<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Bean 的生命周期</title>
      <link href="/2019/12/31/Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/12/31/Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>在分析 Spring Bean 实例化过程中提到 Spring 并不是一启动容器就开启 Bean 的实例化进程，只有当用户调用<code>#getBean(...)</code>方法后，才会触发相应的 Bean 实例化进程。当前，也可以选择直接使用 ApplicationContext 容器，因为该容器启动的时候会立刻调用注册到该容器的所有 Bean 。<br>对于 BeanFactory 而言，并不是所有的<code>#getBean(...)</code>方法都会触发实例化，比如 singleton 类型的 Bean。该类型的 Bean 只会第一次调用<code>#getBean(...)</code>的时候触发，后续则直接在缓存中获取实例对象。</p><p><code>#getBean(...)</code>方法只是 Bean 实例化的入口，真正从处理在 AbstractAutowireCapableBeanFactory 的<code>#doCreateBean(...)</code>中实现，流程如下：</p><p><img src="/images/pasted-42.png" alt="注册流程"></p><p>原来我们采用 new 的方式创建一个对象，用完该对象在脱离作用域后就会被回收，对于后续操作我们无线干涉。但是采取 Spring 容器后，我们完全摆脱了这种命运，Spring 容器将会对锁管理的 Bean 对象，全部给予一个<strong>统一的生命周期</strong>，同时在这个阶段，我们也可以进行干涉。</p><h1 id="1-Bean-实例化"><a href="#1-Bean-实例化" class="headerlink" title="1 Bean 实例化"></a>1 Bean 实例化</h1><p>在<code>#doCreateBean(...)</code>方法中，首先进行 Bean 实例化工作，主要由<code>#createBeanInstance(...)</code>方法实现，该方法返回一个 BeanWrapper 对象。BeanWrapper 对象是 Spring 的一个低级 Bean，具有基础结构的核心接口。为什么说<strong>低级</strong>，因为这个 Bean 还不能被我们使用，连最基本的属性都没有设置。而我们实际开发过程中，一般都不会直接使用该类，而是通过 BeanFactory 隐式的使用。</p><p>BeanWrapper 接口有一个默认实现类 BeanWrapperImple，主要作用是对 Bean 进行包装，然后对这个包装的 Bean 进行操作，比如后续注入属性。</p><p>在实例化 Bean 过程中，Spring 采用<strong>策略模式</strong>来决定使用哪种方法实例化 Bean，一般具有反射和 CGlib 两种。</p><p>InstantiationStrategy 定义了 Bean 实例化策略的抽象接口，其子类 SimpleInstantiationStrategy 提供了基于反射来实例化对象的功能。CglibSubclassingInstantiationStrategy 继承 SimpleInstantiationStrategy，它除了拥有父类以反射实例化对象的功能外，还提供了通过 CGlib 进行动态代理的功能。<strong>默认情况下，Spring 使用 CglibSubclassingInstantiationStrategy</strong>。</p><p>关于 Bean 实例化的详细过程，在前面的文章中已经说明，可以详细的看下。</p><h1 id="2-激活-Aware"><a href="#2-激活-Aware" class="headerlink" title="2 激活 Aware"></a>2 激活 Aware</h1><p>当 Spring 完成 Bean 的实例化并设置相关属性与依赖后，则会开始 Bean 的初始化进程<code>#initializeBean(...)</code>，初始化第一个阶段是检查当前 Bean 对象是否实现了一系列以 Aware 结尾的接口。</p><p>Aware 接口为 Spring 容器的核心接口，是一个具有标识作用的超级接口，实现了该接口的 Bean 是具有被 Spring 容器通知的能力，通知的方法是<strong>回调</strong>。</p><p>在初始化接口，主要是感知 BeanNameAware、BeanClassLoaderAware、BeanFactoryAware。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprivate void invokeAwareMethods(final String beanName, final Object bean) {    if (bean instanceof Aware) {        // BeanNameAware        if (bean instanceof BeanNameAware) {            ((BeanNameAware) bean).setBeanName(beanName);        }        // BeanClassLoaderAware        if (bean instanceof BeanClassLoaderAware) {            ClassLoader bcl = getBeanClassLoader();            if (bcl != null) {                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);            }        }        // BeanFactoryAware        if (bean instanceof BeanFactoryAware) {            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);        }    }}</code></pre><font size=2><ul><li>BeanNameAware：对该 Bean 对象定义的 BeanName 设置到当前对象实例中。</li><li>BeanClassLoaderAware：对当前 Bean 对象相应的 ClassLoader 注入到当前对象实例中。</li><li>BeanFactoryAware：BeanFactoy 容器会将自身注入到当前实例中，这样在当前实例中就有了一个 BeanFactory 容器的引用。</li></ul></font><p>详细可看前面的文章。</p><h1 id="3-BeanPostProcessor"><a href="#3-BeanPostProcessor" class="headerlink" title="3 BeanPostProcessor"></a>3 BeanPostProcessor</h1><p>初始化第二个阶段是 BeanPostProcessor 增强处理，在该阶段 BeanPostProcessor 会处理当前容器内所有符合条件的实例化后的 Bean 对象。它主要是对 Spring 容器提供的 Bean 实例对象进行有效的扩展。允许 Spring 在初始化 Bean 阶段对其进行定制化修改。</p><p>BeanPostProcessor 接口提供了两个方法，在不同的时机执行，分别对应前置处理器和后置处理器。代码如下：</p><pre><code>public interface BeanPostProcessor {    @Nullable    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        return bean;    }    @Nullable    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        return bean;    }}</code></pre><p>详细可看前面的文章。</p><h1 id="4-InitializingBean-和-init-method"><a href="#4-InitializingBean-和-init-method" class="headerlink" title="4 InitializingBean 和 init-method"></a>4 InitializingBean 和 init-method</h1><p>InitializingBean 是一个接口，它为 Spring Bean 的初始化提供了一种方式，它有一个<code>#afterPropertiesSet()</code>方法，在 Bean 的初始化进程中会判断当前 Bean 是否实现了 InitializingBean。如果实现了则调用<code>#afterPropertiesSet()</code>，进行初始化动作。然后在检查是否也指定了<code>init-method</code>，如果指定了则通过反射的方式调用<code>init-method</code>。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)        throws Throwable {    // 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()    boolean isInitializingBean = (bean instanceof InitializingBean);    if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {        if (logger.isTraceEnabled()) {            logger.trace(&quot;Invoking afterPropertiesSet() on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);        }        if (System.getSecurityManager() != null) { // 安全模式            try {                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; {                    // 属性初始化的处理                    ((InitializingBean) bean).afterPropertiesSet();                    return null;                }, getAccessControlContext());            } catch (PrivilegedActionException pae) {                throw pae.getException();            }        } else {            // 属性初始化的处理            ((InitializingBean) bean).afterPropertiesSet();        }    }    if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {        // 判断是否指定了 init-method()，        // 如果指定了 init-method()，则再调用制定的init-method        String initMethodName = mbd.getInitMethodName();        if (StringUtils.hasLength(initMethodName) &amp;&amp;                !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;                !mbd.isExternallyManagedInitMethod(initMethodName)) {            // 激活用户自定义的初始化方法            // 利用反射机制执行            invokeCustomInitMethod(beanName, bean, mbd);        }    }}</code></pre><p>对于 Spring 而言，虽然上面两种都可以实现初始化定义，但是还是更推崇<code>init-method</code>方式。</p><h1 id="5-DisposableBean-和-destroy-method"><a href="#5-DisposableBean-和-destroy-method" class="headerlink" title="5 DisposableBean 和 destroy-method"></a>5 DisposableBean 和 destroy-method</h1><p>与 InitializingBean 和 init-method 对于对象的自定义初始化相似，DisposableBean和 destroy-method 则用于对象的自定义销毁工作。</p><p>当一个 Bean 对象经历了实例化、设置属性、初始化阶段，那么该 Bean 就是对外提供使用了。当完成调用后，如果是 singleton 类型的 Bean，则会看当前 Bean 是否实现了 DisposableBean 接口或者配置了 destroy-method 属性。如果是话就会对该对象注册一个用于对象销毁的毁掉方法。</p><p>但是，并不是对象完成调用后就会立刻执行销毁方法，因为这个时候 Spring 容器还处于运行阶段，只有当 Spring 容器关闭的时候才会去调用。但是 Spring 容器需要我们<strong>主动去告知</strong>。</p><font size=2><ul><li>BeanFactory：需要主动调用<code>#destroySingletons()</code>方法，通知 BeanFactory 容器去执行相应的销毁方法。</li><li>ApplicationContext：需要主动调用<code>#registerShutdownHook()</code>方法。</li></ul></font><h1 id="6-示例"><a href="#6-示例" class="headerlink" title="6 示例"></a>6 示例</h1><p>下面用一个示例在看看上面的执行逻辑。代码如下：</p><pre><code>public class LifeCycleBean implements BeanNameAware,BeanFactoryAware,BeanClassLoaderAware,BeanPostProcessor,        InitializingBean,DisposableBean {    private String test;    public String getTest() {        return test;    }    public void setTest(String test) {        System.out.println(&quot;属性注入....&quot;);        this.test = test;    }    public LifeCycleBean(){ // 构造方法        System.out.println(&quot;构造函数调用...&quot;);    }    public void display(){        System.out.println(&quot;方法调用...&quot;);    }    @Override    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {        System.out.println(&quot;BeanFactoryAware 被调用...&quot;);    }    @Override    public void setBeanName(String name) {        System.out.println(&quot;BeanNameAware 被调用...&quot;);    }    @Override    public void setBeanClassLoader(ClassLoader classLoader) {        System.out.println(&quot;BeanClassLoaderAware 被调用...&quot;);    }    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        System.out.println(&quot;BeanPostProcessor postProcessBeforeInitialization 被调用...&quot;);        return bean;    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        System.out.println(&quot;BeanPostProcessor postProcessAfterInitialization 被调用...&quot;);        return bean;    }    @Override    public void destroy() throws Exception {        System.out.println(&quot;DisposableBean destroy 被调动...&quot;);    }    @Override    public void afterPropertiesSet() throws Exception {        System.out.println(&quot;InitializingBean afterPropertiesSet 被调动...&quot;);    }    public void initMethod(){        System.out.println(&quot;init-method 被调用...&quot;);    }    public void destroyMethdo(){        System.out.println(&quot;destroy-method 被调用...&quot;);    }}</code></pre><p>LifeCycleBean 继承了 BeanNameAware、BeanFactoryAware、BeanClassLoaderAware、BeanPostProcessor、InitializingBean、DisposableBean 六个接口，同时定义了一个 test 属性用于验证属性注入和提供一个<code>#display()</code>方法用于模拟调用。</p><pre><code>&lt;bean id=&quot;lifeCycle&quot; class=&quot;org.springframework.core.test.lifeCycleBean&quot;        init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethdo&quot;&gt;    &lt;property name=&quot;test&quot; value=&quot;test&quot;/&gt;&lt;/bean&gt;</code></pre><p>配置 init-method 和 destroy-method。</p><pre><code>// BeanFactory 容器一定要调用该方法进行 BeanPostProcessor 注册factory.addBeanPostProcessor(new LifeCycleBean()); // 【1】LifeCycleBean lifeCycleBean = (LifeCycleBean) factory.getBean(&quot;lifeCycle&quot;);lifeCycleBean.display();System.out.println(&quot;方法调用完成，容器开始关闭....&quot;);// 关闭容器factory.destroySingletons();</code></pre><p>运行结果如下：</p><pre><code>构造函数调用...构造函数调用...属性注入....BeanNameAware 被调用...BeanClassLoaderAware 被调用...BeanFactoryAware 被调用...BeanPostProcessor postProcessBeforeInitialization 被调用...InitializingBean afterPropertiesSet 被调动...init-method 被调用...BeanPostProcessor postProcessAfterInitialization 被调用...方法调用...方法调用完成，容器开始关闭....DisposableBean destroy 被调动...destroy-method 被调用...</code></pre><p>有两个构造参数调用，是因为在【1】处，我们创建了一个 BeanPostProcessor。</p><p>根据执行的结果我们可以对 Spring Bean 的生命周期如下：<br><font size=2></p><ul><li><ol><li>Spring 容器根据实例化策略对 Bean 进行实例化。</li></ol></li><li><ol start="2"><li>实例化完成后，如果该 Bean 设置了一些属性的话，则利用 set 方法设置一些属性。</li></ol></li><li><ol start="3"><li>如果该 Bean 实现了 BeanNameAware 接口，则调用<code>#setBeanName(...)</code>方法。</li></ol></li><li><ol start="4"><li>如果该 Bean 实现了 BeanClassLoaderAware 接口，则调用<code>setBeanClassLoader(...)</code>方法。</li></ol></li><li><ol start="5"><li>如果该 Bean 实现了 BeanFactoryAware 接口，则调用<code>setBeanFactory(...)</code>方法。</li></ol></li><li><ol start="6"><li>如果该容器注册了 BeanPostProcessor，则会调用<code>#postProcessBeforeInitialization(...)</code>方法，完成 Bean 前置处理。</li></ol></li><li><ol start="7"><li>如果该 Bean 实现了 InitializingBean 接口，则调用<code>#afterPropertiesSet()</code>方法。</li></ol></li><li><ol start="8"><li>如果该 Bean 配置了 init-method，则反射调用指定的方法。</li></ol></li><li><ol start="9"><li>初始化完成后，如果该容器注册了 BeanPostProcessor，则调用<code>#postProcessAfterInitialization(...)</code>方法，完成后置处理。</li></ol></li><li><ol start="10"><li>对象完成初始化，提供使用。</li></ol></li><li><ol start="11"><li>在容器关闭前，如果该 Bean 实现了 DisposableBean 接口，则调用<code>#destroy()</code>方法。</li></ol></li><li><ol start="12"><li>在容器关闭前，如果该 Bean 配置了 destroy-method，则反射调用指定方法。</li></ol></li><li><ol start="13"><li>草他妈的终于完事了，整个 Bean 的生命周期完事了！让它去死把！</li></ol></li></ul></font></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InitializingBean 和 init-method</title>
      <link href="/2019/12/31/InitializingBean-%E5%92%8C-init-method/"/>
      <url>/2019/12/31/InitializingBean-%E5%92%8C-init-method/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>Spring 在 Bean 初始化时进行三个检查扩展，也就是说我们可以对 Bean 进行三个不同的定制化处理，前面的两篇也就是分别对 Aware、BeanPostProcessor 两种进行说明。这篇主要分析最后一种<code>initMethod</code>方法。</p><h1 id="1-InitializingBean"><a href="#1-InitializingBean" class="headerlink" title="1 InitializingBean"></a>1 InitializingBean</h1><p>Spring 的<code>org.springframework.beans.factory.InitializingBean</code>接口，为 Bean 提供了定义初始化方法的方法，它仅包含了一个方法：<code>#afterPropertiesSet()</code>。代码如下：</p><pre><code>public interface InitializingBean {    /**     * 该方法在 BeanFactory 设置完了所有属性之后被调用     * 该方法允许 bean 实例设置了所有 bean 属性时执行初始化工作，如果该过程出现了错误则需要抛出异常     */    void afterPropertiesSet() throws Exception;}</code></pre><p>Spring 在完成实例化后，设置完属性，进行 Aware 接口和 BeanPostProcessor 前置处理后，会接着检测当前 Bean 对象是否实现了<code>InitializingBean</code>接口，如果实现调用<code>#afterPropertiesSet()</code>方法，进一步调整 Bean 实例对象的状态。</p><h2 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h2><pre><code>public class InitializingBeanTest implements InitializingBean {    private String name;    @Override    public void afterPropertiesSet() throws Exception {        System.out.println(&quot;InitializingBeanTest initializing...&quot;);        this.name = &quot;chenssy 2 号&quot;;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><pre><code>&lt;bean id=&quot;initializingBeanTest&quot; class=&quot;org.springframework.core.test.InitializingBeanTest&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;chenssy 1 号&quot;/&gt;&lt;/bean&gt;</code></pre><pre><code>InitializingBeanTest test = (InitializingBeanTest) factory.getBean(&quot;initializingBeanTest&quot;);System.out.println(&quot;name ：&quot; + test.getName());</code></pre><p>运行如下：</p><p><img src="/images/pasted-40.png" alt="运行结果"></p><p>在示例中，改变了 InitializingBeanTest 示例的<code>name</code>属性，也就是说在<code>#afterPropertiesSet()</code>方法中，我们是可以改变 Bean 的属性的，这相当于 Spring 容器又给我们提供了一种可以改变 Bean 实例对象的方法。</p><h2 id="1-2-invokeInitMethods"><a href="#1-2-invokeInitMethods" class="headerlink" title="1.2 invokeInitMethods"></a>1.2 invokeInitMethods</h2><p>上面提到 Bean 初始化阶段，Spring 容器会自动检查当前 Bean 是否已经实现 InitializingBean 接口，如果实现了，则会调用其<code>#afterPropertiesSet()</code>方法，这个主动检查、调用的动作是由<code>#invokeInitMethods(...)</code>方法调用。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)        throws Throwable {    // 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()    boolean isInitializingBean = (bean instanceof InitializingBean);    if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {        if (logger.isTraceEnabled()) {            logger.trace(&quot;Invoking afterPropertiesSet() on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);        }        if (System.getSecurityManager() != null) { // 安全模式            try {                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; {                    // 属性初始化的处理                    ((InitializingBean) bean).afterPropertiesSet();                    return null;                }, getAccessControlContext());            } catch (PrivilegedActionException pae) {                throw pae.getException();            }        } else {            // 属性初始化的处理            ((InitializingBean) bean).afterPropertiesSet();        }    }    if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {        // 判断是否指定了 init-method()，        // 如果指定了 init-method()，则再调用制定的init-method        String initMethodName = mbd.getInitMethodName();        if (StringUtils.hasLength(initMethodName) &amp;&amp;                !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;                !mbd.isExternallyManagedInitMethod(initMethodName)) {            // 激活用户自定义的初始化方法            // 利用反射机制执行            invokeCustomInitMethod(beanName, bean, mbd);        }    }}</code></pre><font size=2><ul><li>首先，检查当前 Bean 是否实现了 InitializingBean 接口，如果实现了则调用<code>#afterPropertiesSet()</code>方法。</li><li>然后，在检查是否也指定了<code>init-method</code>，如果指定了则通过反射机制调用<code>init-method</code>方法。</li></ul></font><p>虽然该接口为 Spring 容器的扩展立下汗马功劳，但是如果真的让我们业务对象来实现这个接口，就显得不那么友好，Spring 的核心理念就是无侵入性。所以 Spring 还提供了另外一种实现的方法<code>init-method</code>方法。</p><h1 id="2-init-method"><a href="#2-init-method" class="headerlink" title="2 init-method"></a>2 init-method</h1><p>在<code>&lt;bean&gt;</code>标签中的<code>init-method</code>属性，可以在 Bean 初始化时指定执行方法，可以用来代替 InitializingBean 接口。</p><h2 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h2><pre><code>public class InitializingBeanTest {    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public void setOtherName(){        System.out.println(&quot;InitializingBeanTest setOtherName...&quot;);        this.name = &quot;chenssy 3 号&quot;;    }}</code></pre><pre><code>&lt;bean id=&quot;initializingBeanTest&quot; class=&quot;org.springframework.core.test.InitializingBeanTest&quot;        init-method=&quot;setOtherName&quot;&gt;    &lt;property name=&quot;name&quot; value=&quot;chenssy 1 号&quot;/&gt;&lt;/bean&gt;</code></pre><p><img src="/images/pasted-41.png" alt="运行结果"></p><p>完全可以达到和 InitializingBean 一样的效果，而且在代码中我们丝毫没有看到 Spring 侵入的现象。所以通过<code>init-method</code>我们可以任意的对业务类进行初始化定制。</p><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>从<code>#invokeInitMethods(...)</code>方法中，我们知道<code>init-method</code>指定的方法会在<code>#afterPropertiesSet()</code>方法之后执行，如果<code>#afterPropertiesSet()</code>出现异常则<code>init-method</code>是不会执行的。而且由于<code>init-method</code>是由反射来实现，所以<code>#afterPropertiesSet()</code>的执行效率能高一些，但是它具有侵入性。<br>至此 InitializingBean 和 init-method 都已经分析完毕，对于 DisposableBean 和 destroy-method，他们和 init相似，这里就不再赘述。</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanPostProcessor</title>
      <link href="/2019/12/31/BeanPostProcessor/"/>
      <url>/2019/12/31/BeanPostProcessor/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><h1 id="1-BeanPostProcessor-接口"><a href="#1-BeanPostProcessor-接口" class="headerlink" title="1 BeanPostProcessor 接口"></a>1 BeanPostProcessor 接口</h1><p>Spring 作为一个优秀的开源框架，它为我们提供了丰富的可扩展点，除了前面提到的 Aware 接口，还包括其他部分，其中一个很重要的就是 BeanPostProcessor。这篇主要介绍 BeanPostProcessor 的使用和实现原理。</p><blockquote><p>BeanPostProcessor 的作用：在 Bean 完成实例化后，如果需要对其进行一些配置，增加一些自己的处理逻辑，那么请使用 BeanPostProcessor。</p></blockquote><h1 id="2-BeanPostProcessor-示例"><a href="#2-BeanPostProcessor-示例" class="headerlink" title="2 BeanPostProcessor 示例"></a>2 BeanPostProcessor 示例</h1><p>首先定义一个类，该类实现<code>BeanPostProcessor</code>接口。代码如下：</p><pre><code>public class BeanPostProcessorTest implements BeanPostProcessor{    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        System.out.println(&quot;Bean [&quot; + beanName + &quot;] 开始初始化&quot;);        // 这里一定要返回 bean，不能返回 null        return bean;    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        System.out.println(&quot;Bean [&quot; + beanName + &quot;] 完成初始化&quot;);        return bean;    }    public void display(){        System.out.println(&quot;hello BeanPostProcessor!!!&quot;);    }}</code></pre><pre><code>ClassPathResource resource = new ClassPathResource(&quot;spring.xml&quot;);DefaultListableBeanFactory factory = new DefaultListableBeanFactory();XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);reader.loadBeanDefinitions(resource);BeanPostProcessorTest test = (BeanPostProcessorTest) factory.getBean(&quot;beanPostProcessorTest&quot;);test.display();</code></pre><p><img src="/images/pasted-35.png" alt="运行结果"></p><p>运行结果比较奇怪，为什么没有执行<code>#postProcessBeforeInitialization(...)</code>和<code>#postProcessAfterInitialization(...)</code>方法？</p><p>我们 debug 下源码，这两个方法在 AbstractAutowireCapableBeanFactory 的<code>#initializeBean(...)</code>方法中调用。如下：</p><p><img src="/images/pasted-36.png" alt="执行代码"></p><p>在<code>#postProcessBeforeInitialization(...)</code>方法中。结果如下：</p><p><img src="/images/pasted-37.png" alt="执行代码"></p><p>这段代码是通过迭代<code>#getBeanPostProcessors()</code>方法返回的结果集来调用 BeanPostProcessor 的<code>#postProcessBeforeInitialization(...)</code>方法，但是在这里我们看到方法返回的结果集为空，所以肯定不会执行相应的方法。我们需要在<code>#getBeanPostProcessors()</code>方法，返回的结果集中存在至少一个元素即可。代码如下：</p><pre><code>// AbstractBeanFactory.java/** BeanPostProcessors to apply in createBean. */private final List&lt;BeanPostProcessor&gt; beanPostProcessors = new CopyOnWriteArrayList&lt;&gt;();public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() {    return this.beanPostProcessors;}</code></pre><p>返回的<code>beanPostProcessors</code>是一个<code>private</code>的 List，也就是只要该类中存在<code>#beanPostProcessors.add(...)</code>的调用就可以。我们在 AbstractBeanFactory 中找到代码：</p><pre><code>// AbstractBeanFactory.java@Overridepublic void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {    Assert.notNull(beanPostProcessor, &quot;BeanPostProcessor must not be null&quot;);    // Remove from old position, if any    this.beanPostProcessors.remove(beanPostProcessor);    // Track whether it is instantiation/destruction aware    if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {        this.hasInstantiationAwareBeanPostProcessors = true;    }    if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {        this.hasDestructionAwareBeanPostProcessors = true;    }    // Add to end of list    this.beanPostProcessors.add(beanPostProcessor);}</code></pre><p>该方法是由 AbstractBeanFactory 的父类，<code>org.springframework.beans.factory.config.ConfigurableBeanFactory</code>接口定义，它的核心思想就是将制定的 BeanPostProcessor 注册到该 BeanFactory 创建的 Bean 中。同时它是<strong>按照插入顺序进行注册</strong>，完全忽略了 Order 接口锁表达的任何排序语义。</p><p>到这里，已经很清晰了，我们只需要手动的调用<code>#addBeanPostProcessor(...)</code>方法就可以。加入代码：</p><pre><code>BeanPostProcessorTest beanPostProcessorTest = new BeanPostProcessorTest();factory.addBeanPostProcessor(beanPostProcessorTest);</code></pre><h1 id="3-BeanPostProcessor-基本原理"><a href="#3-BeanPostProcessor-基本原理" class="headerlink" title="3 BeanPostProcessor 基本原理"></a>3 BeanPostProcessor 基本原理</h1><p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口，代码如下：</p><pre><code>public interface BeanPostProcessor {    @Nullable    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        return bean;    }    @Nullable    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        return bean;    }}</code></pre><p>BeanPostProcessor 可以理解成是 Spring 是一个工厂钩子，它是 Spring 提供的对象实例化阶段强有力的扩展点，允许 Spring 在实例化 Bean 阶段对其进行定制化修改，比较常见的使用水处理标记接口实现类，或者为当前对象提供代理实现（AOP）。<br>一般普通的 BeanFactory 是不支持自定注册 BeanPostProcessor 的，需要我们手动的调用<code>#addBeanPostProcessor(...)</code>方法进行注册。注册后的 BeanPostProcessor 适用于所有该 BeanFactory 创建的 Bean，但是<strong>ApplicationContext 可以在其中自动检测所有的 BeanPostProcessor 并自动完成注册，同时将它们应用到随后创建的任何 Bean 中</strong>。</p><p><code>#postProcessBeforeInitialization(...)</code>和<code>#postProcessAfterInitialization(...)</code>两个方法，都能接收一个 Object 类型的 Bean。一个 String 类型的 BeanName，其中 Bean 是已经实例化的<code>instanceBean</code>，这两个两发的初始化 Bean 的前后处理器。它们应用<code>#invokeInitMethods(...)</code>方法的前后。如下图：</p><p><img src="/images/pasted-39.png" alt="流程"></p><p>两者源码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.java@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)        throws BeansException {    Object result = existingBean;    // 遍历 BeanPostProcessor 数组    for (BeanPostProcessor processor : getBeanPostProcessors()) {        // 处理        Object current = processor.postProcessBeforeInitialization(result, beanName);        // 返回空，则返回 result        if (current == null) {            return result;        }        // 修改 result        result = current;    }    return result;}@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)        throws BeansException {    Object result = existingBean;    // 遍历 BeanPostProcessor    for (BeanPostProcessor processor : getBeanPostProcessors()) {        // 处理        Object current = processor.postProcessAfterInitialization(result, beanName);        // 返回空，则返回 result        if (current == null) {            return result;        }        // 修改 result        result = current;    }    return result;}</code></pre><h2 id="3-1-自动检测并注册"><a href="#3-1-自动检测并注册" class="headerlink" title="3.1 自动检测并注册"></a>3.1 自动检测并注册</h2><p><code>#getBeanPostProcessors()</code>方法，返回的是<code>beanPostProcessors</code>集合，该集合里面存放就是我们自定义的 BeanPostProcessor，如果该集合中存在元素，则调用相对应方法，否则直接返回 Bean。而<code>BeanFactory</code>如果想使用必须手动的调用<code>#addBeanPostProcessor(...)</code>方法，将后置处理器增加到集合中。<strong>但是 ApplicationContext 并不需要手动，可以自动检测并注册</strong>。</p><p>ApplicationContext 实现自动的原因，在于我们构造一个 ApplicationContext 实例对象的时候回调用<code>#registerBeanPostProcessors(...)</code>方法，将检测到的 BeanPostProcessor 注入到 ApplicationContext 容器中，同时应用到该容器创建的 Bean 中。代码如下：</p><pre><code>// AbstractApplicationContext.java/** * 实例化并调用已经注入的 BeanPostProcessor * 必须在应用中 bean 实例化之前调用 */protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);}// PostProcessorRegistrationDelegate.javapublic static void registerBeanPostProcessors(        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {    // 获取所有的 BeanPostProcessor 的 beanName    // 这些 beanName 都已经全部加载到容器中去，但是没有实例化    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);    // Register BeanPostProcessorChecker that logs an info message when    // a bean is created during BeanPostProcessor instantiation, i.e. when    // a bean is not eligible for getting processed by all BeanPostProcessors.    // 记录所有的beanProcessor数量    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;    // 注册 BeanPostProcessorChecker，它主要是用于在 BeanPostProcessor 实例化期间记录日志    // 当 Spring 中高配置的后置处理器还没有注册就已经开始了 bean 的实例化过程，这个时候便会打印 BeanPostProcessorChecker 中的内容    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));    // Separate between BeanPostProcessors that implement PriorityOrdered,    // Ordered, and the rest.    // PriorityOrdered 保证顺序    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();    // MergedBeanDefinitionPostProcessor    List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();    // 使用 Ordered 保证顺序    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();    // 没有顺序    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();    for (String ppName : postProcessorNames) {        // PriorityOrdered        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {            // 调用 getBean 获取 bean 实例对象            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);            priorityOrderedPostProcessors.add(pp);            if (pp instanceof MergedBeanDefinitionPostProcessor) {                internalPostProcessors.add(pp);            }        } else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {            // 有序 Ordered            orderedPostProcessorNames.add(ppName);        } else {            // 无序            nonOrderedPostProcessorNames.add(ppName);        }    }    // First, register the BeanPostProcessors that implement PriorityOrdered.    // 第一步，注册所有实现了 PriorityOrdered 的 BeanPostProcessor    // 先排序    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);    // 后注册    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);    // Next, register the BeanPostProcessors that implement Ordered.    // 第二步，注册所有实现了 Ordered 的 BeanPostProcessor    List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();    for (String ppName : orderedPostProcessorNames) {        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);        orderedPostProcessors.add(pp);        if (pp instanceof MergedBeanDefinitionPostProcessor) {            internalPostProcessors.add(pp);        }    }    // 先排序    sortPostProcessors(orderedPostProcessors, beanFactory);    // 后注册    registerBeanPostProcessors(beanFactory, orderedPostProcessors);    // Now, register all regular BeanPostProcessors.    // 第三步注册所有无序的 BeanPostProcessor    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();    for (String ppName : nonOrderedPostProcessorNames) {        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);        nonOrderedPostProcessors.add(pp);        if (pp instanceof MergedBeanDefinitionPostProcessor) {            internalPostProcessors.add(pp);        }    }    // 注册，无需排序    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);    // Finally, re-register all internal BeanPostProcessors.    // 最后，注册所有的 MergedBeanDefinitionPostProcessor 类型的 BeanPostProcessor    sortPostProcessors(internalPostProcessors, beanFactory);    registerBeanPostProcessors(beanFactory, internalPostProcessors);    // Re-register post-processor for detecting inner beans as ApplicationListeners,    // moving it to the end of the processor chain (for picking up proxies etc).    // 加入ApplicationListenerDetector（探测器）    // 重新注册 BeanPostProcessor 以检测内部 bean，因为 ApplicationListeners 将其移动到处理器链的末尾    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));}</code></pre><p>方法首先获取到该 BeanFactory 中所有 BeanPostProcessor 类型的 BeanName数组。其实就是找所有实现 BeanPostProcessor 接口的 Bean，然后遍历这些 Bean，将按照指定的排序添加到相应的 List 集合中。</p><h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h1><p>至此，BeanPostProcessor 已经分析完毕了，这里简单的总结下：</p><font size=2><ul><li><ol><li>BeanPostProcessor 的作用域是容器级，它只和所在的容器相关，当 BeanPostProcessor 完成注册后，它会应用在它所在容器的所有 Bean 中。</li></ol></li><li><ol start="2"><li>BeanFactory 和 ApplicationContext 对 BeanPostProcessor 的处理不同。ApplicationContext 会自动检测并注册 BeanPostProcessor。</li></ol></li><li><ol start="3"><li>ApplicationContext 的 BeanPostProcessor 支持 Ordered 排序。而 BeanFactory 是不支持的。</li></ol></li></ul></font></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aware 接口</title>
      <link href="/2019/12/31/Aware-%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/12/31/Aware-%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>AbstractAutowireCapableBeanFactory 的<code>#doCreateBean(...)</code>方法，主要做三件事：</p><font size=2><ul><li>实例化 Bean 对象：<code>#createBeanInstance(...)</code>方法。</li><li>属性注入：<code>#populateBean(...)</code>方法。</li><li>初始化 Bean 对象：<code>#initializeBean(...)</code>方法。</li></ul></font><p>而<strong>初始化 Bean 对象时</strong>也是做三件事：</p><font size=2><ul><li>激活 Aware 方法。</li><li>后置处理器的应用。</li><li>激活自定义的 init 方法。</li></ul></font><p>接下来三篇，就是描述这三件事情。</p><h1 id="1-Aware-接口"><a href="#1-Aware-接口" class="headerlink" title="1 Aware 接口"></a>1 Aware 接口</h1><p><code>org.springframework.beans.factory.Aware</code> 接口。定义如下：</p><pre><code>public interface Aware {}</code></pre><p>Aware 接口为 Spring 容器的核心接口，是一个具有表示作用的超级接口，实现了该接口的 Bean 是具有被 Spring 容器<strong>通知的能力</strong>，通知的方式是采用<strong>回调</strong>。  </p><p>Aware 接口是一个空接口，实际的方法签名由各个子接口来确定，且该接口通常只会有一个接口单参数的 set 方法，该 set 方法的命名方式为：set + 去掉接口命中 Aware 后缀。即 XxxAware 接口，通常方法定义为 setXxx()。    </p><p>Aware 的子接口需要提供一个<code>setXxx()</code>方法，我们知道 set 是设置属性值的方法，Aware 的含义是感知的，感应的。那么在 Spring 容器中是如何实现感知并设置属性值得呢？我们可以从初始化 Bean 中激活 Aware 方法<code>#invokeAwareMethods(...)</code>方法中看到一点。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprivate void invokeAwareMethods(final String beanName, final Object bean) {    if (bean instanceof Aware) {        // BeanNameAware        if (bean instanceof BeanNameAware) {            ((BeanNameAware) bean).setBeanName(beanName);        }        // BeanClassLoaderAware        if (bean instanceof BeanClassLoaderAware) {            ClassLoader bcl = getBeanClassLoader();            if (bcl != null) {                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);            }        }        // BeanFactoryAware        if (bean instanceof BeanFactoryAware) {            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);        }    }}</code></pre><p>首先，判断 Bean 是否的 Aware 接口的实现。如果是的话，则调用<code>setXxx()</code>方法，给实例设置属性值。在<code>#invokeAwareMethods(...)</code>方法中，主要设置 beanName、beanClassLoader、beanFactory三个属性值。</p><h1 id="2-Aware-子类"><a href="#2-Aware-子类" class="headerlink" title="2 Aware 子类"></a>2 Aware 子类</h1><p>Spring 提供了一系列的 Aware 接口。如下图。</p><p><img src="/images/pasted-32.png" alt="Aware 子类"></p><p>上面只是一部分子类，从这里我们可以看到 Spring 提供的 Aware 接口是何其多。同时从上图我们也可以看到几个熟悉的接口，如：BeanClassloaderAware、BeanFactoryAware、BeanNameAware。</p><pre><code>public interface BeanClassLoaderAware extends Aware {    /**    * 将 BeanClassLoader 提供给 bean 实例回调    * 在 bean 属性填充之后、初始化回调之前回调，    * 例如InitializingBean的InitializingBean.afterPropertiesSet（）方法或自定义init方法    */    void setBeanClassLoader(ClassLoader classLoader);}public interface BeanFactoryAware extends Aware {    /**    * 将 BeanFactory 提供给 bean 实例回调    * 调用时机和 setBeanClassLoader 一样    */    void setBeanFactory(BeanFactory beanFactory) throws BeansException;}public interface BeanNameAware extends Aware {    /**    * 在创建此 bean 的 bean工厂中设置 beanName    */    void setBeanName(String name);}public interface ApplicationContextAware extends Aware {    /**     * 设置此 bean 对象的 ApplicationContext，通常，该方法用于初始化对象     */    void setApplicationContext(ApplicationContext applicationContext)        throws BeansException;}</code></pre><h2 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h2><pre><code>public class MyApplicationAware implements BeanNameAware,BeanFactoryAware,BeanClassLoaderAware,ApplicationContextAware{    private String beanName;    private BeanFactory beanFactory;    private ClassLoader classLoader;    private ApplicationContext applicationContext;    @Override    public void setBeanClassLoader(ClassLoader classLoader) {        System.out.println(&quot;调用了 BeanClassLoaderAware 的 setBeanClassLoader 方法&quot;);        this.classLoader = classLoader;    }    @Override    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {        System.out.println(&quot;调用了 BeanFactoryAware 的 setBeanFactory 方法&quot;);        this.beanFactory = beanFactory;    }    @Override    public void setBeanName(String name) {        System.out.println(&quot;调用了 BeanNameAware 的 setBeanName 方法&quot;);        this.beanName = name;    }    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        System.out.println(&quot;调用了 ApplicationContextAware 的 setApplicationContext 方法&quot;);        this.applicationContext = applicationContext;    }    public void display(){        System.out.println(&quot;beanName:&quot; + beanName);        System.out.println(&quot;是否为单例：&quot; + beanFactory.isSingleton(beanName));        System.out.println(&quot;系统环境为：&quot; + applicationContext.getEnvironment());    }}</code></pre><pre><code>public static void main(String[] args) {    ClassPathResource resource = new ClassPathResource(&quot;spring.xml&quot;);    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);    reader.loadBeanDefinitions(resource);    MyApplicationAware applicationAware = (MyApplicationAware) factory.getBean(&quot;myApplicationAware&quot;);    applicationAware.display();}</code></pre><p><img src="/images/pasted-33.png" alt="运行结果"></p><p>从该运行结果可以看出，这里只执行了三个 Aware 接口的 set 方法，原因就是通过<code>#getBean(...)</code>方法调用时，在激活 Aware 接口时只检测了 BeanNameAware、BeanClassloaderAware、BeanFactoryAware 三个 Aware 接口。如果将测试方法调整如下：</p><pre><code>public static void main(String[] args) {    ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);    MyApplicationAware applicationAware = (MyApplicationAware) applicationContext.getBean(&quot;myApplicationAware&quot;);    applicationAware.display();}</code></pre><p><img src="/images/pasted-34.png" alt="运行结果"></p><p>我们看到运行结果一致。可以说明是 Spring 容器自动将相关的 Aware 属性 set 到了我们需要的 Bean 中。</p><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>到这里我们基本可以知道 Aware 真正的含义是什么了。其实是 Spring 容器在初始化主动监测当前 Bean 是否实现了 Aware 接口。如果实现了则回调其 set 方法将相应的参数设置给 Bean。</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建 Bean 总结</title>
      <link href="/2019/12/27/%E5%88%9B%E5%BB%BA-Bean-%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/27/%E5%88%9B%E5%BB%BA-Bean-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>在前面，我们详细分析了一个配置文件到底经历的哪些过程转变成一个 BeanDefinition，但是这个 BeanDefinition 并不是真正想使用的 Bean，因为它还仅仅只是承载了我们需要的目标 Bean 的信息。  </p><p>从 BeanDefinition 到我们需要的目标 Bean 还有一个漫长的初始化阶段。在这里我们做一个<strong>概括性总结</strong>。  </p><p>Bean 的初始化阶段，由第一次隐式或显式的调用<code>#getBean(...)</code>方法来开启，所以我们从这个方法开始。代码如下：</p><pre><code>// AbstractBeanFactory.javapublic Object getBean(String name) throws BeansException {    return doGetBean(name, null, null, false);}protected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {    // 【1】 返回 bean 名称，剥离工厂引用前缀。    // 如果 name 是 alias ，则获取对应映射的 beanName 。    final String beanName = transformedBeanName(name);    Object bean;    // 从缓存中或者实例工厂中获取 Bean 对象    // Eagerly check singleton cache for manually registered singletons.    Object sharedInstance = getSingleton(beanName);    if (sharedInstance != null &amp;&amp; args == null) {        if (logger.isTraceEnabled()) {            if (isSingletonCurrentlyInCreation(beanName)) {                logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +                        &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);            } else {                logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);            }        }        // 【2】 完成 FactoryBean 的相关处理，并用来获取 FactoryBean 的处理结果        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);    } else {        // 【3】 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常。        if (isPrototypeCurrentlyInCreation(beanName)) {            throw new BeanCurrentlyInCreationException(beanName);        }        // 【4】 如果容器中没有找到，则从父类容器中加载        BeanFactory parentBeanFactory = getParentBeanFactory();        if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {            // Not found -&gt; check parent.            String nameToLookup = originalBeanName(name);            if (parentBeanFactory instanceof AbstractBeanFactory) {                return ((AbstractBeanFactory) parentBeanFactory).doGetBean(                        nameToLookup, requiredType, args, typeCheckOnly);            } else if (args != null) {                // Delegation to parent with explicit args.                return (T) parentBeanFactory.getBean(nameToLookup, args);            } else if (requiredType != null) {                // No args -&gt; delegate to standard getBean method.                return parentBeanFactory.getBean(nameToLookup, requiredType);            } else {                return (T) parentBeanFactory.getBean(nameToLookup);            }        }        // 【5】 如果不是仅仅做类型检查则是创建bean，这里需要记录         if (!typeCheckOnly) {            markBeanAsCreated(beanName);        }        try {            // 【6】 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);            // 检查给定的合并的 BeanDefinition            checkMergedBeanDefinition(mbd, beanName, args);            // 【7】 处理所依赖的 bean            String[] dependsOn = mbd.getDependsOn();            if (dependsOn != null) {                for (String dep : dependsOn) {                    // 若给定的依赖 bean 已经注册为依赖给定的 bean                    // 循环依赖的情况                    if (isDependent(beanName, dep)) {                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                                &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);                    }                    // 缓存依赖调用 TODO 芋艿                    registerDependentBean(dep, beanName);                    try {                        getBean(dep);                    } catch (NoSuchBeanDefinitionException ex) {                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                                &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);                    }                }            }            // 【8】 bean 实例化            if (mbd.isSingleton()) { // 单例模式                sharedInstance = getSingleton(beanName, () -&gt; {                    try {                        return createBean(beanName, mbd, args);                    }                    catch (BeansException ex) {                        // Explicitly remove instance from singleton cache: It might have been put there                        // eagerly by the creation process, to allow for circular reference resolution.                        // Also remove any beans that received a temporary reference to the bean.                        // 显式从单例缓存中删除 Bean 实例                        // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它。 TODO 芋艿                        destroySingleton(beanName);                        throw ex;                    }                });                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);            } else if (mbd.isPrototype()) { // 原型模式                // It&#39;s a prototype -&gt; create a new instance.                Object prototypeInstance;                try {                    beforePrototypeCreation(beanName);                    prototypeInstance = createBean(beanName, mbd, args);                } finally {                    afterPrototypeCreation(beanName);                }                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);            } else {                // 从指定的 scope 下创建 bean                String scopeName = mbd.getScope();                final Scope scope = this.scopes.get(scopeName);                if (scope == null) {                    throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);                }try {                    Object scopedInstance = scope.get(beanName, () -&gt; {                        beforePrototypeCreation(beanName);                        try {                            return createBean(beanName, mbd, args);                        } finally {                            afterPrototypeCreation(beanName);                        }                    });                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);                } catch (IllegalStateException ex) {                    throw new BeanCreationException(beanName,                            &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +                            &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,                            ex);                }            }        } catch (BeansException ex) {            cleanupAfterBeanCreationFailure(beanName);            throw ex;        }    }    // 【9】 检查需要的类型是否符合 bean 的实际类型    if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {        try {            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);            if (convertedBean == null) {                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());            }            return convertedBean;        } catch (TypeMismatchException ex) {            if (logger.isTraceEnabled()) {                logger.trace(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +                        ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);            }            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());        }    }    return (T) bean;}</code></pre><p>内部调用<code>#doGetBean(...)</code>方法。<code>#doGetBean(...)</code>方法的代码量比较多，并且是一个复杂的过程，但是大致可以分为以下几个过程：</p><font size=2><ul><li><ol><li>转换 BeanName。因为我们调用<code>#getBean(...)</code>方法传入的<code>name</code>，并不一定就是 BeanName，也可能是 AliasName、FactoryBean。所以这里还要进行一次简单的转换。</li></ol></li><li><ol start="2"><li>尝试从缓存中加载单例 Bean。</li></ol></li><li><ol start="3"><li>Bean 的实例化。</li></ol></li><li><ol start="4"><li>原型模式的依赖检查，因为 Spring 只会解决单例模式的循环依赖，对于原型模式的循环依赖直接抛出异常。</li></ol></li><li><ol start="5"><li>尝试从 parentBeanFactory 获取 Bean 实现。如果<code>parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)</code>则尝试从 parentBeanFactory 中获取 Bean 实例对象。因为<code>!containsBeanDefinition(beanName)</code>就意味着定义的 xml 文件中没有 BeanName 的相关配置，这个时候只能从<code>parentBeanFactory</code>中获取。</li></ol></li><li><ol start="6"><li>获取 RootBeanDefinition，并对其进行合并检查。从缓存中获取已经解析的 RootBeanDefinition。同时，如果父类不为<code>null</code>的话，则会合并父类的属性。</li></ol></li><li><ol start="7"><li>依赖检查。某个 Bean 依赖其他的 Bean，则需要优先加载被依赖的 Bean。</li></ol></li><li><ol start="8"><li>对不同的 scope 进行处理。</li></ol></li><li><ol start="9"><li>类型转换处理。如果传递的<code>requireType</code>不为<code>null</code>，则需要检测所得到的的 Bean 的类型会否与该<code>requireType</code>一致。如果不一致尝试转换，转换失败抛出异常。</li></ol></li></ul></font><p>下面就一下几个方面，说明 Spring Bean 的加载过程。</p><font size=2><ul><li><ol><li>从缓存获取 Bean。</li></ol></li><li><ol start="2"><li>创建 Bean 实例对象。</li></ol></li><li><ol start="3"><li>从 Bean 实例中获取对象。</li></ol></li></ul></font><h1 id="1-从缓存获取-Bean"><a href="#1-从缓存获取-Bean" class="headerlink" title="1 从缓存获取 Bean"></a>1 从缓存获取 Bean</h1><p>Spring 中根据 scope的不同可以将 Bean 分为几类：singleton、prototype和其他。这样分的目的在于 Spring 对于不同的 scope 处理是不同的。</p><font size=2><ul><li>singleton：在 Spring 的 IoC 容器中只会存在一个对象实例，所有的对象的引用都共享着个实例。Spring 容器只会创建该 Bean 定义的唯一实例，这个实例会被保存到缓存中，并且对该 Bean 的所有后续请求和引用都从缓存中获取。</li><li>prototype：原型 Bean，每次对该 Bean 的请求都会创建一个新的实例。</li><li>其他：<ul><li>request：每次 http 请求都会创建一个 Bean 实例。</li><li>session：在一个 http session 中，创建一个 Bean 实例。</li><li>global session：在一个全局的 http session 中，创建一个 Bean 实例。</li></ul></li></ul></font><p>所以，从缓存中获取的 Bean 一定是 singleton Bean，这也是 Spring 为何只解决 singleton Bean 的循环依赖。调用<code>#getSingleton(...)</code>方法，从缓存中获取。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.javapublic Object getSingleton(String beanName) {    return getSingleton(beanName, true);}@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) {    // 从单例缓冲中加载 bean    Object singletonObject = this.singletonObjects.get(beanName);    // 缓存中的 bean 为空，且当前 bean 正在创建    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {        // 加锁        synchronized (this.singletonObjects) {            // 从 earlySingletonObjects 获取            singletonObject = this.earlySingletonObjects.get(beanName);            // earlySingletonObjects 中没有，且允许提前创建            if (singletonObject == null &amp;&amp; allowEarlyReference) {                // 从 singletonFactories 中获取对应的 ObjectFactory                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);                if (singletonFactory != null) {                    // 获得 bean                    singletonObject = singletonFactory.getObject();                    // 添加 bean 到 earlySingletonObjects 中                    this.earlySingletonObjects.put(beanName, singletonObject);                    // 从 singletonFactories 中移除对应的 ObjectFactory                    this.singletonFactories.remove(beanName);                }            }        }    }    return singletonObject;}</code></pre><p>该方法就是从<code>singletonObjects</code>、<code>earlySingletonObjects</code>、<code>singletonFactories</code>三个缓存中获取，这里也是<strong>Spring 解决循环依赖的关键之处</strong>。</p><h1 id="2-创建-Bean-实例对象"><a href="#2-创建-Bean-实例对象" class="headerlink" title="2 创建 Bean 实例对象"></a>2 创建 Bean 实例对象</h1><p>如果缓存中没有，也没有<code>parentBeanFactory</code>，则会调用<code>#createBean(...)</code>方法，创建 Bean 实例。该方法主要是在处理不同 scope 的 Bean 的时候进行调用。代码如下：</p><pre><code>// AbstractBeanFactory.javaprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)            throws BeanCreationException;</code></pre><p>该方法是定义在 AbstractBeanFactory 中的抽象方法，其含义是根据给定的 BeanDefinition 和 args 实例化一个 Bean 对象。如果该 BeanDefinition 存在父类，则该 BeanDefinition 合并父类的属性。所有 Bean 实例的创建都会委托给该方法实现。</p><font size=2><ul><li>方法接收三个参数：<ul><li>beanName：bean 的名称。</li><li>mbd：已经合并了父类属性的 BeanDefinition。</li><li>args：用于构造函数或者工厂方法创建 Bean 实例对象的参数。</li></ul></li></ul></font><p>该抽象方法的<strong>默认实现</strong>是在 AbstractAutowireCapableBeanFactory 中实现，该方法其实只是会一些检查和验证工作，真正的初始化由<code>#doCreateBean(...)</code>方法实现。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)        throws BeanCreationException {    // BeanWrapper 是对 Bean 的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装 bean 的属性描述器    BeanWrapper instanceWrapper = null;    // 【1】 单例模型，则从未完成的 FactoryBean 缓存中删除    if (mbd.isSingleton()) {        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);    }    // 【2】 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化    if (instanceWrapper == null) {        instanceWrapper = createBeanInstance(beanName, mbd, args);    }    // 包装的实例对象    final Object bean = instanceWrapper.getWrappedInstance();    // 包装的实例对象的类型    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();    if (beanType != NullBean.class) {        mbd.resolvedTargetType = beanType;    }    // 【3】 判断是否有后置处理    // 如果有后置处理，则允许后置处理修改 BeanDefinition    synchronized (mbd.postProcessingLock) {        if (!mbd.postProcessed) {            try {                // 后置处理修改 BeanDefinition                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);            } catch (Throwable ex) {                throw new BeanCreationException(mbd.getResourceDescription(), beanName,                        &quot;Post-processing of merged bean definition failed&quot;, ex);            }            mbd.postProcessed = true;        }    }    // 【4】 解决单例模式的循环依赖    boolean earlySingletonExposure = (mbd.isSingleton() // 单例模式            &amp;&amp; this.allowCircularReferences // 运行循环依赖            &amp;&amp; isSingletonCurrentlyInCreation(beanName)); // 当前单例 bean 是否正在被创建    if (earlySingletonExposure) {        if (logger.isTraceEnabled()) {            logger.trace(&quot;Eagerly caching bean &#39;&quot; + beanName +                    &quot;&#39; to allow for resolving potential circular references&quot;);        }        // 提前将创建的 bean 实例加入到 singletonFactories 中        // 这里是为了后期避免循环依赖        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));    }    // 开始初始化 bean 实例对象    Object exposedObject = bean;    try {        // 【5】 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性        // 则会递归初始依赖 bean        populateBean(beanName, mbd, instanceWrapper);        // 【6】 调用初始化方法        exposedObject = initializeBean(beanName, exposedObject, mbd);    } catch (Throwable ex) {        if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {            throw (BeanCreationException) ex;        } else {            throw new BeanCreationException(                    mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);        }    }    // 【7】 循环依赖处理    if (earlySingletonExposure) {        // 获取 earlySingletonReference        Object earlySingletonReference = getSingleton(beanName, false);        // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空        if (earlySingletonReference != null) {            // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强            if (exposedObject == bean) {                exposedObject = earlySingletonReference;            // 处理依赖            } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {                String[] dependentBeans = getDependentBeans(beanName);                Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);                for (String dependentBean : dependentBeans) {                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {                        actualDependentBeans.add(dependentBean);                    }                }                if (!actualDependentBeans.isEmpty()) {                    throw new BeanCurrentlyInCreationException(beanName,                            &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +                            &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +                            &quot;wrapped. This means that said other beans do not use the final version of the &quot; +                            &quot;bean. This is often the result of over-eager type matching - consider using &quot; +                            &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);                }            }        }    }    // 【8】 注册 bean    try {        registerDisposableBeanIfNecessary(beanName, bean, mbd);    } catch (BeanDefinitionValidationException ex) {        throw new BeanCreationException(                mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);    }    return exposedObject;}</code></pre><p><code>#doCreateBean(...)</code>是创建 Bean 实例的核心方法，它的整理思路是：</p><font size=2><ul><li>【1】处，如果是单例模式，则清楚<code>factoryBeanInstanceCache</code>缓存，同时返回 BeanWrapper 实例对象。</li><li>【2】处，如果缓存中没有 BeanWrapper 或者不是单例模式，则调用<code>#createBeanInstance(...)</code>方法，实例化 Bean，主要是将 BeanDefinition 转换为 BeanWrapper。</li><li>【3】处，MergedBeanDefinitionPostProcessor 的应用。</li><li>【4】处，单例模式的循环依赖处理。</li><li>【5】处，调用<code>#populateBean(...)</code>方法进行属性填充，将所有属性填充到 Bean 实例中。</li><li>【6】处，调用<code>#initializeBean(...)</code>方法，初始化 Bean。</li><li>【7】处，依赖检查。</li><li>【8】处，注册 DisposableBean。</li></ul></font><h2 id="2-1-实例化-Bean"><a href="#2-1-实例化-Bean" class="headerlink" title="2.1 实例化 Bean"></a>2.1 实例化 Bean</h2><p>如果缓存中没有 BeanWrapper 实例对象或者该 Bean 不是 singleton，则调用<code>#createBeanInstance(...)</code>方法。创建 Bean 实例，该方法主要是根据参数 BeanDefinition、args 来调用构造函数实例化 Bean 对象，<strong>过程较为复杂</strong>。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {    // Make sure bean class is actually resolved at this point.    // 解析 bean ，将 bean 类名解析为 class 引用。    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);    if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) { // 校验        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());    }    // 【1】 如果存在 Supplier 回调，则使用给定的回调方法初始化策略    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();    if (instanceSupplier != null) {        return obtainFromSupplier(instanceSupplier, beanName);    }    // 【2】 使用 FactoryBean 的 factory-method 来创建，支持静态工厂和实例工厂    if (mbd.getFactoryMethodName() != null)  {        return instantiateUsingFactoryMethod(beanName, mbd, args);    }    // 【3】 Shortcut when re-creating the same bean...    boolean resolved = false;    boolean autowireNecessary = false;    if (args == null) {        // constructorArgumentLock 构造函数的常用锁        synchronized (mbd.constructorArgumentLock) {            // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析            // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制            if (mbd.resolvedConstructorOrFactoryMethod != null) {                resolved = true;                autowireNecessary = mbd.constructorArgumentsResolved;            }        }    }    // 已经解析好了，直接注入即可    if (resolved) {        // &lt;3.1&gt; autowire 自动注入，调用构造函数自动注入        if (autowireNecessary) {            return autowireConstructor(beanName, mbd, null, null);        } else {            // &lt;3.2&gt; 使用默认构造函数构造            return instantiateBean(beanName, mbd);        }    }    // 【4】 确定解析的构造函数    // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);    // 【4.1】 有参数情况时，创建 Bean 。先利用参数个数，类型等，确定最精确匹配的构造方法。    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {        return autowireConstructor(beanName, mbd, ctors, args);    }    // 【4.1】 选择构造方法，创建 Bean 。    ctors = mbd.getPreferredConstructors();    if (ctors != null) {        return autowireConstructor(beanName, mbd, ctors, null); // args = null    }    // 【4.2】 有参数时，又没获取到构造方法，则只能调用无参构造方法来创建实例了(兜底方法)    return instantiateBean(beanName, mbd);}</code></pre><p>实例化 Bean 对象，是一个复杂的过程，主要过程：</p><font size=2><ul><li>【1】处，如果存在 Supplier 回调，则调用<code>#obtainFromSupplier(...)</code>方法，进行初始化。</li><li>【2】处，如果存在工厂方法，则使用工行方法进行初始化。</li><li>【3】处，首先判断缓存，如果<strong>缓存存在</strong>，即已经解析过了，则直接使用缓存中的，根据<code>constructorArgumentsResolved</code>参数来判断。<ul><li>【3.1】处，使用构造函数自动注入。</li><li>【3.2】处，使用默认构造函数注入。</li></ul></li><li>【4】处，如果<strong>缓存没有</strong>，则需要先确定使用哪一个构造函数来完成解析工作，因为一个类可能有多个构造函数。<ul><li>【4.1】处，如果存在参数，使用相匹配的构造函数。</li><li>【4.2】处，否则使用默认构造函数。</li></ul></li></ul></font><p>其实核心还是在于根据不同的情况，执行不同的实例化策略，主要包括四种策略：</p><font size=2><ul><li>Supplier回调。</li><li><code>#instantiateUsingFactoryMethod(...)</code>方法，工厂方法初始化。</li><li><code>#autowireConstructor(...)</code>方法，构造函数自动注入初始化。</li><li><code>#instantiateBean(...)</code>方法，默认构造函数初始化。</li></ul></font><p>其实无论哪种策略，他们是实现逻辑都差不多：确定构造函数和构造参数，然后实例化。只不过相对于 Supplier 回调和默认构造而言，工厂方法初始化和构造函数初始化比较复杂。复杂的点也只在于如何确定构造函数和构造参数。<br>如果实例化的 Bean 包含<code>override</code>重写方法，就需要<strong>CGLIB</strong>动态代理来实例化，否则直接反射。</p><h2 id="2-2-属性填充"><a href="#2-2-属性填充" class="headerlink" title="2.2 属性填充"></a>2.2 属性填充</h2><p>属性填充其实就是将 BeanDefinition 的属性值复制给 BeanWrapper 实例对象的过程。在填充的过程需要根据注入的类型来区分是根据名称注入，还是类型注入。当前这个过程<strong>还会涉及循环依赖问题</strong>。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {    // 没有实例化对象    if (bw == null) {        // 有属性，则抛出 BeanCreationException 异常        if (mbd.hasPropertyValues()) {            throw new BeanCreationException(                    mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);            // 没有属性，直接 return 返回        } else {            // Skip property population phase for null instance.            return;        }    }    // 【1】 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会    boolean continueWithPropertyPopulation = true;    if (!mbd.isSynthetic()  // bean 不是&quot;合成&quot;的，即未由应用程序本身定义            &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { // 是否持有 InstantiationAwareBeanPostProcessor        // 迭代所有的 BeanPostProcessors        for (BeanPostProcessor bp : getBeanPostProcessors()) {            if (bp instanceof InstantiationAwareBeanPostProcessor) { // 如果为 InstantiationAwareBeanPostProcessor                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                // 返回值为是否继续填充 bean                // postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回 true，否则返回 false                // 一般情况下，应该是返回true 。                // 返回 false 的话，将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {                    continueWithPropertyPopulation = false;                    break;                }            }        }    }    // 如果后续处理器发出停止填充命令，则终止后续操作    if (!continueWithPropertyPopulation) {        return;    }    // bean 的属性值    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);    // 【2】 自动注入    if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {        // 将 PropertyValues 封装成 MutablePropertyValues 对象        // MutablePropertyValues 允许对属性进行简单的操作，并提供构造函数以支持Map的深度复制和构造。        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);        // Add property values based on autowire by name if applicable.        // 根据名称自动注入        if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) {            autowireByName(beanName, mbd, bw, newPvs);        }        // 根据类型自动注入        if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {            autowireByType(beanName, mbd, bw, newPvs);        }        pvs = newPvs;    }    // 是否已经注册了 InstantiationAwareBeanPostProcessors    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();    // 是否需要进行【依赖检查】    boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);    // 【3】 BeanPostProcessor 处理    PropertyDescriptor[] filteredPds = null;    if (hasInstAwareBpps) {        if (pvs == null) {            pvs = mbd.getPropertyValues();        }        // 遍历 BeanPostProcessor 数组        for (BeanPostProcessor bp : getBeanPostProcessors()) {            if (bp instanceof InstantiationAwareBeanPostProcessor) {                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                // 对所有需要依赖检查的属性进行后处理                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);                if (pvsToUse == null) {                    // 从 bw 对象中提取 PropertyDescriptor 结果集                    // PropertyDescriptor：可以通过一对存取方法提取一个属性                    if (filteredPds == null) {                        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);                    }                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);                    if (pvsToUse == null) {                        return;                    }                }                pvs = pvsToUse;            }        }    }    // 【4】 依赖检查    if (needsDepCheck) {        if (filteredPds == null) {            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);        }        // 依赖检查，对应 depends-on 属性        checkDependencies(beanName, mbd, filteredPds, pvs);    }    // 【5】 将属性应用到 bean 中    if (pvs != null) {        applyPropertyValues(beanName, mbd, bw, pvs);    }}</code></pre><p>处理流程如下：</p><font size=2><ul><li>【1】处，根据<code>hasInstantiationAwareBeanPostProcessors</code>属性来判断，是否需要注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 Bean 的机会。<strong>此过程可以控制 Spring 是否继续进行属性填充</strong>。</li><li>统一存入到 PropertyValues 中，PropertyValues 用于描述 Bean 的属性。<ul><li>【2】处，根绝注入类型的不同来判断：<ul><li>根据名称注入。</li><li>根据类型注入。</li></ul></li><li>【3】处，进行 BeanPostProcessor 处理。</li><li>【4】处，依赖检查。</li></ul></li><li>【5】处，将所有 PropertyValues 中的属性，填充到 BeanWrapper 中。</li></ul></font><h2 id="2-3-初始化-Bean"><a href="#2-3-初始化-Bean" class="headerlink" title="2.3 初始化 Bean"></a>2.3 初始化 Bean</h2><p>初始化 Bean 为<code>#createBean(...)</code>的最后一个过程。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {    if (System.getSecurityManager() != null) { // 安全模式        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {            // &lt;1&gt; 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware            invokeAwareMethods(beanName, bean);            return null;        }, getAccessControlContext());    } else {        // 【1】 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware        invokeAwareMethods(beanName, bean);    }    // 【2】 后处理器，before    Object wrappedBean = bean;    if (mbd == null || !mbd.isSynthetic()) {        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);    }    // 【3】 激活用户自定义的 init 方法    try {        invokeInitMethods(beanName, wrappedBean, mbd);    } catch (Throwable ex) {        throw new BeanCreationException(                (mbd != null ? mbd.getResourceDescription() : null),                beanName, &quot;Invocation of init method failed&quot;, ex);    }    // 【2】 后处理器，after    if (mbd == null || !mbd.isSynthetic()) {        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);    }    return wrappedBean;}</code></pre><p>初始化 Bean 的方法其实就是三个步骤处理，而这三个步骤还主要根据<strong>用户设置</strong>来决定，这三个过程为：</p><font size=2><ul><li>【1】处，激活 Aware 方法。</li><li>【2】处，后置处理器的操作。</li><li>【3】处，激活自定义的 init 方法。</li></ul></font><h1 id="3-从-Bean-实例中获取对象"><a href="#3-从-Bean-实例中获取对象" class="headerlink" title="3 从 Bean 实例中获取对象"></a>3 从 Bean 实例中获取对象</h1><p>无论从单例缓存中获取，还是通过<code>#createBean(...)</code>方法创建 Bean 实例。最终都会调用<code>#getObjectForBeanInstance(...)</code>方法，来根据传入的 Bean 实例获取对象。按照 Spring 的传统，该方法也只是做一些检查工作。真正的实现逻辑委托为<code>#getObjectFromFactoryBean(...)</code>方法实现。代码如下：</p><pre><code>protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {    // 【1】为单例模式且缓存中存在    if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {        synchronized (getSingletonMutex()) { // 【1.1】 单例锁            // 【1.2】 从缓存中获取指定的 factoryBean            Object object = this.factoryBeanObjectCache.get(beanName);            if (object == null) {                // 为空，则从 FactoryBean 中获取对象                object = doGetObjectFromFactoryBean(factory, beanName);                // 从缓存中获取                // (e.g. because of circular reference processing triggered by custom getBean calls)                Object alreadyThere = this.factoryBeanObjectCache.get(beanName);                if (alreadyThere != null) {                    object = alreadyThere;                } else {                    // 【1.3】 需要后续处理                    if (shouldPostProcess) {                        // 若该 Bean 处于创建中，则返回非处理对象，而不是存储它                        if (isSingletonCurrentlyInCreation(beanName)) {                            // Temporarily return non-post-processed object, not storing it yet..                            return object;                        }                        // 单例 Bean 的前置处理                        beforeSingletonCreation(beanName);                        try {                            // 对从 FactoryBean 获取的对象进行后处理                            // 生成的对象将暴露给 bean 引用                            object = postProcessObjectFromFactoryBean(object, beanName);                        } catch (Throwable ex) {                            throw new BeanCreationException(beanName,                                    &quot;Post-processing of FactoryBean&#39;s singleton object failed&quot;, ex);                        } finally {                            // 单例 Bean 的后置处理                            afterSingletonCreation(beanName);                        }                    }                    // 【1.4】 添加到 factoryBeanObjectCache 中，进行缓存                    if (containsSingleton(beanName)) {                        this.factoryBeanObjectCache.put(beanName, object);                    }                }            }            return object;        }    // 【2】    } else {        // 为空，则从 FactoryBean 中获取对象        Object object = doGetObjectFromFactoryBean(factory, beanName);        // 需要后续处理        if (shouldPostProcess) {            try {                // 对从 FactoryBean 获取的对象进行后处理                // 生成的对象将暴露给 bean 引用                object = postProcessObjectFromFactoryBean(object, beanName);            }            catch (Throwable ex) {                throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&#39;s object failed&quot;, ex);            }        }        return object;    }}</code></pre><p>主要流程如下：</p><font size=2><ul><li>若为单例且单例 Bean 缓存中存在<code>beanName</code>，则<code>【1】</code>进行后续处理，否则<code>【2】</code>从 FactoryBean 中获取 Bean 实例对象。</li><li>【1.1】处，获取锁。锁住的对象是<code>this.singletonObjects</code>，主要因为在单例模式必须保证全局唯一性。</li><li>【1.2】处，从<code>factoryBeanObjectCache</code>缓存中获取实例对象<code>object</code>。若<code>object</code>为空，则调用<code>#doGetObjectFromFactoryBean(...)</code>方法，从 FactoryBean 获取对象，其实内部就是调用<code>FactoryBean#getObject()</code>方法。<ul><li>【1.3】处，如果需要后续处理，则进行进一步处理。<ul><li>若该 Bean 处于创建中，则返回<strong>废处理的Bean对象</strong>，而不是存储它。</li><li>调用<code>#beforeSingletonCreation(...)</code>方法，进行创建之前的处理。默认实现将该 Bean 标记为当前创建的。</li><li>调用<code>#postProcessObjectFromFactoryBean(...)</code>方法，对从 FactoryBean 获取的 Bean 实例对象进行后置处理。</li><li>调用<code>#afterSingletonCreation(...)</code>方法，进行创建 Bean 之后的处理，默认是将该 Bean 标记为不再创建中。</li></ul></li></ul></li><li>【1.4】处，最后加入到<code>factoryBeanObjectCache</code>缓存中。</font></li></ul><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>终于结束了！！！到这里 Spring 加载 Bean 的全部流程就结束了！！！！撒花！！</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean之创建 Bean（六）之初始化 Bean 对象</title>
      <link href="/2019/12/27/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96-Bean-%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/12/27/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E5%85%AD%EF%BC%89%E4%B9%8B%E5%88%9D%E5%A7%8B%E5%8C%96-Bean-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>一个 Bean 经过千辛万苦的<code>#createBeanInstance(...)</code>方法，终于被创建出来了。然后又经过一番属性注入、依赖处理。终于像了那么一回事，现在我们只需要最后一步，初始化它！！就可堪重用了。  </p><p>这最后一步初始化，也就是<code>#initializeBean(...)</code>方法，所以，我们这篇主要就来分析下<code>#doCreateBean(...)</code>的最后一步：<strong>初始化对象</strong>。</p><h1 id="1-initializeBean"><a href="#1-initializeBean" class="headerlink" title="1 initializeBean"></a>1 initializeBean</h1><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected Object initializeBean(final String beanName, final Object bean, @Nullable RootBeanDefinition mbd) {    if (System.getSecurityManager() != null) { // 安全模式        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {            // 【1】 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware            invokeAwareMethods(beanName, bean);            return null;        }, getAccessControlContext());    } else {        // 【1】 激活 Aware 方法，对特殊的 bean 处理：Aware、BeanClassLoaderAware、BeanFactoryAware        invokeAwareMethods(beanName, bean);    }    // 【2】 后处理器，before    Object wrappedBean = bean;    if (mbd == null || !mbd.isSynthetic()) {        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);    }    // 【3】 激活用户自定义的 init 方法    try {        invokeInitMethods(beanName, wrappedBean, mbd);    } catch (Throwable ex) {        throw new BeanCreationException(                (mbd != null ? mbd.getResourceDescription() : null),                beanName, &quot;Invocation of init method failed&quot;, ex);    }    // 【2】 后处理器，after    if (mbd == null || !mbd.isSynthetic()) {        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);    }    return wrappedBean;}</code></pre><p>初始化 Bean 的方法其实就这三个步骤，而这三个步骤主要还是<strong>根据用户设定</strong>来进行，这三个过程是：</p><font size=2><ul><li>【1】处，激活 Aware 方法。</li><li>【2】处，后置处理器的应用。</li><li>【3】处，激活自定义的 init 方法。</li></ul></font><h2 id="1-1-激活-Aware-方法"><a href="#1-1-激活-Aware-方法" class="headerlink" title="1.1 激活 Aware 方法"></a>1.1 激活 Aware 方法</h2><p>Aware，英文翻译是意识到的、感知的。Spring 提供了大量的 Aware 接口，用于辅助 Spring Bean 以变成的方式调用 Spring 容器，通过实现这些接口，可以增强 Spring Bean 的功能。  </p><p>Spring 提供了大量的 Aware 接口用于我们的扩展使用，关于 Aware 接口后续会有详细的文章讲解，这里不再赘述。</p><h2 id="1-2-后置处理器的应用"><a href="#1-2-后置处理器的应用" class="headerlink" title="1.2 后置处理器的应用"></a>1.2 后置处理器的应用</h2><p>BeanPostProcessor 在前面介绍 Bean 加载过程曾多次遇到，这是 Sprnig 中开放式框架的一个<strong>亮点！</strong>。  </p><p>BeanPostProcessor 的作用是：如果我们想要在 Spring 容器完成 Bean 的实例化，配置和其他初始化后添加一些自己的逻辑处理，那么请使用该接口，这个接口给予了用户充足的权限<strong>去更改或扩展 Spring</strong>，是我们对 Spring 进行扩展和增强处理的必要接口。</p><p><code>#applyBeanPostProcessorsBeforeInitialization(...)</code>方法。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.java@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)        throws BeansException {    Object result = existingBean;    // 遍历 BeanPostProcessor 数组    for (BeanPostProcessor processor : getBeanPostProcessors()) {        // 处理        Object current = processor.postProcessBeforeInitialization(result, beanName);        // 返回空，则返回 result        if (current == null) {            return result;        }        // 修改 result        result = current;    }    return result;}</code></pre><p><code>#applyBeanPostProcessorsAfterInitialization(...)</code>方法。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.java@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)        throws BeansException {    Object result = existingBean;    // 遍历 BeanPostProcessor    for (BeanPostProcessor processor : getBeanPostProcessors()) {        // 处理        Object current = processor.postProcessAfterInitialization(result, beanName);        // 返回空，则返回 result        if (current == null) {            return result;        }        // 修改 result        result = current;    }    return result;}</code></pre><p>其实逻辑就是通过<code>#getBeanPostProcessors()</code>方法，获取定义的 BeanPostProcessor，然后分别调用其<code>#postProcessBeforeInitialization(...)</code>、<code>#postProcessAfterInitialization(...)</code>两个方法，进行<strong>自定义业务处理</strong>。</p><h2 id="1-3-激活自定义的-init-方法"><a href="#1-3-激活自定义的-init-方法" class="headerlink" title="1.3 激活自定义的 init 方法"></a>1.3 激活自定义的 init 方法</h2><p>如果熟悉<code>&lt;bean&gt;</code>标签的配置，一定不会忘记<code>init-method</code>方法，该方法就是在这里执行。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected void invokeInitMethods(String beanName, final Object bean, @Nullable RootBeanDefinition mbd)        throws Throwable {    // 首先会检查是否是 InitializingBean ，如果是的话需要调用 afterPropertiesSet()    boolean isInitializingBean = (bean instanceof InitializingBean);    if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(&quot;afterPropertiesSet&quot;))) {        if (logger.isTraceEnabled()) {            logger.trace(&quot;Invoking afterPropertiesSet() on bean with name &#39;&quot; + beanName + &quot;&#39;&quot;);        }        if (System.getSecurityManager() != null) { // 安全模式            try {                AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; {                    // 【1】 属性初始化的处理                    ((InitializingBean) bean).afterPropertiesSet();                    return null;                }, getAccessControlContext());            } catch (PrivilegedActionException pae) {                throw pae.getException();            }        } else {            // 【1】 属性初始化的处理            ((InitializingBean) bean).afterPropertiesSet();        }    }    if (mbd != null &amp;&amp; bean.getClass() != NullBean.class) {        String initMethodName = mbd.getInitMethodName();        if (StringUtils.hasLength(initMethodName) &amp;&amp;                !(isInitializingBean &amp;&amp; &quot;afterPropertiesSet&quot;.equals(initMethodName)) &amp;&amp;                !mbd.isExternallyManagedInitMethod(initMethodName)) {            // 【2】 激活用户自定义的初始化方法            invokeCustomInitMethod(beanName, bean, mbd);        }    }}</code></pre><font size=2><ul><li>首先，检查是否为 InitializingBean。如果是的话，需要执行<code>#afterPropertiesSet()</code>，因为我们除了可以使用<code>init-method</code>来自定初始化方法外，还可以实现 InitializingBean接口。接口仅有一个<code>#afterPropertiesSet()</code>方法。</li><li>两者的执行先后顺序是先【1】的<code>#afterPropertiesSet()</code>方法，后【2】的<code>init-method</code>对应的方法。</li></ul></font><h1 id="2-小结"><a href="#2-小结" class="headerlink" title="2 小结"></a>2 小结</h1><p>这三个方法后续会单独进行分析，至此一个 Bean 是怎么创建出来的，已经全部结束。</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean之创建 Bean（五）之循环依赖</title>
      <link href="/2019/12/27/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2019/12/27/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E4%BA%94%EF%BC%89%E4%B9%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>这篇分析<code>#doCreateBean(...)</code>方法的第三个过程：循环依赖处理。本文内容不仅仅局限于<code>#doCreateBean(...)</code>方法，而是从整个 Bean 的加载过程进行分析。</p><h1 id="1-什么是循环依赖"><a href="#1-什么是循环依赖" class="headerlink" title="1 什么是循环依赖"></a>1 什么是循环依赖</h1><p>循环依赖，其实就是循环引用。两个或两个以上的 Bean 互相引用对方，最终形成一个闭环。</p><p><img src="/images/pasted-28.png" alt="循环依赖示例"></p><p>循环依赖，是<strong>死循环</strong>的一种体现，在初始化 A 的时候发现引用了 B ，这时就去初始化 B。然后发现 B 引用了 C，就去初始化 C 。然后发现引用了 A，一次循环永不退出，除非有<strong>终结条件</strong>。</p><p>Spring 循环依赖的场景有两个：</p><font size=2><ul><li>构造器的循环依赖</li><li>field 属性的循环依赖。</li></ul></font><p>对于构造器的循环依赖， Spring 是无法解决的，只能抛出 BeanCurrentlyInCreationException 异常表示循环依赖。<strong>所以下面着重的说下基于 field 属性的循环依赖</strong>。  </p><p>在之前的博文中我们提到过，Spring 只解决了 singleton 模式下的循环依赖，对原型模式则是直接抛出异常。这是为什么？</p><h1 id="2-解决循环依赖"><a href="#2-解决循环依赖" class="headerlink" title="2 解决循环依赖"></a>2 解决循环依赖</h1><h2 id="2-1-getSingleton"><a href="#2-1-getSingleton" class="headerlink" title="2.1 getSingleton"></a>2.1 getSingleton</h2><p>我们先从加载 Bean 的最初始方法    AbstractBeanFactory 的<code>#doGetBean(...)</code>方法开始，首先会根据<code>beanName</code>从单例 Bean 缓存中获取，如果不为空则直接返回。代码如下：</p><pre><code>// AbstractBeanFactory.javaObject sharedInstance = getSingleton(beanName);</code></pre><p>调用<code>#getSingleton(...)</code>方法，从单例缓存获取。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.java@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) {    // 从单例缓冲中加载 bean    Object singletonObject = this.singletonObjects.get(beanName);    // 缓存中的 bean 为空，且当前 bean 正在创建    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {        // 加锁        synchronized (this.singletonObjects) {            // 从 earlySingletonObjects 获取            singletonObject = this.earlySingletonObjects.get(beanName);            // earlySingletonObjects 中没有，且允许提前创建            if (singletonObject == null &amp;&amp; allowEarlyReference) {                // 从 singletonFactories 中获取对应的 ObjectFactory                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);                if (singletonFactory != null) {                    // 获得 bean                    singletonObject = singletonFactory.getObject();                    // 添加 bean 到 earlySingletonObjects 中                    this.earlySingletonObjects.put(beanName, singletonObject);                    // 从 singletonFactories 中移除对应的 ObjectFactory                    this.singletonFactories.remove(beanName);                }            }        }    }    return singletonObject;}</code></pre><p>这个方法只要是从三个缓存中获取实例。<code>singletonObjects</code>、<code>earlySingletonObjects</code>、<code>singletonFactories</code>。三者定义如下：</p><pre><code>// DefaultSingletonBeanRegistry.java/** * * 存放的是单例 bean 的映射。 * * 对应关系为 bean name --&gt; bean instance */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);/** * * 存放的是【早期】的单例 bean 的映射。 * * 对应关系也是 bean name --&gt; bean instance。 * * 它与 {@link #singletonObjects} 的区别区别在，于 earlySingletonObjects 中存放的 bean 不一定是完整的。 * * 从 {@link #getSingleton(String)} 方法中，中我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了， * 所以当在 bean 的创建过程中就可以通过 getBean() 方法获取。 * 这个 Map 也是解决【循环依赖】的关键所在。 **/private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);/** * * 存放的是 ObjectFactory 的映射，可以理解为创建单例 bean 的 factory 。 * * 对应关系是 bean name --&gt; ObjectFactory */private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);</code></pre><p>他们仨，就是 Spring 解决 singleton bean 的关键因素，我们暂称他们为<strong>三级缓存</strong>：</p><font size=2><ul><li>第一级，<code>singletonObjects</code>。</li><li>第二级，<code>earlySingletonObjects</code>。</li><li>第三极，<code>singletonFactories</code>。</li></ul></font><p>这里，我们已经通过<code>#getSingleton(...)</code>方法，看到他们是如何配合的了，在详细分析之前，提下其中的<code>#isSingletonCurrentlyInCreation(...)</code>方法和<code>allowEarlyReference</code>属性。</p><font size=2><ul><li><code>#isSingletonCurrentlyInCreation(...)</code>方法：判断当前 singleton bean 是否处于创建中。Bean 处于创建中，也就是 Bean 在初始化但是没有完成初始化，有一个这样的过程其实和 Spring 解决 Bean 循环依赖的理念相辅相成。<strong>因为 Spring 解决 singleton bean 的核心就在于提前曝光 Bean</strong>。</li><li><code>allowEarlyReference</code>变量：从字面来看就是允许提前拿到引用。真正的含义是，是否允许从<code>singletonFactories</code>缓存中通过<code>#getObject()</code>方法，拿到实例。原因在于<code>singletonFactories</code>才是 Spring 解决 singleton bean 的诀窍。</li></ul></font><p><code>#getSingleton(...)</code>方法还是比较简单，流程如下：</p><font size=2><ul><li>首先，从一级缓存    <code>singletonObjects</code>获取。</li><li>如果，没有且当前指定的 beanName 正在创建，在从二级缓存<code>earlySingletonObjects</code>中获取。</li><li>如果，还是没有且允许<code>singletonFactories</code>通过<code>#getObject()</code>方法获取，则从三级缓存<code>singletonFactories</code>获取。如果获取到了，通过其<code>#getObject()</code>方法获取实例。并将其加入到二级缓存<code>earlySingletonObjects</code>中，并从三级缓存<code>singletonFactories</code>删除。代码如下：</li></ul><pre><code>// DefaultSingletonBeanRegistry.javasingletonObject = singletonFactory.getObject();this.earlySingletonObjects.put(beanName, singletonObject);this.singletonFactories.remove(beanName);</code></pre><ul><li>这样，就从<strong>三级缓存升级到二级缓存了</strong>。</li><li>所以，二级缓存存在的意义，就是缓存三级缓存中<code>#getObject()</code>的执行结果，提早<strong>曝光单例 Bean 对象</strong>。</li></ul></font><h2 id="2-2-addSingletonFactory"><a href="#2-2-addSingletonFactory" class="headerlink" title="2.2 addSingletonFactory"></a>2.2 addSingletonFactory</h2><p>上面是从缓存中获取，但是缓存中的数据从哪里添加的呢？往下跟踪会发现在 AbstractAutowireCapableBeanFactory 的<code>#doCreateBean(...)</code>方法中，有一段代码：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaboolean earlySingletonExposure = (mbd.isSingleton() // 单例模式        &amp;&amp; this.allowCircularReferences // 运行循环依赖        &amp;&amp; isSingletonCurrentlyInCreation(beanName)); // 当前单例 bean 是否正在被创建if (earlySingletonExposure) {    if (logger.isTraceEnabled()) {        logger.trace(&quot;Eagerly caching bean &#39;&quot; + beanName +                &quot;&#39; to allow for resolving potential circular references&quot;);    }    // 提前将创建的 bean 实例加入到 singletonFactories 中    // 这里是为了后期避免循环依赖    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));}</code></pre><p>当一个 Bean 满足三个条件是，则调用<code>#addSingletonFactory(...)</code>方法，把它添加到缓存中。条件如下：</p><font size=2><ul><li>单例。</li><li>运行提前暴露的 Bean。</li><li>当前 Bean 正在创建中。</li></ul></font><p><code>#addSingletonFactory(...)</code>方法。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.javaprotected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {    Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;);    synchronized (this.singletonObjects) {        if (!this.singletonObjects.containsKey(beanName)) {            this.singletonFactories.put(beanName, singletonFactory);            this.earlySingletonObjects.remove(beanName);            this.registeredSingletons.add(beanName);        }    }}</code></pre><p>从这段代码可以看出，<code>singletonFactories</code>这个三级缓存才是解决 Spring 循环依赖的根本所在。同时这段代码也发生在<code>#createBeanInstance(...)</code>之后，也就是说这个 Bean 其实已经被创建出来了，<strong>但是它还不完美，因为没有进行属性填充和初始化</strong>，但是对于其他引用它的 Bean 来说，已经足够了，已经可以找到它在堆中的位置了。所以 Spring 在这个时候，选择将该对象提前曝光出来让大家使用。</p><h2 id="2-3-addSingleton"><a href="#2-3-addSingleton" class="headerlink" title="2.3 addSingleton"></a>2.3 addSingleton</h2><p>介绍到这里我们发现三级缓存<code>singletonFactories</code>和二级缓存<code>earlySingletonObjects</code>中的值都有出处了，那一级缓存在哪里？我们在 DefaultSingletonBeanRegistry 中可以发现一个<code>#addSingleton(...)</code>方法。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.javaprotected void addSingleton(String beanName, Object singletonObject) {    synchronized (this.singletonObjects) {        this.singletonObjects.put(beanName, singletonObject);        this.singletonFactories.remove(beanName);        this.earlySingletonObjects.remove(beanName);        this.registeredSingletons.add(beanName);    }}</code></pre><p>添加一级缓存，同时从二级、三级缓存中删除。</p><p>这个方法在<code>#doGetBean(...)</code>方法中，处理不同 scope 时，如果是 singleton 则调用<code>#getSingleton(...)</code>方法。如下图：</p><p><img src="/images/pasted-29.png" alt="调用流程"></p><p>在前面我们已经分析<code>#createBean(...)</code>方法，这里就不再重复。我们关注<code>#getSingleton(...)</code>方法。代码如下：</p><pre><code>// AbstractBeanFactory.javapublic Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {    Assert.notNull(beanName, &quot;Bean name must not be null&quot;);    synchronized (this.singletonObjects) {        Object singletonObject = this.singletonObjects.get(beanName);        if (singletonObject == null) {            //....            try {                singletonObject = singletonFactory.getObject();                newSingleton = true;            }            //.....            if (newSingleton) {                addSingleton(beanName, singletonObject);            }        }        return singletonObject;    }}</code></pre><p><strong>这里要特别注意，此处的方法，在 AbstractBeanFactory 中实现，与【2.1 getSingleton】不同</strong>。</p><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>至此，Spring 关于 singleton bean 循环依赖已经分析完毕，我们已经可以确定 spring 解决循环依赖的方案了：</p><font size=2><ul><li>Spring 在创建 Bean 的时候并不是等他完全完成，而是在创建过程中将创建中的 Bean 的 ObjectFactory 提前曝光，加入到<code>singletonFactories</code>缓存中。</li><li>这样，一旦下一个 Bean 创建的时候需要依赖 Bean，则直接使用 ObjectFactory 的 <code>#getObject()</code>方法获取，也就是【2.1 getSingleton】中的代码。</li></ul></font><p>我们在详细描述一下上面那个循环依赖的解决过程：</p><font size=2><ul><li>首先 A 完成初始化第一步并将自己提前曝光出来，在初始化的时候发现自己依赖对象 B，此时就去尝试<code>#getObject(b)</code>，然后发现 B 还没有创建出来。</li><li>然后去创建 B，在 B 初始化的时候又发现自己依赖 C，C也没有被创建出来。</li><li>这时 C 的初始化过程中，发现自己依赖 A，于是尝试<code>#getObject(A)</code>，<strong>重点在这！</strong>，这时由于 A 已经添加到缓存中了（一般都是三级缓存中），通过 ObjectFactory 提前曝光，<strong>拿出来了！！！</strong>。C 在拿到 A 以后顺序完成初始化，然后将自己添加到一级缓存中。</li><li>回到 B 的流程，B 也拿到了 C，完成初始化。A 也可以顺利拿到 B 完成初始化。整个过程就结束了！！！！！</li></ul></font><p>可以参考下图，方便理解。</p><p><img src="/images/pasted-31.png" alt="解决循环依赖"></p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建 Bean（四）之属性填充</title>
      <link href="/2019/12/26/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85/"/>
      <url>/2019/12/26/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E5%9B%9B%EF%BC%89%E4%B9%8B%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p><code>#doCreateBean(...)</code>方法，主要用于完成 Bean 的创建和初始化工作，我们可以将其分为四个部分：</p><font size=2><ul><li><code>#createBeanInstance(...)</code>方法，实例化 Bean。</li><li><code>#populateBean(...)</code>方法，进行属性填充。</li><li>循环依赖。</li><li><code>#initializeBean(...)</code>方法，初始化 Bean。</li></ul></font><p>第一个过程，如何实例化 Bean 在前两篇已经说明了，这篇主要来分析属性填充，也就是<code>#populateBean(...)</code>方法。该方法的作用是将 BeanDefinition 中的属性值复制给 BeanWrapper 实例对象。</p><h1 id="1-populateBean"><a href="#1-populateBean" class="headerlink" title="1 populateBean"></a>1 populateBean</h1><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {    // 没有实例化对象    if (bw == null) {        // 有属性，则抛出 BeanCreationException 异常        if (mbd.hasPropertyValues()) {            throw new BeanCreationException(                    mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);            // 没有属性，直接 return 返回        } else {            // Skip property population phase for null instance.            return;        }    }    // 【1】 在设置属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 bean 的机会    boolean continueWithPropertyPopulation = true;    if (!mbd.isSynthetic()  // bean 不是&quot;合成&quot;的，即未由应用程序本身定义            &amp;&amp; hasInstantiationAwareBeanPostProcessors()) { // 是否持有 InstantiationAwareBeanPostProcessor        // 迭代所有的 BeanPostProcessors        for (BeanPostProcessor bp : getBeanPostProcessors()) {            if (bp instanceof InstantiationAwareBeanPostProcessor) { // 如果为 InstantiationAwareBeanPostProcessor                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                // 返回值为是否继续填充 bean                // postProcessAfterInstantiation：如果应该在 bean上面设置属性则返回 true，否则返回 false                // 一般情况下，应该是返回true 。                // 返回 false 的话，将会阻止在此 Bean 实例上调用任何后续的 InstantiationAwareBeanPostProcessor 实例。                if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {                    continueWithPropertyPopulation = false;                    break;                }            }        }    }    // 如果后续处理器发出停止填充命令，则终止后续操作    if (!continueWithPropertyPopulation) {        return;    }    // 【2】bean 的属性值    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);    // 【3】 自动注入    if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {        // 将 PropertyValues 封装成 MutablePropertyValues 对象        // MutablePropertyValues 允许对属性进行简单的操作，并提供构造函数以支持Map的深度复制和构造。        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);        // Add property values based on autowire by name if applicable.        // 根据名称自动注入        if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) {            autowireByName(beanName, mbd, bw, newPvs);        }        // Add property values based on autowire by type if applicable.        // 根据类型自动注入        if (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) {            autowireByType(beanName, mbd, bw, newPvs);        }        pvs = newPvs;    }    // 是否已经注册了 InstantiationAwareBeanPostProcessors    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();    // 是否需要进行【依赖检查】    boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);    // 【4】 BeanPostProcessor 处理    PropertyDescriptor[] filteredPds = null;    if (hasInstAwareBpps) {        if (pvs == null) {            pvs = mbd.getPropertyValues();        }        // 遍历 BeanPostProcessor 数组        for (BeanPostProcessor bp : getBeanPostProcessors()) {            if (bp instanceof InstantiationAwareBeanPostProcessor) {                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                // 对所有需要依赖检查的属性进行后处理                PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);                if (pvsToUse == null) {                    // 从 bw 对象中提取 PropertyDescriptor 结果集                    // PropertyDescriptor：可以通过一对存取方法提取一个属性                    if (filteredPds == null) {                        filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);                    }                    pvsToUse = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);                    if (pvsToUse == null) {                        return;                    }                }                pvs = pvsToUse;            }        }    }    // 【5】 依赖检查    if (needsDepCheck) {        if (filteredPds == null) {            filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);        }        // 依赖检查，对应 depends-on 属性        checkDependencies(beanName, mbd, filteredPds, pvs);    }    // 【6】 将属性应用到 bean 中    if (pvs != null) {        applyPropertyValues(beanName, mbd, bw, pvs);    }}</code></pre><p>处理流程如下：</p><font size=2><ul><li>【1】处，根据<code>hasInstantiationAwareBeanPostProcessors</code>属性来判断，是否需要在注入属性之前给 InstantiationAwareBeanPostProcessors 最后一次改变 Bean 的机会。<strong>此过程可以控制 Spring 是否继续进行属性填充</strong>。</li><li>【2】处，统一存入到 PropertyValues 中，PropertyValues 用于描述 Bean 的属性。</li><li>【3】处，根据注入类型的不同来判断：<ul><li>根据名称自动注入</li><li>根据类型自动注入</li><li>详见【1.1】</li></ul></li><li>【4】处，进行 BeanPostProcessor 处理。</li><li>【5】处，依赖检查。</li><li>【6】处，将所有 PropertyValues 中的属性，填充到 BeanWrapper 中。</li></ul></font><h2 id="1-1-自动注入"><a href="#1-1-自动注入" class="headerlink" title="1.1 自动注入"></a>1.1 自动注入</h2><p>Spring 会根据注入类型的不同，调用不同的方法来注入属性值。代码如下：</p><pre><code>// AbstractBeanDefinition.java/** * 注入模式 */private int autowireMode = AUTOWIRE_NO;public int getResolvedAutowireMode() {    if (this.autowireMode == AUTOWIRE_AUTODETECT) { // 自动检测模式，获得对应的检测模式        Constructor&lt;?&gt;[] constructors = getBeanClass().getConstructors();        for (Constructor&lt;?&gt; constructor : constructors) {            if (constructor.getParameterCount() == 0) {                return AUTOWIRE_BY_TYPE;            }        }        return AUTOWIRE_CONSTRUCTOR;    } else {        return this.autowireMode;    }}</code></pre><h3 id="1-1-1-autowireByName"><a href="#1-1-1-autowireByName" class="headerlink" title="1.1.1 autowireByName"></a>1.1.1 autowireByName</h3><p><code>#autowireByName(...)</code>方法，顾名思义是根据属性名称，完成自动依赖注入。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected void autowireByName(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {    // 【1】 对 Bean 对象中非简单属性    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);    // 遍历 propertyName 数组    for (String propertyName : propertyNames) {        // 如果容器中包含指定名称的 bean，则将该 bean 注入到 bean中        if (containsBean(propertyName)) {            // 递归初始化相关 bean            Object bean = getBean(propertyName);            // 为指定名称的属性赋予属性值            pvs.add(propertyName, bean);            // 属性依赖注入            registerDependentBean(propertyName, beanName);            if (logger.isTraceEnabled()) {                logger.trace(&quot;Added autowiring by name from bean name &#39;&quot; + beanName +                        &quot;&#39; via property &#39;&quot; + propertyName + &quot;&#39; to bean named &#39;&quot; + propertyName + &quot;&#39;&quot;);            }        } else {            if (logger.isTraceEnabled()) {                logger.trace(&quot;Not autowiring property &#39;&quot; + propertyName + &quot;&#39; of bean &#39;&quot; + beanName +                        &quot;&#39; by name: no matching bean found&quot;);            }        }    }}</code></pre><font size=2><ul><li>【1】处，该方法逻辑简单，获取该 Bean 的非简单属性。非简单属性，就是对象类型的属性，但是这里并不会将所有的对象类型都找到，比如8个原始类型，String、Number、Date、URL、URI等都会被省略。代码如下：</li></ul><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) {    // 创建 result 集合    Set&lt;String&gt; result = new TreeSet&lt;&gt;();    PropertyValues pvs = mbd.getPropertyValues();    // 遍历 PropertyDescriptor 数组    PropertyDescriptor[] pds = bw.getPropertyDescriptors();    for (PropertyDescriptor pd : pds) {        if (pd.getWriteMethod() != null // 有可写方法                &amp;&amp; !isExcludedFromDependencyCheck(pd) // 依赖检测中没有被忽略                &amp;&amp; !pvs.contains(pd.getName()) // pvs 不包含该属性名                &amp;&amp; !BeanUtils.isSimpleProperty(pd.getPropertyType())) { // 不是简单属性类型            result.add(pd.getName()); // 添加到 result 中        }    }    return StringUtils.toStringArray(result);}</code></pre></font><p>获取需要依赖注入的属性后，通过遍历、递归的方式初始化相关的 Bean，然后调用<code>#registerDependentBean(...)</code>方法，完成注册依赖。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.java/** * * 保存的是依赖 beanName 之间的映射关系：beanName - &gt; 依赖 beanName 的集合 */private final Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = new ConcurrentHashMap&lt;&gt;(64);/** * * 保存的是依赖 beanName 之间的映射关系：依赖 beanName - &gt; beanName 的集合 */private final Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap = new ConcurrentHashMap&lt;&gt;(64);public void registerDependentBean(String beanName, String dependentBeanName) {    // 获取 beanName    String canonicalName = canonicalName(beanName);    // 添加 &lt;canonicalName, &lt;dependentBeanName&gt;&gt; 到 dependentBeanMap 中    synchronized (this.dependentBeanMap) {        Set&lt;String&gt; dependentBeans =                this.dependentBeanMap.computeIfAbsent(canonicalName, k -&gt; new LinkedHashSet&lt;&gt;(8));        if (!dependentBeans.add(dependentBeanName)) {            return;        }    }    // 添加 &lt;dependentBeanName, &lt;canonicalName&gt;&gt; 到 dependenciesForBeanMap 中    synchronized (this.dependenciesForBeanMap) {        Set&lt;String&gt; dependenciesForBean =                this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&gt; new LinkedHashSet&lt;&gt;(8));        dependenciesForBean.add(canonicalName);    }}</code></pre><h3 id="1-1-2-autowireByType"><a href="#1-1-2-autowireByType" class="headerlink" title="1.1.2 autowireByType"></a>1.1.2 autowireByType</h3><p><code>#autowireByType(...)</code>方法，根据属性类型完成自动依赖注入。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected void autowireByType(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {    // 获取 TypeConverter 实例    // 使用自定义的 TypeConverter，用于取代默认的 PropertyEditor 机制    TypeConverter converter = getCustomTypeConverter();    if (converter == null) {        converter = bw;    }    Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(4);    // 获取非简单属性    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);    // 遍历 propertyName 数组    for (String propertyName : propertyNames) {        try {            // 获取 PropertyDescriptor 实例            PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);            // 不要尝试按类型            if (Object.class != pd.getPropertyType()) {                // 探测指定属性的 set 方法                MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);                boolean eager = !PriorityOrdered.class.isInstance(bw.getWrappedInstance());                DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);                // 解析指定 beanName 的属性所匹配的值，并把解析到的属性名称存储在 autowiredBeanNames 中                // 当属性存在过个封装 bean 时将会找到所有匹配的 bean 并将其注入                Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);                if (autowiredArgument != null) {                    pvs.add(propertyName, autowiredArgument);                }                // 遍历 autowiredBeanName 数组                for (String autowiredBeanName : autowiredBeanNames) {                    // 属性依赖注入                    registerDependentBean(autowiredBeanName, beanName);                    if (logger.isTraceEnabled()) {                        logger.trace(&quot;Autowiring by type from bean name &#39;&quot; + beanName + &quot;&#39; via property &#39;&quot; +                                propertyName + &quot;&#39; to bean named &#39;&quot; + autowiredBeanName + &quot;&#39;&quot;);                    }                }                // 清空 autowiredBeanName 数组                autowiredBeanNames.clear();            }        } catch (BeansException ex) {            throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);        }    }}</code></pre><p>大致过程和根据名称自动注入差不多，都是找到需要的依赖注入的属性，然后找到匹配的 Bean，最后调用<code>#registerDependentBean(...)</code>方法注册依赖，不过相对于<code>#autowireByName(...)</code>方法而言，根据类型寻找匹配的 Bean 过程比较复杂。</p><h4 id="1-1-2-1-resolveDependency"><a href="#1-1-2-1-resolveDependency" class="headerlink" title="1.1.2.1 resolveDependency"></a>1.1.2.1 resolveDependency</h4><p>下面我们分析下这个过程。代码如下：</p><pre><code>// DefaultListableBeanFactory.java@Nullableprivate static Class&lt;?&gt; javaxInjectProviderClass;static {    try {        javaxInjectProviderClass = ClassUtils.forName(&quot;javax.inject.Provider&quot;, DefaultListableBeanFactory.class.getClassLoader());    } catch (ClassNotFoundException ex) {        // JSR-330 API not available - Provider interface simply not supported then.        javaxInjectProviderClass = null;    }}@Override@Nullablepublic Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,        @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {    // 初始化参数名称发现器，该方法并不会在这个时候尝试检索参数名称    // getParameterNameDiscoverer 返回 parameterNameDiscoverer 实例，parameterNameDiscoverer 方法参数名称的解析器    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());    // 依赖类型为 Optional 类型    if (Optional.class == descriptor.getDependencyType()) {        return createOptionalDependency(descriptor, requestingBeanName);    // 依赖类型为ObjectFactory、ObjectProvider    } else if (ObjectFactory.class == descriptor.getDependencyType() ||            ObjectProvider.class == descriptor.getDependencyType()) {        return new DependencyObjectProvider(descriptor, requestingBeanName);    // javaxInjectProviderClass 类注入的特殊处理    } else if (javaxInjectProviderClass == descriptor.getDependencyType()) {        return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);    } else {        // 为实际依赖关系目标的延迟解析构建代理        // 默认实现返回 null        Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);        if (result == null) {            // 通用处理逻辑            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);        }        return result;    }}</code></pre><p>这个我们关注<strong>通用处理逻辑</strong><code>#doResolveDependency(...)</code>方法。代码如下：</p><pre><code>// DefaultListableBeanFactory.java@Nullablepublic Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,    @Nullable Set&lt;String&gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {    // 注入点    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);    try {        // 针对给定的工厂给定一个快捷实现的方式，例如考虑一些预先解析的信息        // 在进入所有bean的常规类型匹配算法之前，解析算法将首先尝试通过此方法解析快捷方式。        // 子类可以覆盖此方法        Object shortcut = descriptor.resolveShortcut(this);        if (shortcut != null) {            // 返回快捷的解析信息            return shortcut;        }        // 依赖的类型        Class&lt;?&gt; type = descriptor.getDependencyType();        // 支持 Spring 的注解 @value        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);        if (value != null) {            if (value instanceof String) {                String strVal = resolveEmbeddedValue((String) value);                BeanDefinition bd = (beanName != null &amp;&amp; containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);                value = evaluateBeanDefinitionString(strVal, bd);            }            TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());            return (descriptor.getField() != null ?                    converter.convertIfNecessary(value, type, descriptor.getField()) :                    converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));        }        // 解析复合 bean，其实就是对 bean 的属性进行解析        // 包括：数组、Collection 、Map 类型        Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);        if (multipleBeans != null) {            return multipleBeans;        }        // 查找与类型相匹配的 bean        // 返回值构成为：key = 匹配的 beanName，value = beanName 对应的实例化 bean        Map&lt;String, Object&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);        // 没有找到，检验 @autowire  的 require 是否为 true        if (matchingBeans.isEmpty()) {            // 如果 @autowire 的 require 属性为 true ，但是没有找到相应的匹配项，则抛出异常            if (isRequired(descriptor)) {                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);            }            return null;        }        String autowiredBeanName;        Object instanceCandidate;        if (matchingBeans.size() &gt; 1) {            // 确认给定 bean autowire 的候选者            // 按照 @Primary 和 @Priority 的顺序            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);            if (autowiredBeanName == null) {                if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {                    // 唯一性处理                    return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);                }                else {                    // 在可选的Collection / Map的情况下，默默地忽略一个非唯一的情况：可能它是一个多个常规bean的空集合                    return null;                }            }            instanceCandidate = matchingBeans.get(autowiredBeanName);        } else {            // We have exactly one match.            Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();            autowiredBeanName = entry.getKey();            instanceCandidate = entry.getValue();        }        if (autowiredBeanNames != null) {            autowiredBeanNames.add(autowiredBeanName);        }        if (instanceCandidate instanceof Class) {            instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);        }        Object result = instanceCandidate;        if (result instanceof NullBean) {            if (isRequired(descriptor)) {                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);            }            result = null;        }        if (!ClassUtils.isAssignableValue(type, result)) {            throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());        }        return result;    } finally {        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);    }}</code></pre><p>到这里就可以完成了所有属性的注入了。<code>#populateBean()</code>方法的工作已经完成了大半。</p><font size=2><ul><li>下一步，则是对依赖的 Bean 的依赖检查和 PostProcessor 的处理。<strong>这个我们后续再说</strong>。</li><li>下面，我们来看该方法的最后一步<code>#applyPropertyValues(...)</code>方法。</li></ul></font><h2 id="1-2-applyPropertyValues"><a href="#1-2-applyPropertyValues" class="headerlink" title="1.2 applyPropertyValues"></a>1.2 applyPropertyValues</h2><p>其实，上面只是完成了所有注入属性的获取，将获取的属性封装在 PropertyValues 的实例对象中而已。并没有注入到已经实例的 Bean 中。而<code>#applyPropertyValues(...)</code>方法，就是完成这最后一步。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {    if (pvs.isEmpty()) {        return;    }    // 设置 BeanWrapperImpl 的 SecurityContext 属性    if (System.getSecurityManager() != null &amp;&amp; bw instanceof BeanWrapperImpl) {        ((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());    }    // MutablePropertyValues 类型属性    MutablePropertyValues mpvs = null;    // 原始类型    List&lt;PropertyValue&gt; original;    // 获得 original    if (pvs instanceof MutablePropertyValues) {        mpvs = (MutablePropertyValues) pvs;        // 属性值已经转换        if (mpvs.isConverted()) {            // Shortcut: use the pre-converted values as-is.            try {                // 为实例化对象设置属性值 ，依赖注入真真正正地实现在此！！！！！                bw.setPropertyValues(mpvs);                return;            } catch (BeansException ex) {                throw new BeanCreationException(                        mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);            }        }        original = mpvs.getPropertyValueList();    } else {        // 如果 pvs 不是 MutablePropertyValues 类型，则直接使用原始类型        original = Arrays.asList(pvs.getPropertyValues());    }    // 获取 TypeConverter = 获取用户自定义的类型转换    TypeConverter converter = getCustomTypeConverter();    if (converter == null) {        converter = bw;    }    // 获取对应的解析器    BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);    // Create a deep copy, resolving any references for values.    List&lt;PropertyValue&gt; deepCopy = new ArrayList&lt;&gt;(original.size());    boolean resolveNecessary = false;    // 遍历属性，将属性转换为对应类的对应属性的类型    for (PropertyValue pv : original) {        // 属性值不需要转换        if (pv.isConverted()) {            deepCopy.add(pv);        // 属性值需要转换        } else {            String propertyName = pv.getName();            Object originalValue = pv.getValue(); // 原始的属性值，即转换之前的属性值            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue); // 转换属性值，例如将引用转换为IoC容器中实例化对象引用 ！！！！！ 对属性值的解析！！            Object convertedValue = resolvedValue; // 转换之后的属性值            boolean convertible = bw.isWritableProperty(propertyName) &amp;&amp;                    !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);  // 属性值是否可以转换            // 使用用户自定义的类型转换器转换属性值            if (convertible) {                convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);            }            // Possibly store converted value in merged bean definition,            // in order to avoid re-conversion for every created bean instance.            // 存储转换后的属性值，避免每次属性注入时的转换工作            if (resolvedValue == originalValue) {                if (convertible) {                    // 设置属性转换之后的值                    pv.setConvertedValue(convertedValue);                }                deepCopy.add(pv);            // 属性是可转换的，且属性原始值是字符串类型，且属性的原始类型值不是            // 动态生成的字符串，且属性的原始值不是集合或者数组类型            } else if (convertible &amp;&amp; originalValue instanceof TypedStringValue &amp;&amp;                    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;                    !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {                pv.setConvertedValue(convertedValue);                deepCopy.add(pv);            } else {                resolveNecessary = true;                // 重新封装属性的值                deepCopy.add(new PropertyValue(pv, convertedValue));            }        }    }    // 标记属性值已经转换过    if (mpvs != null &amp;&amp; !resolveNecessary) {        mpvs.setConverted();    }    // Set our (possibly massaged) deep copy.    // 进行属性依赖注入，依赖注入的真真正正实现依赖的注入方法在此！！！    try {        bw.setPropertyValues(new MutablePropertyValues(deepCopy));    } catch (BeansException ex) {        throw new BeanCreationException(                mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);    }}</code></pre><p><code>#applyPropertyValues(...)</code>方法就是做一件事，完成属性转换注入进去！</p><font size=2><ul><li>属性值类型不需要转换时，不需要解析属性值，直接准备进入依赖注入。</li><li>属性值需要进行类型转换时，如果对其他对象的引用等，首先需要解析属性值，然后对解析后的属性值进行依赖注入。</li></ul></font><h1 id="2-小结"><a href="#2-小结" class="headerlink" title="2 小结"></a>2 小结</h1><p>至此，<code>#doCreateBean(...)</code>方法的第二个过程：属性填充。已经分析完成了。下篇分析第三个过程：循环依赖的处理。循环依赖并不仅仅只是在<code>#doCreateBean(...)</code>方法中，而是整个 Spring 的 IoC 体系都要涉及的内容。</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建 Bean（三）之实例化 Bean 对象(2)</title>
      <link href="/2019/12/26/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96-Bean-%E5%AF%B9%E8%B1%A1-2/"/>
      <url>/2019/12/26/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E4%B8%89%EF%BC%89%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96-Bean-%E5%AF%B9%E8%B1%A1-2/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p><code>#createBeanInstance(...)</code>方法，用于实例化 Bean 对象。它会根据不同情况，选择不同的实例化策略来完成 Bean 的初始化，主要包括：</p><fint size=2><ul><li>Supplier回调：<code>#obtainFromSupplier(...)</code>方法。</li><li>工厂方法初始化：<code>#instantiateUsingFactoryMethod(...)</code>方法。</li><li>构造函数自动注入初始化：<code>#autowireConstructor(...)</code>方法。</li><li>默认构造函数注入：<code>#instantiateBean(...)</code>方法。</li></ul></fint><p>在上篇分析了前两种，这篇来分析一下后两种的构造函数注入。</p><h1 id="1-autowireConstructor"><a href="#1-autowireConstructor" class="headerlink" title="1 autowireConstructor"></a>1 autowireConstructor</h1><p>这个初始化方法，我们可以简单理解为<strong>带有参数的构造方法</strong>，来初始化 Bean 对象。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor&lt;?&gt;[] ctors, @Nullable Object[] explicitArgs) {    return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);}// ConstructorResolver.javapublic BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,        @Nullable Constructor&lt;?&gt;[] chosenCtors, @Nullable Object[] explicitArgs) {    // 封装 BeanWrapperImpl 对象，并完成初始化    BeanWrapperImpl bw = new BeanWrapperImpl();    this.beanFactory.initBeanWrapper(bw);    // 获得 constructorToUse、argsHolderToUse、argsToUse    Constructor&lt;?&gt; constructorToUse = null; // 构造函数    ArgumentsHolder argsHolderToUse = null; // 构造参数    Object[] argsToUse = null; // 构造参数    // 确定构造参数    // 如果 getBean() 已经传递，则直接使用    if (explicitArgs != null) {        argsToUse = explicitArgs;    } else {        // 尝试从缓存中获取        Object[] argsToResolve = null;        synchronized (mbd.constructorArgumentLock) {            // 缓存中的构造函数或者工厂方法            constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;            if (constructorToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {                // Found a cached constructor...                // 缓存中的构造参数                argsToUse = mbd.resolvedConstructorArguments;                if (argsToUse == null) {                    argsToResolve = mbd.preparedConstructorArguments;                }            }        }        // 缓存中存在,则解析存储在 BeanDefinition 中的参数        // 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)        // 缓存中的值可能是原始值也有可能是最终值        if (argsToResolve != null) {            argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, true);        }    }    // 没有缓存，则尝试从配置文件中获取参数    if (constructorToUse == null || argsToUse == null) {        // Take specified constructors, if any.        // 如果 chosenCtors 未传入，则获取构造方法们        Constructor&lt;?&gt;[] candidates = chosenCtors;        if (candidates == null) {            Class&lt;?&gt; beanClass = mbd.getBeanClass();            try {                candidates = (mbd.isNonPublicAccessAllowed() ?                        beanClass.getDeclaredConstructors() : beanClass.getConstructors());            } catch (Throwable ex) {                throw new BeanCreationException(mbd.getResourceDescription(), beanName,                        &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() +                        &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);            }        }        // 创建 Bean        if (candidates.length == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues()) {            Constructor&lt;?&gt; uniqueCandidate = candidates[0];            if (uniqueCandidate.getParameterCount() == 0) {                synchronized (mbd.constructorArgumentLock) {                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;                    mbd.constructorArgumentsResolved = true;                    mbd.resolvedConstructorArguments = EMPTY_ARGS;                }                bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));                return bw;            }        }        // 是否需要解析构造器        // Need to resolve the constructor.        boolean autowiring = (chosenCtors != null ||                mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);        // 用于承载解析后的构造函数参数的值        ConstructorArgumentValues resolvedValues = null;        int minNrOfArgs;        if (explicitArgs != null) {            minNrOfArgs = explicitArgs.length;        } else {            // 从 BeanDefinition 中获取构造参数，也就是从配置文件中提取构造参数            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();            resolvedValues = new ConstructorArgumentValues();            // 解析构造函数的参数            // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);        }        // 对构造函数进行排序处理        // public 构造函数优先参数数量降序，非public 构造函数参数数量降序        AutowireUtils.sortConstructors(candidates);        // 最小参数类型权重        int minTypeDiffWeight = Integer.MAX_VALUE;        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = null;        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null;        // 迭代所有构造函数        for (Constructor&lt;?&gt; candidate : candidates) {            // 获取该构造函数的参数类型            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();            // 如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数参数个数，则终止。            // 因为，已经按照参数个数降序排列了            if (constructorToUse != null &amp;&amp; argsToUse.length &gt; paramTypes.length) {                // Already found greedy constructor that can be satisfied -&gt;                // do not look any further, there are only less greedy constructors left.                break;            }            // 参数个数不等，继续            if (paramTypes.length &lt; minNrOfArgs) {                continue;            }            // 参数持有者 ArgumentsHolder 对象            ArgumentsHolder argsHolder;            if (resolvedValues != null) {                try {                    // 注释上获取参数名称                    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);                    if (paramNames == null) {                        // 获取构造函数、方法参数的探测器                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();                        if (pnd != null) {                            // 通过探测器获取构造函数的参数名称                            paramNames = pnd.getParameterNames(candidate);                        }                    }                    // 根据构造函数和构造参数，创建参数持有者 ArgumentsHolder 对象                    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,                            getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);                } catch (UnsatisfiedDependencyException ex) {                    // 若发生 UnsatisfiedDependencyException 异常，添加到 causes 中。                    if (logger.isTraceEnabled()) {                        logger.trace(&quot;Ignoring constructor [&quot; + candidate + &quot;] of bean &#39;&quot; + beanName + &quot;&#39;: &quot; + ex);                    }                    // Swallow and try next constructor.                    if (causes == null) {                        causes = new LinkedList&lt;&gt;();                    }                    causes.add(ex);                    continue; // continue ，继续执行                }            } else {                // continue 构造函数没有参数                // Explicit arguments given -&gt; arguments length must match exactly.                if (paramTypes.length != explicitArgs.length) {                    continue;                }                // 根据 explicitArgs ，创建 ArgumentsHolder 对象                argsHolder = new ArgumentsHolder(explicitArgs);            }            // isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式            // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常            // 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配            // typeDiffWeight：类型差异权重            int typeDiffWeight = (mbd.isLenientConstructorResolution() ?                    argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));            // Choose this constructor if it represents the closest match.            // 如果它代表着当前最接近的匹配则选择其作为构造函数            if (typeDiffWeight &lt; minTypeDiffWeight) {                constructorToUse = candidate;                argsHolderToUse = argsHolder;                argsToUse = argsHolder.arguments;                minTypeDiffWeight = typeDiffWeight;                ambiguousConstructors = null;            } else if (constructorToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight) {                if (ambiguousConstructors == null) {                    ambiguousConstructors = new LinkedHashSet&lt;&gt;();                    ambiguousConstructors.add(constructorToUse);                }                ambiguousConstructors.add(candidate);            }        }        // 没有可执行的工厂方法，抛出异常        if (constructorToUse == null) {            if (causes != null) {                UnsatisfiedDependencyException ex = causes.removeLast();                for (Exception cause : causes) {                    this.beanFactory.onSuppressedException(cause);                }                throw ex;            }            throw new BeanCreationException(mbd.getResourceDescription(), beanName,                    &quot;Could not resolve matching constructor &quot; +                    &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;);        } else if (ambiguousConstructors != null &amp;&amp; !mbd.isLenientConstructorResolution()) {            throw new BeanCreationException(mbd.getResourceDescription(), beanName,                    &quot;Ambiguous constructor matches found in bean &#39;&quot; + beanName + &quot;&#39; &quot; +                    &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +                    ambiguousConstructors);        }        if (explicitArgs == null) {            // 将解析的构造函数加入缓存            argsHolderToUse.storeCache(mbd, constructorToUse);        }    }    // 创建 Bean 对象，并设置到 bw 中    bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));    return bw;}</code></pre><p>代码和<code>#instantiateUsingFactoryMethod(...)</code>一样，跟老太太的裹脚布一样又臭又长。但是如果理解了<code>#instantiateUsingFactoryMethod(...)</code>方法的初始化过程，那么<code>#autowireConstructor(...)</code>其实也差不多。<br>一句话概括就是，首先确定构造函数参数、构造函数，然后调用相对应的初始化策略进行 Bean 的初始化。关于如何确定和上篇博文说的一样，这里不再重复。<br>我们主要来分析初始化策略这块代码。</p><h2 id="1-1-instantiate"><a href="#1-1-instantiate" class="headerlink" title="1.1 instantiate"></a>1.1 instantiate</h2><pre><code>// BeanUtils.java// SimpleInstantiationStrategy.java@Overridepublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,        final Constructor&lt;?&gt; ctor, Object... args) {    // 【1】 没有覆盖，直接使用反射实例化即可    if (!bd.hasMethodOverrides()) {        if (System.getSecurityManager() != null) {            // 设置构造方法，可访问            // use own privileged to change accessibility (when security is on)            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {                ReflectionUtils.makeAccessible(ctor);                return null;            });        }        // 通过 BeanUtils 直接使用构造器对象实例化 Bean 对象        return BeanUtils.instantiateClass(ctor, args);    } else {        // 【2】 生成 CGLIB 创建的子类对象        return instantiateWithMethodInjection(bd, beanName, owner, ctor, args);    }}</code></pre><font size=2><ul><li>【1】处，如果该 Bean 没有设置<code>lookup-method</code>、<code>replaced-method</code>、或者<code>@Lookup</code>注解，则直接通过反射的方法实例化 Bean对象。详见【1.1.1】</li><li>【2】处，如果存在需要覆盖的方法或者动态替换的方法时，则需要使用 CGLIB 进行动态代理。详见【1.1.2】</li></ul></font><h3 id="1-1-1-反射创建-Bean-对象"><a href="#1-1-1-反射创建-Bean-对象" class="headerlink" title="1.1.1 反射创建 Bean 对象"></a>1.1.1 反射创建 Bean 对象</h3><p>通过工具类 BeanUtils 的<code>#instantiateClass(...)</code>方法，完成反射工作。代码如下：</p><pre><code>// BeanUtils.javapublic static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args) throws BeanInstantiationException {    Assert.notNull(ctor, &quot;Constructor must not be null&quot;);    try {        // 设置构造方法，可访问        ReflectionUtils.makeAccessible(ctor);        // 使用构造方法，创建对象        return (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?                KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));    // 各种异常的翻译，最终统一抛出 BeanInstantiationException 异常    } catch (InstantiationException ex) {        throw new BeanInstantiationException(ctor, &quot;Is it an abstract class?&quot;, ex);    } catch (IllegalAccessException ex) {        throw new BeanInstantiationException(ctor, &quot;Is the constructor accessible?&quot;, ex);    } catch (IllegalArgumentException ex) {        throw new BeanInstantiationException(ctor, &quot;Illegal arguments for constructor&quot;, ex);    } catch (InvocationTargetException ex) {        throw new BeanInstantiationException(ctor, &quot;Constructor threw exception&quot;, ex.getTargetException());    }}</code></pre><h3 id="1-1-2-CGLIB-创建-Bean-对象"><a href="#1-1-2-CGLIB-创建-Bean-对象" class="headerlink" title="1.1.2 CGLIB 创建 Bean 对象"></a>1.1.2 CGLIB 创建 Bean 对象</h3><pre><code>// SimpleInstantiationStrategy.javaprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {    throw new UnsupportedOperationException(&quot;Method Injection not supported in SimpleInstantiationStrategy&quot;);}</code></pre><p>方法默认是没有实现的，具体过程由子类<code>org.springframework.beans.factory.support.CglibSubclassingInstantiationStrategy</code>来实现。代码如下：</p><pre><code>// CglibSubclassingInstantiationStrategy.java@Overrideprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {    return instantiateWithMethodInjection(bd, beanName, owner, null);}@Overrideprotected Object instantiateWithMethodInjection(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner, @Nullable Constructor&lt;?&gt; ctor, Object... args) {    // Must generate CGLIB subclass...    // 通过CGLIB生成一个子类对象    return new CglibSubclassCreator(bd, owner).instantiate(ctor, args);}</code></pre><p>创建一个 CglibSubclassCreator 对象，调用其<code>#instantiate(...)</code>方法，生成子类对象。代码如下：</p><pre><code>// CglibSubclassingInstantiationStrategy.javapublic Object instantiate(@Nullable Constructor&lt;?&gt; ctor, Object... args) {    // 通过 Cglib 创建一个代理类    Class&lt;?&gt; subclass = createEnhancedSubclass(this.beanDefinition);    Object instance;    // 没有构造器，通过 BeanUtils 使用默认构造器创建一个bean实例    if (ctor == null) {        instance = BeanUtils.instantiateClass(subclass);    } else {        try {            // 获取代理类对应的构造器对象，并实例化 bean            Constructor&lt;?&gt; enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());            instance = enhancedSubclassConstructor.newInstance(args);        } catch (Exception ex) {            throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),                    &quot;Failed to invoke constructor for CGLIB enhanced subclass [&quot; + subclass.getName() + &quot;]&quot;, ex);        }    }    // 为了避免 memory leaks 异常，直接在 bean 实例上设置回调对象    Factory factory = (Factory) instance;    factory.setCallbacks(new Callback[] {NoOp.INSTANCE,            new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),            new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});    return instance;}</code></pre><p>到了这里 CGLIB 的方法分析完毕了，当然还没有详细的说，具体的流程等后续 AOP 到时候在详细说明。</p><h1 id="2-instantiateBean"><a href="#2-instantiateBean" class="headerlink" title="2 instantiateBean"></a>2 instantiateBean</h1><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {    try {        Object beanInstance;        final BeanFactory parent = this;        // 安全模式        if (System.getSecurityManager() != null) {            beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;                    // 获得 InstantiationStrategy 对象，并使用它，创建 Bean 对象                    getInstantiationStrategy().instantiate(mbd, beanName, parent),                    getAccessControlContext());        } else {            // 获得 InstantiationStrategy 对象，并使用它，创建 Bean 对象            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);        }        // 封装 BeanWrapperImpl  并完成初始化        BeanWrapper bw = new BeanWrapperImpl(beanInstance);        initBeanWrapper(bw);        return bw;    } catch (Throwable ex) {        throw new BeanCreationException(                mbd.getResourceDescription(), beanName, &quot;Instantiation of bean failed&quot;, ex);    }}</code></pre><p>这个方法，相比于<code>#instantiateUsingFactoryMethod(...)</code>、<code>#autowireConstructor(...)</code>简直太照顾我们了。因为它没有参数，所以不需要经过复杂的确认构造器、构造参数。</p><h2 id="2-1-instantiate"><a href="#2-1-instantiate" class="headerlink" title="2.1 instantiate"></a>2.1 instantiate</h2><pre><code>// SimpleInstantiationStrategy.java@Overridepublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {    // Don&#39;t override the class with CGLIB if no overrides.    // 没有覆盖，直接使用反射实例化即可    if (!bd.hasMethodOverrides()) {        Constructor&lt;?&gt; constructorToUse;        synchronized (bd.constructorArgumentLock) {            // 获得构造方法 constructorToUse            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;            if (constructorToUse == null) {                final Class&lt;?&gt; clazz = bd.getBeanClass();                // 如果是接口，抛出 BeanInstantiationException 异常                if (clazz.isInterface()) {                    throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);                }                try {                    // 从 clazz 中，获得构造方法                    if (System.getSecurityManager() != null) { // 安全模式                        constructorToUse = AccessController.doPrivileged(                                (PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);                    } else {                        constructorToUse =  clazz.getDeclaredConstructor();                    }                    // 标记 resolvedConstructorOrFactoryMethod 属性                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;                } catch (Throwable ex) {                    throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);                }            }        }        // 通过 BeanUtils 直接使用构造器对象实例化 Bean 对象        return BeanUtils.instantiateClass(constructorToUse);    } else {        // Must generate CGLIB subclass.        // 生成 CGLIB 创建的子类对象        return instantiateWithMethodInjection(bd, beanName, owner);    }}</code></pre><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>对于<code>#createBeanInstance(...)</code>方法而言，他就是<strong>选择合适实例化策略来为 Bean 创建实例对象</strong>，具体策略有：</p><font size=2><ul><li>Supplier回调方式。</li><li>工厂方法初始化。</li><li>构造函数自动注入初始化。</li><li>默认构造函数注入。</li></ul></font><p>其中，工厂方法初始化和构造函数自动注入初始化最为复杂，主要原因还是构造函数和构造参数不确定。<br>当前，在实例化过程中会根据是否需要覆盖或者动态替换方法，来决定是否使用<strong>动态代理</strong>的模式，否则直接返回反射即可。</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建 Bean（二）之实例化 Bean 对象(1)</title>
      <link href="/2019/12/26/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96-Bean-%E5%AF%B9%E8%B1%A1-1/"/>
      <url>/2019/12/26/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E5%AE%9E%E4%BE%8B%E5%8C%96-Bean-%E5%AF%B9%E8%B1%A1-1/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><h1 id="1-createBeanInstance"><a href="#1-createBeanInstance" class="headerlink" title="1 createBeanInstance"></a>1 createBeanInstance</h1><p>这篇我们关注创建 Bean 的第一个步骤：实例化 Bean，对应的方法是<code>#createBeanInstance(...)</code>。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {    // 解析 bean ，将 bean 类名解析为 class 引用。    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);    if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) { // 校验        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                &quot;Bean class isn&#39;t public, and non-public access not allowed: &quot; + beanClass.getName());    }    // 【1】 如果存在 Supplier 回调，则使用给定的回调方法初始化策略    Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();    if (instanceSupplier != null) {        return obtainFromSupplier(instanceSupplier, beanName);    }    // 【2】 使用 FactoryBean 的 factory-method 来创建，支持静态工厂和实例工厂    if (mbd.getFactoryMethodName() != null)  {        return instantiateUsingFactoryMethod(beanName, mbd, args);    }    // 【3】 Shortcut when re-creating the same bean...    boolean resolved = false;    boolean autowireNecessary = false;    if (args == null) {        // constructorArgumentLock 构造函数的常用锁        synchronized (mbd.constructorArgumentLock) {            // 如果已缓存的解析的构造函数或者工厂方法不为空，则可以利用构造函数解析            // 因为需要根据参数确认到底使用哪个构造函数，该过程比较消耗性能，所有采用缓存机制            if (mbd.resolvedConstructorOrFactoryMethod != null) {                resolved = true;                autowireNecessary = mbd.constructorArgumentsResolved;            }        }    }    // 已经解析好了，直接注入即可    if (resolved) {        // 【3.1】 autowire 自动注入，调用构造函数自动注入        if (autowireNecessary) {            return autowireConstructor(beanName, mbd, null, null);        } else {            // 【3.2】 使用默认构造函数构造            return instantiateBean(beanName, mbd);        }    }    // 【4】 确定解析的构造函数    // 主要是检查已经注册的 SmartInstantiationAwareBeanPostProcessor    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);    // 【4.1】 有参数情况时，创建 Bean 。先利用参数个数，类型等，确定最精确匹配的构造方法。    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {        return autowireConstructor(beanName, mbd, ctors, args);    }    // 【4.1】 选择构造方法，创建 Bean 。    ctors = mbd.getPreferredConstructors();    if (ctors != null) {        return autowireConstructor(beanName, mbd, ctors, null); // args = null    }    // No special handling: simply use no-arg constructor.    // 【4.2    】 有参数时，又没获取到构造方法，则只能调用无参构造方法来创建实例了(兜底方法)    return instantiateBean(beanName, mbd);}</code></pre><p>实例化 Bean 对象，是一个<strong>复杂</strong>的过程，主要的流程是：<br><font size=2></p><ul><li>【1】处，如果存在 Supplier 回调，则调用<code>#obtainFromSupplier(...)</code>方法，进行初始化。<ul><li>详见【1.1】</li></ul></li><li>【2】处，如果存在工厂方法，则使用工厂方法进行初始化。<ul><li>详见【1.2】</li></ul></li><li>【3】处，首先判断缓存，如果缓存中存在，即已经解析过了，则直接使用已经解析的。根据<code>constructorArgumentsResolved</code>参数来判断。<ul><li>【3.1】处，使用构造函数自动注入，即调用<code>#autowireConstructor(...)</code>方法。</li><li>【3.2】处，还是默认构造函数注入，即调用<code>#instantiateBean(...）</code>方法。<ul><li>详见【【源码】IoC加载Bean之创建 Bean（三）】</li></ul></li></ul></li><li>【4】处，如果缓存中没有，则需要先确实使用哪个构造器来完成解析工作，因为一个类有多个构造函数，每个构造函数不同，所以需要根据参数来锁定构造函数并初始化。<ul><li>【4.1】处，如果窜在参数，则使用想对应的构造函数，即调用<code>#autowireConstructor(...)</code>方法。</li><li>【4.2】处，否则使用默认的构造函数，即调用<code>#instantiateBean(...）</code>方法。<ul><li>详见【【源码】IoC加载Bean之创建 Bean（三）】</li></ul></li></ul></li></ul></font><h2 id="1-1-obtainFromSupplier"><a href="#1-1-obtainFromSupplier" class="headerlink" title="1.1 obtainFromSupplier"></a>1.1 obtainFromSupplier</h2><pre><code>// AbstractAutowireCapableBeanFactory.java// protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {}Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();if (instanceSupplier != null) {    return obtainFromSupplier(instanceSupplier, beanName);}</code></pre><p>首先从 BeanDefinition 中获取 Supplier 对象。如果不为空，则调用<code>#obtainFromSupplier(...)</code>方法。</p><h3 id="1-1-1-Supplier"><a href="#1-1-1-Supplier" class="headerlink" title="1.1.1 Supplier"></a>1.1.1 Supplier</h3><p>那么什么是 Supplier 呢？在<code>java.util.function.Supplier</code>接口下。代码如下：</p><pre><code>public interface Supplier&lt;T&gt; {    T get();}</code></pre><p>Supplier 接口仅有一个功能性的<code>#get()</code>方法，该方法会返回<code>&lt;T&gt;</code>类型，有点类似工厂方法。<br>那这个接口用于指定创建 Bean 的回调。如果我们设置了这样的回调，那么其他的构造器或者工厂方法都会没有用。<br>Supplier 提供了相应的 setter 方法。代码如下：</p><pre><code>// AbstractBeanDefinition.java/** * 创建 Bean 的 Supplier 对象 */@Nullableprivate Supplier&lt;?&gt; instanceSupplier;public void setInstanceSupplier(@Nullable Supplier&lt;?&gt; instanceSupplier) {    this.instanceSupplier = instanceSupplier;}</code></pre><p>在构造 BeanDefinition 的时候，设置了<code>instanceSupplier</code>，该代码如下：（以RootBeanDefinition为例）</p><pre><code>// RootBeanDefinition.javapublic &lt;T&gt; RootBeanDefinition(@Nullable Class&lt;T&gt; beanClass, String scope, @Nullable Supplier&lt;T&gt; instanceSupplier) {    super();    setBeanClass(beanClass);    setScope(scope);    // 设置 instanceSupplier 属性    setInstanceSupplier(instanceSupplier);}</code></pre><h3 id="1-1-2-obtainFromSupplier"><a href="#1-1-2-obtainFromSupplier" class="headerlink" title="1.1.2 obtainFromSupplier"></a>1.1.2 obtainFromSupplier</h3><p>如果设置了<code>instanceSupplier</code>属性，则可以调用<code>#obtainFromSupplier(...)</code>方法，完成 Bean 的初始化。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.java/** * 当前线程，正在创建的 Bean 对象的名字 */private final NamedThreadLocal&lt;String&gt; currentlyCreatedBean = new NamedThreadLocal&lt;&gt;(&quot;Currently created bean&quot;);protected BeanWrapper obtainFromSupplier(Supplier&lt;?&gt; instanceSupplier, String beanName) {    Object instance;    // 获得原创建的 Bean 的对象名    String outerBean = this.currentlyCreatedBean.get();    // 设置新的 Bean 的对象名，到 currentlyCreatedBean 中    this.currentlyCreatedBean.set(beanName);    try {        // 【1】 调用 Supplier 的 get()，返回一个 Bean 对象        instance = instanceSupplier.get();    } finally {        // 设置原创建的 Bean 的对象名，到 currentlyCreatedBean 中        if (outerBean != null) {            this.currentlyCreatedBean.set(outerBean);        } else {            this.currentlyCreatedBean.remove();        }    }    // 未创建 Bean 对象，则创建 NullBean 对象    if (instance == null) {        instance = new NullBean();    }    // 【2】 创建 BeanWrapper 对象    BeanWrapper bw = new BeanWrapperImpl(instance);    // 【3】 初始化 BeanWrapper 对象    initBeanWrapper(bw);    return bw;}</code></pre><p>代码很简单，流程如下：<br><font size=2></p><ul><li>【1】处，调用 Supplier 的<code>#get()</code>方法，获得一个 Bean 实例对象。</li><li>【2】处，根据实例对象构造一个 BeanWrapper 对象。</li><li>【3】处，最后初始化该对象。</li></ul></font><p>有关 BeanWrapper 后续再详说。</p><h2 id="1-2-instantiateUsingFactoryMethod"><a href="#1-2-instantiateUsingFactoryMethod" class="headerlink" title="1.2 instantiateUsingFactoryMethod"></a>1.2 instantiateUsingFactoryMethod</h2><p>如果存在工厂方法，则调用<code>#instantiateUsingFactoryMethod(...)</code>方法，完成 Bean 的初始化工作。（操，这个方法太特么长了！！！）</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected BeanWrapper instantiateUsingFactoryMethod(String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {    return new ConstructorResolver(this).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);}</code></pre><p>构造一个 ConstructorResolver 对象，然后调用其<code>#instantiateUsingFactoryMethod(...)</code>方法。</p><h3 id="1-2-1-ConstructorResolver"><a href="#1-2-1-ConstructorResolver" class="headerlink" title="1.2.1 ConstructorResolver"></a>1.2.1 ConstructorResolver</h3><p><code>org.springframework.expression.ConstructorResolver</code>是构造方法或者工厂类初始化 Bean 的委托类。代码如下：</p><pre><code>// ConstructorResolver.javapublic BeanWrapper instantiateUsingFactoryMethod(        String beanName, RootBeanDefinition mbd, @Nullable Object[] explicitArgs) {    // 构造 BeanWrapperImpl 对象    BeanWrapperImpl bw = new BeanWrapperImpl();    // 初始化 BeanWrapperImpl    // 向BeanWrapper对象中添加 ConversionService 对象和属性编辑器 PropertyEditor 对象    this.beanFactory.initBeanWrapper(bw);    // 【1】 获得 factoryBean、factoryClass、isStatic、factoryBeanName 属性    Object factoryBean;    Class&lt;?&gt; factoryClass;    boolean isStatic;    String factoryBeanName = mbd.getFactoryBeanName();    // 工厂名不为空    if (factoryBeanName != null) {        if (factoryBeanName.equals(beanName)) { // 抛出 BeanDefinitionStoreException 异常            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,                    &quot;factory-bean reference points back to the same bean definition&quot;);        }        // 获取工厂实例        factoryBean = this.beanFactory.getBean(factoryBeanName);        if (mbd.isSingleton() &amp;&amp; this.beanFactory.containsSingleton(beanName)) { // 抛出 ImplicitlyAppearedSingletonException 异常            throw new ImplicitlyAppearedSingletonException();        }        factoryClass = factoryBean.getClass();        isStatic = false;    } else {        // 工厂名为空，则其可能是一个静态工厂        // 静态工厂创建bean，必须要提供工厂的全类名        if (!mbd.hasBeanClass()) {            throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,                    &quot;bean definition declares neither a bean class nor a factory-bean reference&quot;);        }        factoryBean = null;        factoryClass = mbd.getBeanClass();        isStatic = true;    }    // 【2】 获得 factoryMethodToUse、argsHolderToUse、argsToUse 属性    Method factoryMethodToUse = null;  // 工厂方法    ArgumentsHolder argsHolderToUse = null;    Object[] argsToUse = null; // 参数    // 【2.1】 如果指定了构造参数则直接使用    // 在调用 getBean 方法的时候指定了方法参数    if (explicitArgs != null) {        argsToUse = explicitArgs;    } else {        // 没有指定，则尝试从配置文件中解析        Object[] argsToResolve = null;        // 【2.2】 首先尝试从缓存中获取        synchronized (mbd.constructorArgumentLock) {            // 获取缓存中的构造函数或者工厂方法            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;            if (factoryMethodToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {                // 获取缓存中的构造参数                argsToUse = mbd.resolvedConstructorArguments;                if (argsToUse == null) {                    // 获取缓存中的构造函数参数的包可见字段                    argsToResolve = mbd.preparedConstructorArguments;                }            }        }        // 缓存中存在,则解析存储在 BeanDefinition 中的参数        // 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)        // 缓存中的值可能是原始值也有可能是最终值        if (argsToResolve != null) {            argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true);        }    }    // 【3】    if (factoryMethodToUse == null || argsToUse == null) {        // 获取工厂方法的类全名称        factoryClass = ClassUtils.getUserClass(factoryClass);        // 获取所有待定方法        Method[] rawCandidates = getCandidateMethods(factoryClass, mbd);        // 检索所有方法，这里是对方法进行过滤        List&lt;Method&gt; candidateList = new ArrayList&lt;&gt;();        for (Method candidate : rawCandidates) {            // 如果有static 且为工厂方法，则添加到 candidateSet 中            if (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) {                candidateList.add(candidate);            }        }        // 创建 Bean        if (candidateList.size() == 1 &amp;&amp; explicitArgs == null &amp;&amp; !mbd.hasConstructorArgumentValues()) {            Method uniqueCandidate = candidateList.get(0);            if (uniqueCandidate.getParameterCount() == 0) {                synchronized (mbd.constructorArgumentLock) {                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;                    mbd.constructorArgumentsResolved = true;                    mbd.resolvedConstructorArguments = EMPTY_ARGS;                }                bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, uniqueCandidate, EMPTY_ARGS));                return bw;            }        }        Method[] candidates = candidateList.toArray(new Method[0]);        // 排序构造函数        // public 构造函数优先参数数量降序，非 public 构造函数参数数量降序        AutowireUtils.sortFactoryMethods(candidates);        // 用于承载解析后的构造函数参数的值        ConstructorArgumentValues resolvedValues = null;        boolean autowiring = (mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);        int minTypeDiffWeight = Integer.MAX_VALUE;        Set&lt;Method&gt; ambiguousFactoryMethods = null;        int minNrOfArgs;        if (explicitArgs != null) {            minNrOfArgs = explicitArgs.length;        } else {            // 【2.3】 getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数            if (mbd.hasConstructorArgumentValues()) {                // 构造函数的参数                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();                resolvedValues = new ConstructorArgumentValues();                // 解析构造函数的参数                // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);            } else {                minNrOfArgs = 0;            }        }        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = null; // 记录 UnsatisfiedDependencyException 异常的集合        // 遍历 candidates 数组        for (Method candidate : candidates) {            // 方法体的参数            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();            if (paramTypes.length &gt;= minNrOfArgs) {                // 保存参数的对象                ArgumentsHolder argsHolder;                // #getBean(...) 传递了参数                if (explicitArgs != null) {                    // Explicit arguments given -&gt; arguments length must match exactly.                    // 显示给定参数，参数长度必须完全匹配                    if (paramTypes.length != explicitArgs.length) {                        continue;                    }                    // 根据参数创建参数持有者 ArgumentsHolder 对象                    argsHolder = new ArgumentsHolder(explicitArgs);                } else {                    // 为提供参数，解析构造参数                    try {                        String[] paramNames = null;                        // 获取 ParameterNameDiscoverer 对象                        // ParameterNameDiscoverer 是用于解析方法和构造函数的参数名称的接口，为参数名称探测器                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();                        // 获取指定构造函数的参数名称                        if (pnd != null) {                            paramNames = pnd.getParameterNames(candidate);                        }                        // 在已经解析的构造函数参数值的情况下，创建一个参数持有者 ArgumentsHolder 对象                        argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw,                                paramTypes, paramNames, candidate, autowiring, candidates.length == 1);                    } catch (UnsatisfiedDependencyException ex) {                        // 若发生 UnsatisfiedDependencyException 异常，添加到 causes 中。                        if (logger.isTraceEnabled()) {                            logger.trace(&quot;Ignoring factory method [&quot; + candidate + &quot;] of bean &#39;&quot; + beanName + &quot;&#39;: &quot; + ex);                        }                        if (causes == null) {                            causes = new LinkedList&lt;&gt;();                        }                        causes.add(ex);                        continue; // continue ，继续执行                    }                }                // isLenientConstructorResolution 判断解析构造函数的时候是否以宽松模式还是严格模式                // 严格模式：解析构造函数时，必须所有的都需要匹配，否则抛出异常                // 宽松模式：使用具有&quot;最接近的模式&quot;进行匹配                // typeDiffWeight：类型差异权重                int typeDiffWeight = (mbd.isLenientConstructorResolution() ?                        argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));                // Choose this factory method if it represents the closest match.                // 代表最接近的类型匹配，则选择作为构造函数                if (typeDiffWeight &lt; minTypeDiffWeight) {                    factoryMethodToUse = candidate;                    argsHolderToUse = argsHolder;                    argsToUse = argsHolder.arguments;                    minTypeDiffWeight = typeDiffWeight;                    ambiguousFactoryMethods = null;                }                // 如果具有相同参数数量的方法具有相同的类型差异权重，则收集此类型选项                // 但是，仅在非宽松构造函数解析模式下执行该检查，并显式忽略重写方法（具有相同的参数签名）                else if (factoryMethodToUse != null &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;                        !mbd.isLenientConstructorResolution() &amp;&amp;                        paramTypes.length == factoryMethodToUse.getParameterCount() &amp;&amp;                        !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) {                    // 查找到多个可匹配的方法                    if (ambiguousFactoryMethods == null) {                        ambiguousFactoryMethods = new LinkedHashSet&lt;&gt;();                        ambiguousFactoryMethods.add(factoryMethodToUse);                    }                    ambiguousFactoryMethods.add(candidate);                }            }        }        // 没有可执行的工厂方法，抛出异常        if (factoryMethodToUse == null) {            if (causes != null) {                UnsatisfiedDependencyException ex = causes.removeLast();                for (Exception cause : causes) {                    this.beanFactory.onSuppressedException(cause);                }                throw ex;            }            List&lt;String&gt; argTypes = new ArrayList&lt;&gt;(minNrOfArgs);            if (explicitArgs != null) {                for (Object arg : explicitArgs) {                    argTypes.add(arg != null ? arg.getClass().getSimpleName() : &quot;null&quot;);                }            } else if (resolvedValues != null) {                Set&lt;ValueHolder&gt; valueHolders = new LinkedHashSet&lt;&gt;(resolvedValues.getArgumentCount());                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());                valueHolders.addAll(resolvedValues.getGenericArgumentValues());                for (ValueHolder value : valueHolders) {                    String argType = (value.getType() != null ? ClassUtils.getShortName(value.getType()) :                            (value.getValue() != null ? value.getValue().getClass().getSimpleName() : &quot;null&quot;));                    argTypes.add(argType);                }            }            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);            throw new BeanCreationException(mbd.getResourceDescription(), beanName,                    &quot;No matching factory method found: &quot; +                    (mbd.getFactoryBeanName() != null ?                        &quot;factory bean &#39;&quot; + mbd.getFactoryBeanName() + &quot;&#39;; &quot; : &quot;&quot;) +                    &quot;factory method &#39;&quot; + mbd.getFactoryMethodName() + &quot;(&quot; + argDesc + &quot;)&#39;. &quot; +                    &quot;Check that a method with the specified name &quot; +                    (minNrOfArgs &gt; 0 ? &quot;and arguments &quot; : &quot;&quot;) +                    &quot;exists and that it is &quot; +                    (isStatic ? &quot;static&quot; : &quot;non-static&quot;) + &quot;.&quot;);        } else if (void.class == factoryMethodToUse.getReturnType()) {            throw new BeanCreationException(mbd.getResourceDescription(), beanName,                    &quot;Invalid factory method &#39;&quot; + mbd.getFactoryMethodName() +                    &quot;&#39;: needs to have a non-void return type!&quot;);        } else if (ambiguousFactoryMethods != null) {            throw new BeanCreationException(mbd.getResourceDescription(), beanName,                    &quot;Ambiguous factory method matches found in bean &#39;&quot; + beanName + &quot;&#39; &quot; +                    &quot;(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; +                    ambiguousFactoryMethods);        }        if (explicitArgs == null &amp;&amp; argsHolderToUse != null) {            // 将解析的构造函数加入缓存            argsHolderToUse.storeCache(mbd, factoryMethodToUse);        }    }    // 创建 Bean 对象，并设置到 bw 中    bw.setBeanInstance(instantiate(beanName, mbd, factoryBean, factoryMethodToUse, argsToUse));    return bw;}private Object instantiate(        String beanName, RootBeanDefinition mbd, Constructor constructorToUse, Object[] argsToUse) {    try {        InstantiationStrategy strategy = this.beanFactory.getInstantiationStrategy();        if (System.getSecurityManager() != null) {            return AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;                    strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse),                    this.beanFactory.getAccessControlContext());        } else {            return strategy.instantiate(mbd, beanName, this.beanFactory, constructorToUse, argsToUse);        }    } catch (Throwable ex) {        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                &quot;Bean instantiation via constructor failed&quot;, ex);    }}</code></pre><p><code>#instantiateUsingFactoryMethod(...)</code>方法，实在太特么长了。细节很复杂，感觉和之前是 Spring 代码完全不一样风格啊。有不知道哪位大神写出来的。Spring 之前的代码也存在很复杂的逻辑，但是都是将一个复杂的逻辑，拆分成不同的细小模块，每个模块负责一部分功能。<br>虽然该方法体量大，但是通过可以通过<strong>一句话概括</strong>，确定工厂对象，然后获取构造函数和构造参数，最后调用 InstantiationStrategy 对象的<code>#instantiate(...)</code>方法，创建 Bean 实例。</p><h4 id="1-2-1-1-确定工厂对象"><a href="#1-2-1-1-确定工厂对象" class="headerlink" title="1.2.1.1 确定工厂对象"></a>1.2.1.1 确定工厂对象</h4><blockquote><p>对应【1】处。</p></blockquote><p>首先获取工厂方法名：</p><font size=2><ul><li>若工厂方法名不为空，则调用<code>AbstractAutowireCapableBeanFactory#getBean(...)</code>方法，获取工厂对象。</li><li>若为空，则可能为一个静态工厂，对于静态工厂必须提供工厂类的全类名，同时设置<code>factoryBean = null</code>。</li></ul></font><h4 id="1-2-1-2-构造参数确认"><a href="#1-2-1-2-构造参数确认" class="headerlink" title="1.2.1.2 构造参数确认"></a>1.2.1.2 构造参数确认</h4><blockquote><p>对应【2】处。</p></blockquote><p>工厂对象确认后，则是确认构造参数。构造参数的确认分为三种情况：</p><font size=2><ul><li><code>explicitArgs</code>参数。</li><li>缓存中获取。</li><li>配置文件中解析。</li></ul></font><h5 id="1-2-1-2-1-explicitArgs-参数"><a href="#1-2-1-2-1-explicitArgs-参数" class="headerlink" title="1.2.1.2.1 explicitArgs 参数"></a>1.2.1.2.1 explicitArgs 参数</h5><blockquote><p>对应【2.1】处</p></blockquote><p><code>explicitArgs</code>参数，是我们调用<code>#getBean(...)</code>方法时传递进来的，一般该参数是用于初始化 Bean 时所传递的参数。如果该参数不为空，就可以确定构造函数的参数就是它。</p><h4 id="1-2-1-2-2-缓存中获取哦"><a href="#1-2-1-2-2-缓存中获取哦" class="headerlink" title="1.2.1.2.2 缓存中获取哦"></a>1.2.1.2.2 缓存中获取哦</h4><blockquote><p>对应【2.2】处</p></blockquote><p>该方法最后，我们会发现一段<code>argsHolderToUse.storeCache(...)</code>代码。这段代码主要是讲构造函数、构造参数保存到缓冲中。</p><pre><code>// ConstructorResolver.ArgumentsHolder.javapublic void storeCache(RootBeanDefinition mbd, Executable constructorOrFactoryMethod) {    synchronized (mbd.constructorArgumentLock) {        mbd.resolvedConstructorOrFactoryMethod = constructorOrFactoryMethod;        mbd.constructorArgumentsResolved = true;        if (this.resolveNecessary) {            mbd.preparedConstructorArguments = this.preparedArguments;        } else {            mbd.resolvedConstructorArguments = this.arguments;        }    }}// RootBeanDefinition.javafinal Object constructorArgumentLock = new Object(); // 构造函数的缓存锁@NullableExecutable resolvedConstructorOrFactoryMethod; // 缓存已经解析的构造函数或者工厂方法boolean constructorArgumentsResolved = false; // 标记字段，标记构造函数、参数已经解析了。默认为 `false` 。@NullableObject[] resolvedConstructorArguments; // 缓存已经解析的构造函数参数，包可见字段。@NullableObject[] preparedConstructorArguments;</code></pre><p>其中涉及几个参数，都是跟构造函数、构造函数缓存有关的。<br><font size=2></p><ul><li><code>constructorArgumentLock</code>：构造函数的缓存锁。</li><li><code>resolvedConstructorOrFactoryMethod</code>：缓存已经解析的构造函数或者工厂方法。</li><li><code>constructorArgumentsResolved</code>：标记字段，标记构造函数已经解析的。默认是<code>false</code>。</li><li><code>resolvedConstructorArguments</code>：缓存已经解析的构造函数参数，包可见字段。</li><li><code>preparedConstructorArguments</code></li></ul></font><p>所以从缓存中取出的就是这几个值。代码如下：</p><pre><code>// ConstructorResolver.java// 没有指定，则尝试从配置文件中解析Object[] argsToResolve = null;// 【2.2】 首先尝试从缓存中获取synchronized (mbd.constructorArgumentLock) {    // 获取缓存中的构造函数或者工厂方法    factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;    if (factoryMethodToUse != null &amp;&amp; mbd.constructorArgumentsResolved) {        // Found a cached factory method...        // 获取缓存中的构造参数        argsToUse = mbd.resolvedConstructorArguments;        if (argsToUse == null) {            // 获取缓存中的构造函数参数的包可见字段            argsToResolve = mbd.preparedConstructorArguments;        }    }}// 缓存中存在,则解析存储在 BeanDefinition 中的参数// 如给定方法的构造函数 A(int ,int )，则通过此方法后就会把配置文件中的(&quot;1&quot;,&quot;1&quot;)转换为 (1,1)// 缓存中的值可能是原始值也有可能是最终值if (argsToResolve != null) {    argsToUse = resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve, true);}</code></pre><p>如果缓存中存在的构造参数，则需要调用<code>#resolvePreparedArguments(...)</code>方法转换一下。因为缓存中的值有可能是最终值，也有可能不是最终值。比如我们构造函数中的类型为 Integer 类型的 1 ，但是原始的参数类型有可能是 String 类型的 “1” ，所以即便是从缓存中得到了构造参数，也需要经过一番的类型转换确保参数类型完全对应。</p><h4 id="1-2-1-2-3-配置文件解析"><a href="#1-2-1-2-3-配置文件解析" class="headerlink" title="1.2.1.2.3 配置文件解析"></a>1.2.1.2.3 配置文件解析</h4><blockquote><p>对应【2.3】处。</p></blockquote><p>即没有通过传递参数的方法传递构造参数，缓存中也没有。那就只能从配置文件中获取构造参数了。<br><br/><br>在 Bean 的解析类博文中，我们提到配置文件中的信息都会转换成 BeanDefinition 实例对象，所以配置文件的参数可以直接通过 BeanDefinition 对象获取。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.java// 【2.3】 getBean() 没有传递参数，则需要解析保存在 BeanDefinition 构造函数中指定的参数if (mbd.hasConstructorArgumentValues()) {    // 【2.3.1】 构造函数的参数    ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();    resolvedValues = new ConstructorArgumentValues();    // 【2.3.2】 解析构造函数的参数    // 将该 bean 的构造函数参数解析为 resolvedValues 对象，其中会涉及到其他 bean    minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);}</code></pre><font size=2><ul><li>【2.3.1】处，通过 BeanDefinition 的<code>#getConstructorArgumentValues()</code>方法，就可以获取构造信息了。</li><li>【2.3.2】处，有了构造信息就可以获取相关的参数信息，这一步交由<code>#resolveConstructorArguments(...)</code>方法完成，该方法会将构造参数信息解析为<code>resolvedValues</code>对象，并返回解析到的参数个数<code>minNrOfArgs</code>。</li></ul></font><h3 id="1-2-1-3-构造函数"><a href="#1-2-1-3-构造函数" class="headerlink" title="1.2.1.3 构造函数"></a>1.2.1.3 构造函数</h3><blockquote><p>对应【3】处。</p></blockquote><p>确定构造参数后，下一步则是确定构造函数。  </p><font size=2><ul><li>第一步，通过<code>#getCandidateMethods()</code>获取所有的构造方法，然后对构造方法进行筛选。</li><li>然后，对其进行排序处理。排序的主要目的是为了能够<strong>更方便的找到匹配的构造函数</strong>。</li></ul></font><h3 id="1-2-1-4-创建-Bean-实例"><a href="#1-2-1-4-创建-Bean-实例" class="headerlink" title="1.2.1.4 创建 Bean 实例"></a>1.2.1.4 创建 Bean 实例</h3><blockquote><p>对应【4】处。</p></blockquote><p>工厂方法、构造函数、构造参数都已经确定了，最后一步就是调用<code>org.springframework.beans.factory.support.InstantiationStrategy</code>对象的<code>#instantiate(...)</code>方法，来创建 Bean 实例。代码如下：</p><pre><code>// SimpleInstantiationStrategy.java/** * 线程变量，正在创建 Bean 的 Method 对象 */private static final ThreadLocal&lt;Method&gt; currentlyInvokedFactoryMethod = new ThreadLocal&lt;&gt;();@Overridepublic Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner,        @Nullable Object factoryBean, final Method factoryMethod, Object... args) {    try {        // 设置 Method 可访问        if (System.getSecurityManager() != null) {            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {                ReflectionUtils.makeAccessible(factoryMethod);                return null;            });        } else {            ReflectionUtils.makeAccessible(factoryMethod);        }        // 获得原 Method 对象        Method priorInvokedFactoryMethod = currentlyInvokedFactoryMethod.get();        try {            // 设置新的 Method 对象，到 currentlyInvokedFactoryMethod 中            currentlyInvokedFactoryMethod.set(factoryMethod);            // 【X】 创建 Bean 对象            Object result = factoryMethod.invoke(factoryBean, args);            // 未创建，则创建 NullBean 对象            if (result == null) {                result = new NullBean();            }            return result;        } finally {            // 设置老的 Method 对象，到 currentlyInvokedFactoryMethod 中            if (priorInvokedFactoryMethod != null) {                currentlyInvokedFactoryMethod.set(priorInvokedFactoryMethod);            } else {                currentlyInvokedFactoryMethod.remove();            }        }    } catch (IllegalArgumentException ex) {        throw new BeanInstantiationException(factoryMethod,                &quot;Illegal arguments to factory method &#39;&quot; + factoryMethod.getName() + &quot;&#39;; &quot; +                &quot;args: &quot; + StringUtils.arrayToCommaDelimitedString(args), ex);    } catch (IllegalAccessException ex) {        throw new BeanInstantiationException(factoryMethod,                &quot;Cannot access factory method &#39;&quot; + factoryMethod.getName() + &quot;&#39;; is it public?&quot;, ex);    } catch (InvocationTargetException ex) {        String msg = &quot;Factory method &#39;&quot; + factoryMethod.getName() + &quot;&#39; threw exception&quot;;        if (bd.getFactoryBeanName() != null &amp;&amp; owner instanceof ConfigurableBeanFactory &amp;&amp;                ((ConfigurableBeanFactory) owner).isCurrentlyInCreation(bd.getFactoryBeanName())) {            msg = &quot;Circular reference involving containing bean &#39;&quot; + bd.getFactoryBeanName() + &quot;&#39; - consider &quot; +                    &quot;declaring the factory method as static for independence from its containing instance. &quot; + msg;        }        throw new BeanInstantiationException(factoryMethod, msg, ex.getTargetException());    }}</code></pre><p>核心的部分在<code>【X】</code>处，利用 Java 反射执行工厂方法并返回创建好的实例。代码如下：</p><pre><code>// SimpleInstantiationStrategy.javaObject result = factoryMethod.invoke(factoryBean, args);</code></pre><h1 id="2-小结"><a href="#2-小结" class="headerlink" title="2 小结"></a>2 小结</h1><p><code>#createBeanInstance(...)</code>方法中还有两个特别重要的方法：<br><font size=2></p><ul><li><code>autowireConstructor(...)</code>方法。</li><li><code>#instantiateBean(...)</code>方法。</li></ul></font><p>我们在下一篇博客在详细说明这俩方法。</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建 Bean（一）之主流程</title>
      <link href="/2019/12/26/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E4%B8%BB%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/12/26/%E5%88%9B%E5%BB%BA-Bean%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E4%B8%BB%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><blockquote><p>在上篇中我们注意到一个重要的方法<code>#createBean(...)</code>方法，这是一个<strong>核心方法</strong>，要特别的注意！</p></blockquote><h1 id="1-createBean-抽象方法"><a href="#1-createBean-抽象方法" class="headerlink" title="1 createBean 抽象方法"></a>1 createBean 抽象方法</h1><pre><code>// AbstractBeanFactory.javaprotected abstract Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)        throws BeanCreationException;</code></pre><p>该方法定义在<code>AbstractBeanFactory</code>抽象类中，含义是根据给定的<code>BeanDefinition</code>和<code>args</code>实例出一个 Bean 对象。<br>如果该 BeanDefinition 存在父类，则该 BeanDefinition 已经合并了父类的属性。<br>所有 Bean 实例的创建，都会委托给该方法实现。  </p><font size=2><ul><li>该方法接收三个参数：</li><li>beanName：bean 的名字。</li><li>mbd：已经合并了父类属性的 BeanDefinition。</li><li>args：用于构造函数或者工厂方法创建 Bean 实例对象的参数。</li></ul></font><h1 id="2-createBean-默认实现"><a href="#2-createBean-默认实现" class="headerlink" title="2 createBean 默认实现"></a>2 createBean 默认实现</h1><pre><code>// AbstractAutowireCapableBeanFactory.java@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)        throws BeanCreationException {    if (logger.isTraceEnabled()) {        logger.trace(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);    }    RootBeanDefinition mbdToUse = mbd;    // 【1】 确保此时的 bean 已经被解析了    // 如果获取的class 属性不为null，则克隆该 BeanDefinition    // 主要是因为该动态解析的 class 无法保存到到共享的 BeanDefinition    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);    if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {        mbdToUse = new RootBeanDefinition(mbd);        mbdToUse.setBeanClass(resolvedClass);    }    // Prepare method overrides.    try {        // 【2】 验证和准备覆盖方法        mbdToUse.prepareMethodOverrides();    } catch (BeanDefinitionValidationException ex) {        throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),                beanName, &quot;Validation of method overrides failed&quot;, ex);    }    try {        // 【3】 实例化的前置处理        // 给 BeanPostProcessors 一个机会用来返回一个代理类而不是真正的类实例        // AOP 的功能就是基于这个地方        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);        if (bean != null) {            return bean;        }    } catch (Throwable ex) {        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,                &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);    }    try {        // 【4】 创建 Bean 对象        Object beanInstance = doCreateBean(beanName, mbdToUse, args);        if (logger.isTraceEnabled()) {            logger.trace(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);        }        return beanInstance;    } catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {        throw ex;    } catch (Throwable ex) {        throw new BeanCreationException(                mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);    }}</code></pre><font size=2><ul><li>【1】处，解析指定的 BeanDefinition 的 class 属性。</li><li>【2】处，处理<code>override</code>属性。</li><li>【3】处，实例化的前置处理器。</li><li>【4】处，创建 Bean 对象。</li></ul></font><h2 id="2-1-解析指定-BeanDefinition-的-class"><a href="#2-1-解析指定-BeanDefinition-的-class" class="headerlink" title="2.1 解析指定 BeanDefinition 的 class"></a>2.1 解析指定 BeanDefinition 的 class</h2><pre><code>// AbstractAutowireCapableBeanFactory.javaClass&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) {    mbdToUse = new RootBeanDefinition(mbd);    mbdToUse.setBeanClass(resolvedClass);}</code></pre><p><code>#resolveBeanClass(...)</code>方法，主要是解析 BeanDefinition 的 class 类，并将已经解析的 Class 存储在 BeanDefinition 中供后面使用。<br>如果解析的 class 不为空，则会将该 BeanDefinition 进行设置到 <code>mbdToUse</code>中，这要做的主要目的，是因为动态解析的 class 是无法保存到共享的 BeanDefinition 中。</p><h2 id="2-2-处理-override-属性"><a href="#2-2-处理-override-属性" class="headerlink" title="2.2 处理 override 属性"></a>2.2 处理 override 属性</h2><p>在 Bean 实例化过程中，如果检测到存在<code>methodOverride</code>，则会动态地为当前 Bean 生成代理并使用对应的拦截器为 Bean 做增强处理。具体如何增强后续分析，现在先看<code>mbdToUse.prepareMethodOverrides()</code>代码块做了什么。代码如下：</p><pre><code>// AbstractBeanDefinition.javapublic void prepareMethodOverrides() throws BeanDefinitionValidationException {    // Check that lookup methods exists.    if (hasMethodOverrides()) {        Set&lt;MethodOverride&gt; overrides = getMethodOverrides().getOverrides();        synchronized (overrides) { // 同步            // 循环，执行 prepareMethodOverride            for (MethodOverride mo : overrides) {                prepareMethodOverride(mo);            }        }    }}</code></pre><p>如果存在<code>methodOverride</code>，则获取所有的 methodOverride，然后通过遍历的方法一次调用<code>#prepareMethodOverride()</code>方法，代码如下：</p><pre><code>// AbstractBeanDefinition.javaprotected void prepareMethodOverride(MethodOverride mo) throws BeanDefinitionValidationException {    int count = ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());    if (count == 0) {        throw new BeanDefinitionValidationException(                &quot;Invalid method override: no method with name &#39;&quot; + mo.getMethodName() +                &quot;&#39; on class [&quot; + getBeanClassName() + &quot;]&quot;);    } else if (count == 1) {        // Mark override as not overloaded, to avoid the overhead of arg type checking.        mo.setOverloaded(false);    }}</code></pre><font size=2><ul><li>根据方法名称，从 class 中获取该方法名的个数。<ul><li>如果为0，则抛出 BeanDefinitionValidationException 异常。</li><li>如果为1，则设置该重载方法没有被重载。</li></ul></li><li>如果一个类中存在多个重载方法，则在方法调用的时候在来决定到底重载哪个。</li></ul></font><p>我们看到<code>mbdToUse.prepareMethodOverrides()</code>代码块，其实并没有做什么实例工作，仅仅是对<code>methodOverride</code>属性做了一些简单的校验。</p><h2 id="2-3-实例化的前置处理"><a href="#2-3-实例化的前置处理" class="headerlink" title="2.3 实例化的前置处理"></a>2.3 实例化的前置处理</h2><p><code>#resolveBeforeInstantiation(...)</code>方法的作用，是给 BeanPostProcessors 后置处理器返回一个<strong>代理对象</strong>的机会，其实在调用该方法之前 Spring 一直都没有创建 Bean，name这里返回一个 Bean 的代理又有什么意义？这是为了在后续做<code>if</code>判断使用。代码如下：</p><pre><code>// AbstractBeanDefinition.javaObject bean = resolveBeforeInstantiation(beanName, mbdToUse);// ↓↓↓ if (bean != null) {    return bean;}</code></pre><font size=2><ul><li>如果代理对象不为空，则直接返回代理对象，<strong>这一步很重要</strong>！！Spring 后续实现 AOP 就是通过这个判断。</li><li><code>#resolveBeforeInstantiation(...)</code>方法。代码如下：</li></ul><pre><code>// AbstractAutowireCapableBeanFactory.java@Nullableprotected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {    Object bean = null;    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {        // Make sure bean class is actually resolved at this point.        if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);            if (targetType != null) {                // 前置                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);                if (bean != null) {                    // 后置                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);                }            }        }        mbd.beforeInstantiationResolved = (bean != null);    }    return bean;}</code></pre><p>这个方法的核心在于<code>#applyBeanPostProcessorsBeforeInstantiation()</code>和<code>#applyBeanPostProcessorsAfterInitialization()</code>两个方法，before 为实例化前的后置处理器，after 为实例化后的后置处理器。<br>后续这两个方法会在详细说明。</p></font><h2 id="2-4-创建-Bean"><a href="#2-4-创建-Bean" class="headerlink" title="2.4 创建 Bean"></a>2.4 创建 Bean</h2><p>如果没有代理对象，就只能走正常的路线进行 Bean 的创建了。该过程由<code>#doCreateBean(...)</code>方法来实现。代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)        throws BeanCreationException {    // BeanWrapper 是对 Bean 的包装，其接口中所定义的功能很简单包括设置获取被包装的对象，获取被包装 bean 的属性描述器    BeanWrapper instanceWrapper = null;    // 【1】 单例模型，则从未完成的 FactoryBean 缓存中删除    if (mbd.isSingleton()) {        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);    }    // 【2】 使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化    if (instanceWrapper == null) {        instanceWrapper = createBeanInstance(beanName, mbd, args);    }    // 包装的实例对象    final Object bean = instanceWrapper.getWrappedInstance();    // 包装的实例对象的类型    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();    if (beanType != NullBean.class) {        mbd.resolvedTargetType = beanType;    }    // 【3】 判断是否有后置处理    // 如果有后置处理，则允许后置处理修改 BeanDefinition    synchronized (mbd.postProcessingLock) {        if (!mbd.postProcessed) {            try {                // 后置处理修改 BeanDefinition                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);            } catch (Throwable ex) {                throw new BeanCreationException(mbd.getResourceDescription(), beanName,                        &quot;Post-processing of merged bean definition failed&quot;, ex);            }            mbd.postProcessed = true;        }    }    // 【4】 解决单例模式的循环依赖    boolean earlySingletonExposure = (mbd.isSingleton() // 单例模式            &amp;&amp; this.allowCircularReferences // 运行循环依赖            &amp;&amp; isSingletonCurrentlyInCreation(beanName)); // 当前单例 bean 是否正在被创建    if (earlySingletonExposure) {        if (logger.isTraceEnabled()) {            logger.trace(&quot;Eagerly caching bean &#39;&quot; + beanName +                    &quot;&#39; to allow for resolving potential circular references&quot;);        }        // 提前将创建的 bean 实例加入到 singletonFactories 中        // 这里是为了后期避免循环依赖        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));    }    // 开始初始化 bean 实例对象    Object exposedObject = bean;    try {        // 【5】 对 bean 进行填充，将各个属性值注入，其中，可能存在依赖于其他 bean 的属性        // 则会递归初始依赖 bean        populateBean(beanName, mbd, instanceWrapper);        // 【6】 调用初始化方法        exposedObject = initializeBean(beanName, exposedObject, mbd);    } catch (Throwable ex) {        if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {            throw (BeanCreationException) ex;        } else {            throw new BeanCreationException(                    mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);        }    }    // 【7】 循环依赖处理    if (earlySingletonExposure) {        // 获取 earlySingletonReference        Object earlySingletonReference = getSingleton(beanName, false);        // 只有在存在循环依赖的情况下，earlySingletonReference 才不会为空        if (earlySingletonReference != null) {            // 如果 exposedObject 没有在初始化方法中被改变，也就是没有被增强            if (exposedObject == bean) {                exposedObject = earlySingletonReference;            // 处理依赖            } else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) {                String[] dependentBeans = getDependentBeans(beanName);                Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;&gt;(dependentBeans.length);                for (String dependentBean : dependentBeans) {                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {                        actualDependentBeans.add(dependentBean);                    }                }                if (!actualDependentBeans.isEmpty()) {                    throw new BeanCurrentlyInCreationException(beanName,                            &quot;Bean with name &#39;&quot; + beanName + &quot;&#39; has been injected into other beans [&quot; +                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +                            &quot;] in its raw version as part of a circular reference, but has eventually been &quot; +                            &quot;wrapped. This means that said other beans do not use the final version of the &quot; +                            &quot;bean. This is often the result of over-eager type matching - consider using &quot; +                            &quot;&#39;getBeanNamesOfType&#39; with the &#39;allowEagerInit&#39; flag turned off, for example.&quot;);                }            }        }    }    // 【8】 注册 bean    try {        registerDisposableBeanIfNecessary(beanName, bean, mbd);    } catch (BeanDefinitionValidationException ex) {        throw new BeanCreationException(                mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);    }    return exposedObject;}</code></pre><p>这块是最核心的创建方法，很复杂。<br><font size=2></p><ul><li>【1】处，如果是单例模式清除掉缓存。</li><li>【2】处，到调用<code>#createBeanInstance(...)</code>方法，实例化 Bean。只要是将 BeanDefinition 转换为<code>org.springframework.beans.BeanWrapper</code>对象。<ul><li>详见【【源码】IoC加载Bean之创建 Bean（二）】和【【源码】IoC加载Bean之创建 Bean（三）】</li></ul></li><li>【3】处，MergedBeanDefinitionPostProcessor 的应用。</li><li>【4】处，单例模式的循环依赖处理。<ul><li>详见【【源码】IoC加载Bean之创建 Bean（五）】</li></ul></li><li>【5】处，调用<code>#populateBean(...)</code>方法，进行属性填充。将所有属性填充至 Bean 的实例中。<ul><li>详见【【源码】IoC加载Bean之创建 Bean（四）】</li></ul></li><li>【6】处，调用<code>#initializeBean(...)</code>方法，初始化 Bean。<ul><li>详见【【源码】IoC加载Bean之创建 Bean（六）】</li></ul></li><li>【7】处，依赖检查。</li><li>【8】处，注册 DisposableBean。</li></ul></font><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p><code>#doCreateBean(...)</code>方法，完成 Bean 的创建和初始化工作，内容很多。这里就是简单的列出思路，下文开始，将对该方法进行拆分分析，从以下几个方面入手：<br><font size=2></p><ul><li><code>#createBeanInstance(...)</code>方法，实例化 Bean。</li><li>循环依赖的处理。</li><li><code>#populateBean(...)</code>方法，进行属性填充。</li><li><code>#initializeBean(...)</code>方法，初始化 Bean。</li></ul></font></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析各scope的Bean创建</title>
      <link href="/2019/12/25/%E5%88%86%E6%9E%90%E5%90%84scope%E7%9A%84Bean%E5%88%9B%E5%BB%BA/"/>
      <url>/2019/12/25/%E5%88%86%E6%9E%90%E5%90%84scope%E7%9A%84Bean%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>在 Spring 中存在着不同的 scope，默认是 singleton，还有 property、request 等其他的 scope。他们的初始化步骤各不相同。</p><h1 id="1-singleton"><a href="#1-singleton" class="headerlink" title="1 singleton"></a>1 singleton</h1><p>Spring 的 scope 默认为 singleton，其初始化代码如下：</p><pre><code>// AbstractBeanFactory.javaif (mbd.isSingleton()) { // 单例模式    sharedInstance = getSingleton(beanName, () -&gt; {        try {            return createBean(beanName, mbd, args);        }        catch (BeansException ex) {            // 显式从单例缓存中删除 Bean 实例            // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它。 TODO 芋艿            destroySingleton(beanName);            throw ex;        }    });    // &lt;x&gt;    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);}</code></pre><p>在上文中已经分析了从缓存中获取单例默认的 Bean。但如果<strong>缓存中不存在呢</strong>？则需要从头开始加载 Bean，这个过程由<code>#getSingleton(...)</code>方法实现。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.javapublic Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {    Assert.notNull(beanName, &quot;Bean name must not be null&quot;);    // 全局加锁    synchronized (this.singletonObjects) {        // 【1】 从缓存中检查一遍        // 因为 singleton 模式其实就是复用已经创建的 bean 所以这步骤必须检查        Object singletonObject = this.singletonObjects.get(beanName);        //  为空，开始加载过程        if (singletonObject == null) {            if (this.singletonsCurrentlyInDestruction) {                throw new BeanCreationNotAllowedException(beanName,                        &quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot; +                        &quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;);            }            if (logger.isDebugEnabled()) {                logger.debug(&quot;Creating shared instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);            }            // 【2】 加载前置处理            beforeSingletonCreation(beanName);            boolean newSingleton = false;            boolean recordSuppressedExceptions = (this.suppressedExceptions == null);            if (recordSuppressedExceptions) {                this.suppressedExceptions = new LinkedHashSet&lt;&gt;();            }            try {                // 【3】 初始化 bean                // 这个过程其实是调用 createBean() 方法                singletonObject = singletonFactory.getObject();                newSingleton = true;            } catch (IllegalStateException ex) {                singletonObject = this.singletonObjects.get(beanName);                if (singletonObject == null) {                    throw ex;                }            } catch (BeanCreationException ex) {                if (recordSuppressedExceptions) {                    for (Exception suppressedException : this.suppressedExceptions) {                        ex.addRelatedCause(suppressedException);                    }                }                throw ex;            } finally {                if (recordSuppressedExceptions) {                    this.suppressedExceptions = null;                }                // 【4】 后置处理                afterSingletonCreation(beanName);            }            // 【5】 加入缓存中            if (newSingleton) {                addSingleton(beanName, singletonObject);            }        }        return singletonObject;    }</code></pre><p>其实这个过程并没有创建 Bean 对象，仅仅做了一部分的准备和预处理步骤。真正获取单例 Bean 的方法，由【3】处的<code>singletonFactory.getObject()</code>方法实现，而<code>singletonFactory</code>参数由回调方法产生。</p><font size=2><ul><li>【1】处，再次检查缓存中是否已经加载过，如果已经加载了则直接返回，否则开始加载过程。</li><li>【2】处，调用<code>#beforeSingletonCreation(...)</code>方法，记录加载单例 Bean 之前的加载状态，即前置处理。</li><li>【3】处，调用参数传递的 ObjectFactory 的<code>#getObject()</code>方法实例化。<strong>极其重要，后续详讲</strong></li><li>【4】处，调用<code>#afterSingletonCreation(...)</code>方法，进行加载单例后的后置处理。</li><li>【5】处，调用<code>#addSingleton(...)</code>方法，将结果记录到缓存中，同时删除加载 Bean 过程中所记录的一切服务状态。详见【1.1 addSingleton】</li></ul></font><h2 id="1-1-addSingleton"><a href="#1-1-addSingleton" class="headerlink" title="1.1 addSingleton"></a>1.1 addSingleton</h2><pre><code>// DefaultSingletonBeanRegistry.java/** * 存放的是单例 bean 的映射。 * * 对应关系为 bean name --&gt; bean instance */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);/** * 存放的是【早期】的单例 bean 的映射。 * * 对应关系也是 bean name --&gt; bean instance。 * * 它与 {@link #singletonObjects} 的区别区别在，于 earlySingletonObjects 中存放的 bean 不一定是完整的。 * * 从 {@link #getSingleton(String)} 方法中，中我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了， * 所以当在 bean 的创建过程中就可以通过 getBean() 方法获取。 * 这个 Map 也是解决【循环依赖】的关键所在。 **/private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);/** * 存放的是 ObjectFactory 的映射，可以理解为创建单例 bean 的 factory 。 * * 对应关系是 bean name --&gt; ObjectFactory */private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);/** Set of registered singletons, containing the bean names in registration order. */private final Set&lt;String&gt; registeredSingletons = new LinkedHashSet&lt;&gt;(256);protected void addSingleton(String beanName, Object singletonObject) {    synchronized (this.singletonObjects) {        this.singletonObjects.put(beanName, singletonObject);        this.singletonFactories.remove(beanName);        this.earlySingletonObjects.remove(beanName);        this.registeredSingletons.add(beanName);    }}</code></pre><font size=2><p>一个 put、一个 add、两个 remove 操作。</p><ul><li>【put】<code>singletonObjects</code>属性，单例 Bean 的缓存。</li><li>【remove】<code>singletonFactories</code>属性，单例 BeanFactory 的缓存。</li><li>【remove】<code>earlySingletonObjects</code>属性，早期创建的单例 Bean 的缓存。</li><li>【add】<code>registeredSingletons</code>属性，已经注册的单例缓存。</li></ul></font><h1 id="2-原型模式"><a href="#2-原型模式" class="headerlink" title="2 原型模式"></a>2 原型模式</h1><pre><code>// AbstractBeanFactory.javaelse if (mbd.isPrototype()) {    Object prototypeInstance = null;    try {       // 【1】 加载前置处理        beforePrototypeCreation(beanName);        // 【2】 创建 Bean 对象        prototypeInstance = createBean(beanName, mbd, args);    } finally {       // 【3】 加载后置处理        afterPrototypeCreation(beanName);    }    // 【4】 从 Bean 实例中获取对象    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);}</code></pre><p>原型模式的初始化比较简单，直接创建一个新的 Bean 实例就可以，过程如下：</p><font size=2><ul><li>【1】处，调用<code>#beforePrototypeCreation(...)</code>方法，记录加载原型模式之前的加载状态，即前置处理。详见【2.1 beforePrototypeCreation】</li><li>【2】处，调用<code>#createBean(...)</code>方法，创建一个 Bean 实例对象。<strong>超级重要！后续详讲</strong></li><li>【3】处，调用<code>#afterPrototypeCreation(...)</code>方法，进行加载原型模式之后的加载状态，即后置处理。详见【2.3 afterPrototypeCreation】</li><li>【4】处，加载了单例 Bean 后，调用<code>#getObjectForBeanInstance(...)</code>方法，从 Bean 实例中获取对象。该方法已经在【【源码】IoC加载Bean之从单例缓存中获取单例 Bean】详细说明。</font></li></ul><h2 id="2-1-beforePrototypeCreation】"><a href="#2-1-beforePrototypeCreation】" class="headerlink" title="2.1 beforePrototypeCreation】"></a>2.1 beforePrototypeCreation】</h2><pre><code>// AbstractBeanFactory.javaprivate final ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation =        new NamedThreadLocal&lt;&gt;(&quot;Prototype beans currently in creation&quot;);protected void beforePrototypeCreation(String beanName) {    Object curVal = this.prototypesCurrentlyInCreation.get();    if (curVal == null) { // String        this.prototypesCurrentlyInCreation.set(beanName);    } else if (curVal instanceof String) { // String =&gt; Set        Set&lt;String&gt; beanNameSet = new HashSet&lt;&gt;(2);        beanNameSet.add((String) curVal);        beanNameSet.add(beanName);        this.prototypesCurrentlyInCreation.set(beanNameSet);    } else { // Set        Set&lt;String&gt; beanNameSet = (Set&lt;String&gt;) curVal;        beanNameSet.add(beanName);    }}</code></pre><h2 id="2-2-afterSingletonCreation"><a href="#2-2-afterSingletonCreation" class="headerlink" title="2.2 afterSingletonCreation"></a>2.2 afterSingletonCreation</h2><pre><code>// AbstractBeanFactory.javaprotected void afterPrototypeCreation(String beanName) {    Object curVal = this.prototypesCurrentlyInCreation.get();    if (curVal instanceof String) { // String =&gt; null        this.prototypesCurrentlyInCreation.remove();    } else if (curVal instanceof Set) { // Set        Set&lt;String&gt; beanNameSet = (Set&lt;String&gt;) curVal;        beanNameSet.remove(beanName);        if (beanNameSet.isEmpty()) { // Set =&gt; null            this.prototypesCurrentlyInCreation.remove();        }    }}</code></pre><h1 id="3-其他作用域"><a href="#3-其他作用域" class="headerlink" title="3 其他作用域"></a>3 其他作用域</h1><pre><code>// AbstractBeanFactory.javaelse {    // 获得 scopeName 对应的 Scope 对象    String scopeName = mbd.getScope();    final Scope scope = this.scopes.get(scopeName);    if (scope == null) {        throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);    }    try {        // 从指定的 scope 下创建 bean        Object scopedInstance = scope.get(beanName, () -&gt; {            // 加载前置处理            beforePrototypeCreation(beanName);            try {                // 创建 Bean 对象                return createBean(beanName, mbd, args);            } finally {                // 加载后缀处理                afterPrototypeCreation(beanName);            }        });        // 从 Bean 实例中获取对象        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);    } catch (IllegalStateException ex) {        throw new BeanCreationException(beanName,                &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +                &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,                ex);    }}</code></pre><p><strong>核心路程和原型模式一样</strong>，只不过获取 Bean 的实例由<code>Scope#get(...)</code>方法来实现。代码如下：</p><pre><code>// SimpleThreadScope.javaprivate final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadScope =    new NamedThreadLocal&lt;Map&lt;String, Object&gt;&gt;(&quot;SimpleThreadScope&quot;) {        @Override        protected Map&lt;String, Object&gt; initialValue() {            return new HashMap&lt;&gt;();        }    };@Overridepublic Object get(String name, ObjectFactory&lt;?&gt; objectFactory) {    // 获取 scope 缓存    Map&lt;String, Object&gt; scope = this.threadScope.get();    Object scopedObject = scope.get(name);    if (scopedObject == null) {        scopedObject = objectFactory.getObject();        // 加入缓存        scope.put(name, scopedObject);    }    return scopedObject;}</code></pre><p><code>org.springframework.beans.factory.config.Scope</code>接口，有多种不同的实现，对应不同的 scope。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>对于上面三个模块，其中最重要的<strong>有两个方法</strong>：</p><font size=2><ul><li>一个是<code>#createBean(...)</code>方法。<ul><li>后续详细说明。</li></ul></li><li>一个是<code>#getObjectForBeanInstance()</code>方法。<ul><li>在前面的【【源码】IoC加载Bean之从单例缓存中获取单例 Bean】已经详细说明。</li></ul></li></ul><p>这两个方法，在上面三个模块中<strong>都有调用</strong>。</p></font><blockquote><p>getObjectForBeanInstance 方法主要是验证我们得到的 Bean 的正确性。其实就是检测当前的 Bean 是否是 FactoryBean 的类型。<br>如果是，name需要调用该 Bean 对应的 FactoryBean 实例的<code>#getObject()</code>方法，作为返回值。<br>无论是从缓存中获取的 Bean 还是通过不同的 scope 策略加载的 Bean 都只是最原始的 Bean 状态，并不一定是我们需要的 Bean。<br>举个例子，加入我们需要工厂 Bean 进行处理。那么这里得到的其实是工厂 Bean 的初始状态，但是我们真正需要的是工厂 Bean 定义的<code>factiry-method</code>方法返回的 Bean，而<code>getObjectForBeanInstance</code>方法，就是完成这个工作的。</p></blockquote></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>parentBeanFactory与依赖处理</title>
      <link href="/2019/12/25/parentBeanFactory%E4%B8%8E%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/"/>
      <url>/2019/12/25/parentBeanFactory%E4%B8%8E%E4%BE%9D%E8%B5%96%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<font size=3></br><p>如果从单例缓存中没有获取到单例 Bean 对象，则说明两种情况：</p><font size=2><ul><li><ol><li>该 Bean 的 scope 不是 singleton。</li></ol></li><li><ol start="2"><li>该 Bean 的 scope 是singleton，但是没有初始化完成。</li></ol></li></ul></font><p>针对这两种情况，Spring 通过统一加载并完成初始化来处理，分为两个部分：</p><font size=2><ul><li>第一部分，主要是一些检测 parentFactory 以及依赖处理。</li><li>第二部分，是各个 scope 的初始化动作。</li></ul></font><p>代码如下：</p><pre><code>// AbstractBeanFactory.java//protected &lt;T&gt; T doGetBean(final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly)// ... 省略很多代码// 【2】 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常。if (isPrototypeCurrentlyInCreation(beanName)) {    throw new BeanCurrentlyInCreationException(beanName);}// 【4】 如果容器中没有找到，则从父类容器中加载// Check if bean definition exists in this factory.BeanFactory parentBeanFactory = getParentBeanFactory();if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {    // Not found -&gt; check parent.    String nameToLookup = originalBeanName(name);    if (parentBeanFactory instanceof AbstractBeanFactory) {        return ((AbstractBeanFactory) parentBeanFactory).doGetBean(                nameToLookup, requiredType, args, typeCheckOnly);    } else if (args != null) {        // Delegation to parent with explicit args.        return (T) parentBeanFactory.getBean(nameToLookup, args);    } else if (requiredType != null) {        // No args -&gt; delegate to standard getBean method.        return parentBeanFactory.getBean(nameToLookup, requiredType);    } else {        return (T) parentBeanFactory.getBean(nameToLookup);    }}// 【5】 如果不是仅仅做类型检查则是创建bean，这里需要记录if (!typeCheckOnly) {    markBeanAsCreated(beanName);}try {    // 【6】 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象    final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);    // 检查给定的合并的 BeanDefinition    checkMergedBeanDefinition(mbd, beanName, args);    // 【7】 处理所依赖的 bean    String[] dependsOn = mbd.getDependsOn();    if (dependsOn != null) {        for (String dep : dependsOn) {            // 若给定的依赖 bean 已经注册为依赖给定的 bean            // 循环依赖的情况            if (isDependent(beanName, dep)) {                throw new BeanCreationException(mbd.getResourceDescription(), beanName,                        &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);            }            // 缓存依赖调用            registerDependentBean(dep, beanName);            try {                getBean(dep);            } catch (NoSuchBeanDefinitionException ex) {                throw new BeanCreationException(mbd.getResourceDescription(), beanName,                        &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);            }        }    }}// ... 省略很多代码</code></pre><p>这块代码主要处理以下几个部分：</p><font size=2><ul><li>【3】处，检测。若当前的 Bean 在创建，则抛出 BeanCurrentlyInCreationException 异常。详见【1.检测】</li><li>【4】处，如果 BeanDefinitionMap 中不存在 beanName 和 BeanDefinition（即在 Spring bean 初始化过程中没有加载），则尝试从 parentBeanFactory 中加载。详见【2.检查父类 BeanFactory】</li><li>【5】处，判断是否为类型检查。详见【3.类型检查】</li><li>【6】处，从<code>mergedBeanDefinitions</code>中获取<code>beanName</code>对应的 RootBeanDefinition 对象。如果这个 BeanDefinition 是子 Bean 的话，则会合并父类的相关属性。详见【4.获取 RootBeanDefinition】</li><li>【7】处，处理依赖。详见【5.处理依赖】</li></ul></font><h1 id="1-检查"><a href="#1-检查" class="headerlink" title="1 检查"></a>1 检查</h1><p>在前面提过，Spring 之解决单例模式下的循环依赖，对于原型模式的循环依赖则抛出 BeanCurrentlyInCreationException 异常，所以首先检查该 beanName 是否处于原型模式下的循环依赖。代码如下：</p><pre><code>// AbstractBeanFactory.javaif (isPrototypeCurrentlyInCreation(beanName)) {    throw new BeanCurrentlyInCreationException(beanName);}</code></pre><p>调用<code>#isPrototypeCurrentlyInCreation(...)</code>方法，判断当前的 Bean 是否正在创建。代码如下：</p><pre><code>// AbstractBeanFactory.javaprotected boolean isPrototypeCurrentlyInCreation(String beanName) {    Object curVal = this.prototypesCurrentlyInCreation.get();    return (curVal != null &amp;&amp;            (curVal.equals(beanName)  // 相等                    || (curVal instanceof Set &amp;&amp; ((Set&lt;?&gt;) curVal).contains(beanName)))); // 包含}</code></pre><p>其实检测逻辑和单例模式一样，一个集合存放着正在创建的 Bean，从该集合中进行判断即可，只不过单例模式的集合是 Set，而原型模式的则是 ThreadLocal。<code>prototypesCurrentlyInCreation</code>定义如下：</p><pre><code>// AbstractBeanFactory.java/** Names of beans that are currently in creation. */private final ThreadLocal&lt;Object&gt; prototypesCurrentlyInCreation =        new NamedThreadLocal&lt;&gt;(&quot;Prototype beans currently in creation&quot;);</code></pre><h1 id="2-检查父类-BeanFactory"><a href="#2-检查父类-BeanFactory" class="headerlink" title="2 检查父类 BeanFactory"></a>2 检查父类 BeanFactory</h1><p>若<code>#containsBeanDefinition(...)</code>方法中不存在<code>beanName</code>相对应的 BeanDefinition 对象时，则从<code>parentBeanFactory</code>中获取，代码如下：</p><pre><code>// AbstractBeanFactory.java// 获取 parentBeanFactoryBeanFactory parentBeanFactory = getParentBeanFactory();// parentBeanFactory 不为空且 beanDefinitionMap 中不存该 name 的 BeanDefinitionif (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {    // 确定原始 beanName    String nameToLookup = originalBeanName(name);    // 若为 AbstractBeanFactory 类型，委托父类处理    if (parentBeanFactory instanceof AbstractBeanFactory) {        return ((AbstractBeanFactory) parentBeanFactory).doGetBean(                nameToLookup, requiredType, args, typeCheckOnly);    } else if (args != null) {        // 委托给构造函数 getBean() 处理        return (T) parentBeanFactory.getBean(nameToLookup, args);    } else {        // 没有 args，委托给标准的 getBean() 处理        return parentBeanFactory.getBean(nameToLookup, requiredType);    }}</code></pre><p>整个过程都是委托<code>parentBeanFactory</code>的<code>#getBean(...)</code>方法来进行处理，只不过在获取之前对<code>beanName</code>进行简单的处理，主要是想获取原始的 <strong>beanName</strong>。代码如下：</p><pre><code>// AbstractBeanFactory.javaprotected String originalBeanName(String name) {    String beanName = transformedBeanName(name); // 【1】    if (name.startsWith(FACTORY_BEAN_PREFIX)) { // 【2】        beanName = FACTORY_BEAN_PREFIX + beanName;    }    return beanName;}</code></pre><font size=2><ul><li>【1】处，<code>#transformedBeanName(...)</code>方法，是对<code>name</code>进行转换的，获取真正的 beanName。</li><li>【2】处，如果<code>name</code>是以<code>&amp;</code>开发，也就是 <strong>FactoryBean</strong> 对象，因为在<code>#transformedBeanName(...)</code>中将<code>&amp;</code>去掉了，在这里补上。</li></ul></font><h1 id="3-类型检查"><a href="#3-类型检查" class="headerlink" title="3 类型检查"></a>3 类型检查</h1><p>方法参数<code>typeCheckOnly</code>，是用来判断调用<code>#getBean(...)</code>方法时，表示是否<strong>仅仅</strong>进行类型检查获取 Bean 对象。如果不是仅仅做类型检查，而是创建 Bean 对象，则需要调用<code>#markBeanAsCreated(...)</code> 方法，进行记录。代码如下：</p><pre><code>// AbstractBeanFactory.java/** *  已创建 Bean 的名字集合 */private final Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256));protected void markBeanAsCreated(String beanName) {    // 没有创建    if (!this.alreadyCreated.contains(beanName)) {        // 加上全局锁        synchronized (this.mergedBeanDefinitions) {            // 再次检查一次：DCL 双检查模式            if (!this.alreadyCreated.contains(beanName)) {                // 从 mergedBeanDefinitions 中删除 beanName，并在下次访问时重新创建它。                clearMergedBeanDefinition(beanName);                // 添加到已创建 bean 集合中                this.alreadyCreated.add(beanName);            }        }    }}protected void clearMergedBeanDefinition(String beanName) {    this.mergedBeanDefinitions.remove(beanName);}</code></pre><h1 id="4-获取-RootBeanDefinition"><a href="#4-获取-RootBeanDefinition" class="headerlink" title="4 获取 RootBeanDefinition"></a>4 获取 RootBeanDefinition</h1><pre><code>// AbstractBeanFactory.java// 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);// 检查给定的合并的 BeanDefinitioncheckMergedBeanDefinition(mbd, beanName, args);</code></pre><p>调用<code>#getMergedLocalBeanDefinition(...)</code>方法，获取相对应的 BeanDefinition 对象，代码如下：</p><pre><code>// AbstractBeanFactory.java/** Map from bean name to merged RootBeanDefinition. */private final Map&lt;String, RootBeanDefinition&gt; mergedBeanDefinitions = new ConcurrentHashMap&lt;&gt;(256);protected RootBeanDefinition getMergedLocalBeanDefinition(String beanName) throws BeansException {    // 快速从缓存中获取，如果不为空，则直接返回    RootBeanDefinition mbd = this.mergedBeanDefinitions.get(beanName);    if (mbd != null) {        return mbd;    }    // 获取 RootBeanDefinition，    // 如果返回的 BeanDefinition 是子类 bean 的话，则合并父类相关属性    return getMergedBeanDefinition(beanName, getBeanDefinition(beanName));}</code></pre><font size=2><ul><li>首先，直接从<code>mergedBeanDefinitions</code>缓存中获取相应的 RootBeanDefinition 对象，如果存在则直接返回。</li><li>否则，调用<code>#getMergedBeanDefinition(...)</code>方法，获取 RootBeanDefinition 对象。若获取的 BeanDefinition 为<strong>子</strong> BeanDefinition，则需要合并父类的相关属性。</li></ul></font><p>调用<code>#checkMergedBeanDefinition()</code>方法，检查给定的合并的 BeanDefinition 对象。代码如下：</p><pre><code>// AbstractBeanFactory.javaprotected void checkMergedBeanDefinition(RootBeanDefinition mbd, String beanName, @Nullable Object[] args)        throws BeanDefinitionStoreException {    if (mbd.isAbstract()) {        throw new BeanIsAbstractException(beanName);    }}</code></pre><h1 id="5-处理依赖"><a href="#5-处理依赖" class="headerlink" title="5 处理依赖"></a>5 处理依赖</h1><p>如果一个 Bean 有依赖的 Bean 的话，那么在初始化该 Bean 时需要先初始化它的依赖。代码如下：</p><pre><code>// AbstractBeanFactory.java// 处理所依赖的 beanString[] dependsOn = mbd.getDependsOn();if (dependsOn != null) {    for (String dep : dependsOn) {        // 【1】 若给定的依赖 bean 已经注册为依赖给定的 bean        // 即循环依赖的情况，抛出 BeanCreationException 异常        if (isDependent(beanName, dep)) {            throw new BeanCreationException(mbd.getResourceDescription(), beanName,                    &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);        }        // 【2】 缓存依赖调用 TODO 芋艿        registerDependentBean(dep, beanName);        try {            // 【3】 递归处理依赖 Bean            getBean(dep);        } catch (NoSuchBeanDefinitionException ex) {            throw new BeanCreationException(mbd.getResourceDescription(), beanName,                    &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);        }    }}</code></pre><p>通过迭代的方法依次对依赖 Bean 进行检测、校验。如果通过，则调用<code>#getBean(...)</code>方法，实例化<strong>依赖</strong>的 Bean 对象。</p><h2 id="5-1-isDependent"><a href="#5-1-isDependent" class="headerlink" title="5.1 isDependent"></a>5.1 isDependent</h2><p>【1】处，调用的<code>#isDependent(...)</code>方法，是校验该依赖是否已经注册给当前 Bean。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.java/** * 保存的是依赖 beanName 之间的映射关系：beanName - &gt; 依赖 beanName 的集合 */private final Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = new ConcurrentHashMap&lt;&gt;(64);protected boolean isDependent(String beanName, String dependentBeanName) {    synchronized (this.dependentBeanMap) {        return isDependent(beanName, dependentBeanName, null);    }}</code></pre><font size=2><ul><li><code>dependentBeanMap</code>对象保存的是依赖<code>beanName</code>之间的映射关系： beanName -&gt; 依赖 beanName 的集合。</li><li>同步加锁<code>dependentBeanMap</code>对象，然后调用<code>#isDependent(...)</code>方法，进行校验。代码如下：</li></ul><pre><code>// DefaultSingletonBeanRegistry.javaprivate boolean isDependent(String beanName, String dependentBeanName, @Nullable Set&lt;String&gt; alreadySeen) {    // alreadySeen 已经检测的依赖 bean    if (alreadySeen != null &amp;&amp; alreadySeen.contains(beanName)) {        return false;    }    // 获取原始 beanName    String canonicalName = canonicalName(beanName);    // 获取当前 beanName 的依赖集合    Set&lt;String&gt; dependentBeans = this.dependentBeanMap.get(canonicalName);    if (dependentBeans == null) {        return false;    }    // 存在，则证明存在已经注册的依赖    if (dependentBeans.contains(dependentBeanName)) {        return true;    }    // 递归检测依赖    for (String transitiveDependency : dependentBeans) {        if (alreadySeen == null) {            alreadySeen = new HashSet&lt;&gt;();        }        // 添加到 alreadySeen 中        alreadySeen.add(beanName);        // 递推        if (isDependent(transitiveDependency, dependentBeanName, alreadySeen)) {            return true;        }    }    return false;}</code></pre></font><h2 id="5-2-registerDependentBean"><a href="#5-2-registerDependentBean" class="headerlink" title="5.2 registerDependentBean"></a>5.2 registerDependentBean</h2><p>【2】处，如果校验成功，则调用<code>#registerDependentBean(...)</code>方法，对该依赖进行注册，便于在销毁 Bean 之前对其进行销毁。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.java/** * 保存的是依赖 beanName 之间的映射关系：beanName - &gt; 依赖 beanName 的集合 */private final Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = new ConcurrentHashMap&lt;&gt;(64);/** * 保存的是依赖 beanName 之间的映射关系：依赖 beanName - &gt; beanName 的集合 */private final Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap = new ConcurrentHashMap&lt;&gt;(64);public void registerDependentBean(String beanName, String dependentBeanName) {    // 获取 beanName    String canonicalName = canonicalName(beanName);    // 添加 &lt;canonicalName, &lt;dependentBeanName&gt;&gt; 到 dependentBeanMap 中    synchronized (this.dependentBeanMap) {        Set&lt;String&gt; dependentBeans =                this.dependentBeanMap.computeIfAbsent(canonicalName, k -&gt; new LinkedHashSet&lt;&gt;(8));        if (!dependentBeans.add(dependentBeanName)) {            return;        }    }    // 添加 &lt;dependentBeanName, &lt;canonicalName&gt;&gt; 到 dependenciesForBeanMap 中    synchronized (this.dependenciesForBeanMap) {        Set&lt;String&gt; dependenciesForBean =                this.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&gt; new LinkedHashSet&lt;&gt;(8));        dependenciesForBean.add(canonicalName);    }}</code></pre><p>其实就是讲该映射关系保存到两个集合中：<code>dependentBeanMap</code>、<code>dependenciesForBeanMap</code>。</p><h2 id="5-3-getBEAN"><a href="#5-3-getBEAN" class="headerlink" title="5.3 getBEAN"></a>5.3 getBEAN</h2><p>【3】处，最后调用<code>#getBean(...)</code>方法，实例化依赖的 Bean 对象。</p><h1 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h1><p>至此，加载 bean 的第二个部分也分析完毕了。接下来进行：各大作用域 bean 的处理。</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从单例缓存中获取单例 Bean</title>
      <link href="/2019/12/24/%E4%BB%8E%E5%8D%95%E4%BE%8B%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B-Bean/"/>
      <url>/2019/12/24/%E4%BB%8E%E5%8D%95%E4%BE%8B%E7%BC%93%E5%AD%98%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%8D%95%E4%BE%8B-Bean/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>从这篇开始我们开始加载 Bean 的第一个步骤，从缓存中获取 Bean。代码如下：</p><pre><code>// AbstractBeanFactory.java// 从缓存中或者实例工厂中获取 Bean 对象// Eagerly check singleton cache for manually registered singletons.Object sharedInstance = getSingleton(beanName);if (sharedInstance != null &amp;&amp; args == null) {    if (logger.isTraceEnabled()) {        if (isSingletonCurrentlyInCreation(beanName)) {            logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +                    &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);        } else {            logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);        }    }    // 完成 FactoryBean 的相关处理，并用来获取 FactoryBean 的处理结果    bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);}</code></pre><p>调用<code>#getSingleton(String beanName)</code>方法，从缓存中获取 Bean。</p><h1 id="1-getSingleTon方法"><a href="#1-getSingleTon方法" class="headerlink" title="1 getSingleTon方法"></a>1 getSingleTon方法</h1><p>在上一篇提到过，Spring 对单例模式的 Bean 只会创建一次，后续如果在有操作，则直接从单例缓存中获取，该过程就体现在<code>#getSingleton(String beanName)</code>方法中。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.java@Override@Nullablepublic Object getSingleton(String beanName) {    return getSingleton(beanName, true);}@Nullableprotected Object getSingleton(String beanName, boolean allowEarlyReference) {    // 从单例缓冲中加载 bean    Object singletonObject = this.singletonObjects.get(beanName);    // 缓存中的 bean 为空，且当前 bean 正在创建    if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) {        // 加锁        synchronized (this.singletonObjects) {            // 从 earlySingletonObjects 获取            singletonObject = this.earlySingletonObjects.get(beanName);            // earlySingletonObjects 中没有，且允许提前创建            if (singletonObject == null &amp;&amp; allowEarlyReference) {                // 从 singletonFactories 中获取对应的 ObjectFactory                ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName);                if (singletonFactory != null) {                    // 获得 bean                    singletonObject = singletonFactory.getObject();                    // 添加 bean 到 earlySingletonObjects 中                    this.earlySingletonObjects.put(beanName, singletonObject);                    // 从 singletonFactories 中移除对应的 ObjectFactory                    this.singletonFactories.remove(beanName);                }            }        }    }    return singletonObject;}</code></pre><p>这块的代码非常简单，过程如下：</p><font size=2><ul><li><ol><li>从<code>singletonObjects</code>中，获取 Bean 对象。</li></ol></li><li><ol start="2"><li>若为空且当前 Bean 正在创建中，则从<code>earlySingletonObjects</code>中获取 Bean 对象。</li></ol></li><li><ol start="3"><li>若为空且允许提前创建，则从<code>singletonFactories</code>中获取相应的 ObjectFactory 对象。若不为空，则调用其<code>ObjectFactory#getObject(String name)</code>方法，创建 Bean 对象，然后将其加入到<code>earlySingletonObjects</code>，然后从<code>singletonFactories</code>移除。</li></ol></li><li>总体逻辑，就是根据<code>beanName</code>一次检测这三个Map，若为空，从下一个，否则返回。这三个Map都有各自的功能，代码如下：</li></ul><pre><code>// DefaultSingletonBeanRegistry.java/** * 存放的是单例 bean 的映射。 * 对应关系为 bean name --&gt; bean instance */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);/** * 存放的是 ObjectFactory，可以理解为创建单例 bean 的 factory 。 * 对应关系是 bean name --&gt; ObjectFactory **/private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);/** * 存放的是早期的 bean，对应关系也是 bean name --&gt; bean instance。 * 它与 {@link #singletonFactories} 区别在于 earlySingletonObjects 中存放的 bean 不一定是完整。 * * 从 {@link #getSingleton(String)} 方法中，我们可以了解，bean 在创建过程中就已经加入到 earlySingletonObjects 中了。 * 所以当在 bean 的创建过程中，就可以通过 getBean() 方法获取。 * 这个 Map 也是【循环依赖】的关键所在。 */private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);</code></pre></font><h2 id="1-1-isSingletonCurrentlyInCreation"><a href="#1-1-isSingletonCurrentlyInCreation" class="headerlink" title="1.1 isSingletonCurrentlyInCreation"></a>1.1 isSingletonCurrentlyInCreation</h2><p>在上面代码中，有一个非常重要的检测方法<code>#isSingletonCurrentlyInCreation(String beanName)</code>方法，该方法用于判断该<code>beanName</code>对应的 Bean <strong>是否在创建过程中</strong>，注意这个过程讲的是整个工厂中。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.java/** * Names of beans that are currently in creation. * * 正在创建中的单例 Bean 的名字的集合 */private final Set&lt;String&gt; singletonsCurrentlyInCreation =        Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));</code></pre><p>从这段代码中，我们可以推测，在 Bean 创建过程中会将其加入到<code>singletonsCurrentlyInCreation</code>集合中，具体是什么时候加的，后续再详细说明。</p><h1 id="2-getObjectForBeanInstance"><a href="#2-getObjectForBeanInstance" class="headerlink" title="2 getObjectForBeanInstance"></a>2 getObjectForBeanInstance</h1><p>到这里从缓存中获取 Bean 的过程已经分析完毕了，我们在看开篇的代码段，从缓存中获取 Bean 后，若其不为<code>null</code>且<code>args</code>为空，则会调用<code>#getObjectForBeanInstance(...)</code>方法，进行处理。</p><font size=2><ul><li>为什么会有这一段？因为我们从缓存获取的 Bean 是<strong>最原始</strong>的 Bean，并不定是我们最终想要的 Bean。</li><li>怎么办呢？调用<code>#getObjectForBeanInstance(...)</code>方法，进行处理，该方法的定义为获取给定 Bean 实例的对象，该对象要么是 Bean 实例本身，要么就是 FactoryBean 创建的 Bean 对象。</li></ul></font><p>代码如下：</p><pre><code>// AbstractBeanFactory.javaprotected Object getObjectForBeanInstance(        Object beanInstance, String name, String beanName, @Nullable RootBeanDefinition mbd) {    // 【1】 若为工厂类引用（name 以 &amp; 开头）    if (BeanFactoryUtils.isFactoryDereference(name)) {        // 如果是 NullBean，则直接返回        if (beanInstance instanceof NullBean) {            return beanInstance;        }        // 如果 beanInstance 不是 FactoryBean 类型，则抛出异常        if (!(beanInstance instanceof FactoryBean)) {            throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());        }    }    // 【2】 到这里我们就有了一个 Bean 实例，当然该实例可能是会是是一个正常的 bean 又或者是一个 FactoryBean    // 如果是 FactoryBean，我我们则创建该 Bean    if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) {        return beanInstance;    }    Object object = null;    // 【3】 若 BeanDefinition 为 null，则从缓存中加载 Bean 对象    if (mbd == null) {        object = getCachedObjectForFactoryBean(beanName);    }    // 若 object 依然为空，则可以确认，beanInstance 一定是 FactoryBean 。从而，使用 FactoryBean 获得 Bean 对象    if (object == null) {        // Return bean instance from factory.        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;        // containsBeanDefinition 检测 beanDefinitionMap 中也就是在所有已经加载的类中        // 检测是否定义 beanName        if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) {            // 将存储 XML 配置文件的 GenericBeanDefinition 转换为 RootBeanDefinition，            // 如果指定 BeanName 是子 Bean 的话同时会合并父类的相关属性            mbd = getMergedLocalBeanDefinition(beanName);        }        // 是否是用户定义的，而不是应用程序本身定义的        boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic());        // 核心处理方法，使用 FactoryBean 获得 Bean 对象        object = getObjectFromFactoryBean(factory, beanName, !synthetic);    }    return object;}</code></pre><font size=2><ul><li>【1】处，若<code>name</code>为工厂相关的（也就是包含工厂类的前缀&amp;），且<code>beanInstance</code>为 NullBean 类型直接返回，如果<code>beanInstance</code> 不为 FactoryBean 类型则抛出 BeanIsNotAFactoryException 异常。这里主要是<strong>检验 beanInstance 的正确性</strong>。</li><li>【2】处，如果<code>beanInstance</code>不为 FactoryBean 类型或者<code>name</code>也不是工厂相关的，则直接返回<code>beanInstance</code>这个 Bean 对象。<strong>这里主要是对非 FactoryBean类型处理</strong>。</li><li>【3】处，如果 BeanDefinition 为空，则从<code>factoryBeanObjectCache</code>集合中加载 Bean 对象。如果还是空，则可以断定<code>beanInstance</code>一定是 FactoryBean 类型，则委托<code>#getObjectFromFactoryBean(...)</code>方法，进行处理。<strong>使用 FactoryBean 获得 Bean 对象</strong>。</li></ul></font><h2 id="2-1-getObjectFromFactoryBean"><a href="#2-1-getObjectFromFactoryBean" class="headerlink" title="2.1 getObjectFromFactoryBean"></a>2.1 getObjectFromFactoryBean</h2><p>在上面的代码中可以看出，<code>#getObjectForBeanInstance(...)</code>方法，分成两种情况：</p><font size=2><ul><li>第一种，当该实例对象为<strong>非 FactoryBean 类型</strong>，直接返回给定的 Bean 实例对象<code>beanInstance</code>。</li><li>第二种，当该实例对象为<strong>FactoryBean 类型</strong>，从 FactoryBean 中，获取 Bean 实例对象。</li></ul></font><p>第二种，通过<code>#getObjectFromFactoryBean(...)</code>方法来实现，代码如下：</p><pre><code>// FactoryBeanRegistrySupport.java/** * 缓存 FactoryBean 创建的单例 Bean 对象的映射 * beanName ===&gt; Bean 对象 */private final Map&lt;String, Object&gt; factoryBeanObjectCache = new ConcurrentHashMap&lt;&gt;(16);protected Object getObjectFromFactoryBean(FactoryBean&lt;?&gt; factory, String beanName, boolean shouldPostProcess) {    // 【1】 为单例模式且缓存中存在    if (factory.isSingleton() &amp;&amp; containsSingleton(beanName)) {        synchronized (getSingletonMutex()) { // 【1.1】 单例锁            // 【1.2】 从缓存中获取指定的 factoryBean            Object object = this.factoryBeanObjectCache.get(beanName);            if (object == null) {                // 为空，则从 FactoryBean 中获取对象                object = doGetObjectFromFactoryBean(factory, beanName);                // 从缓存中获取                Object alreadyThere = this.factoryBeanObjectCache.get(beanName);                if (alreadyThere != null) {                    object = alreadyThere;                } else {                    // 【1.3】 需要后续处理                    if (shouldPostProcess) {                        // 若该 Bean 处于创建中，则返回非处理对象，而不是存储它                        if (isSingletonCurrentlyInCreation(beanName)) {                            // Temporarily return non-post-processed object, not storing it yet..                            return object;                        }                        // 单例 Bean 的前置处理                        beforeSingletonCreation(beanName);                        try {                            // 对从 FactoryBean 获取的对象进行后处理                            // 生成的对象将暴露给 bean 引用                            object = postProcessObjectFromFactoryBean(object, beanName);                        } catch (Throwable ex) {                            throw new BeanCreationException(beanName,                                    &quot;Post-processing of FactoryBean&#39;s singleton object failed&quot;, ex);                        } finally {                            // 单例 Bean 的后置处理                            afterSingletonCreation(beanName);                        }                    }                    // 【1.4】 添加到 factoryBeanObjectCache 中，进行缓存                    if (containsSingleton(beanName)) {                        this.factoryBeanObjectCache.put(beanName, object);                    }                }            }            return object;        }    // 【2】    } else {        // 为空，则从 FactoryBean 中获取对象        Object object = doGetObjectFromFactoryBean(factory, beanName);        // 需要后续处理        if (shouldPostProcess) {            try {                // 对从 FactoryBean 获取的对象进行后处理                // 生成的对象将暴露给 bean 引用                object = postProcessObjectFromFactoryBean(object, beanName);            }            catch (Throwable ex) {                throw new BeanCreationException(beanName, &quot;Post-processing of FactoryBean&#39;s object failed&quot;, ex);            }        }        return object;    }}</code></pre><p>主要流程如下：</p><font size=2><ul><li>若为单例且单例 Bean 缓存中存在，则【1】进行后续处理，否则，【2】从 FactoryBean 中获取 Bean 实例对象。</li><li>【1.1】首先，获取锁。我们在前面的代码中看到了大量的锁，锁住的对象都是<code>this.singletonObjects</code>,主要是因为在单例模式中必须要保证全局唯一性。代码如下：</li></ul><pre><code>// DefaultSingletonBeanRegistry.java/** * 存放的是单例 bean 的映射。 * * 对应关系为 bean name --&gt; bean instance */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);public final Object getSingletonMutex() {    return this.singletonObjects;}</code></pre><ul><li>【1.2】然后，从<code>factoryBeanObjectCache</code>缓存中获取实例对象 <code>object</code>，若<code>object</code>为空，则调用<code>#doGetObjectFromFactoryBean(...)</code>方法，从 FactoryBean 获取对象，其实内部就是调用<code>FactoryBean#getObject()</code>方法，代码如下：</li></ul><pre><code>rivate Object doGetObjectFromFactoryBean(final FactoryBean&lt;?&gt; factory, final String beanName)    throws BeanCreationException {    Object object;    try {        // 需要权限验证        if (System.getSecurityManager() != null) {            AccessControlContext acc = getAccessControlContext();            try {                // 【x】 从 FactoryBean 中，获得 Bean 对象                object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);            } catch (PrivilegedActionException pae) {                throw pae.getException();            }        } else {            // 【x】 从 FactoryBean 中，获得 Bean 对象            object = factory.getObject();        }    } catch (FactoryBeanNotInitializedException ex) {        throw new BeanCurrentlyInCreationException(beanName, ex.toString());    } catch (Throwable ex) {        throw new BeanCreationException(beanName, &quot;FactoryBean threw exception on object creation&quot;, ex);    }    // Do not accept a null value for a FactoryBean that&#39;s not fully    // initialized yet: Many FactoryBeans just return null then.    if (object == null) {        if (isSingletonCurrentlyInCreation(beanName)) {            throw new BeanCurrentlyInCreationException(                    beanName, &quot;FactoryBean which is currently in creation returned null from getObject&quot;);        }        object = new NullBean();    }    return object;}</code></pre><ul><li><p>【x】处，可以看到内部调用了<code>FactoryBean#getObject()</code>方法，获取 Bean 对象。</p></li><li><p>【1.3】如果需要后续进行处理，则进一步处理，步骤如下：</p><ul><li>若该 Bean 处理创建中，则返回<strong>非处理的 Bean 对象</strong>，而不是存储它。</li><li>调用<code>#beforeSingletonCreation(...)</code>方法，进行创建之前的处理，默认实现将该 Bean 表示为当前创建的。</li><li>调用<code>#postProcessObjectFromFactoryBean(...)</code>方法，对 FactoryBean 获取的 Bean实例对象进行后置处理，详见【2.3 postProcessObjectFromFactoryBean】</li></ul></li><li><p>【1.4】最后，加入到<code>factoryBeanObjectCache</code>缓存中。</p></li></ul><p><strong>该方法应该就是创建 Bean 实例对象的核心方法之一，这里我们关注三个方法：</strong></p><ul><li><code>#beforeSingletonCreation(...)</code></li><li><code>#afterSingletonCreation(...)</code></li><li><code>#postProcessObjectFromFactoryBean(...)</code></font></li></ul><h2 id="2-2-isSingletonCurrentlyInCreation"><a href="#2-2-isSingletonCurrentlyInCreation" class="headerlink" title="2.2 isSingletonCurrentlyInCreation"></a>2.2 isSingletonCurrentlyInCreation</h2><p>这个方法非常的重要，因为<strong>他们记录着 Bean 的加载状态，是检测当前 Bean 是否处于创建中的关键之处，对解决 Bean 循环依赖起着关键作用</strong>。</p><font size=2><ul><li><code>#beforeSingletonCreation(...)</code>方法，用于添加标志，<strong>当前 Bean 正处于创建中</strong>。</li><li><code>#afterSingletonCreation(...)</code>方法，用于移除标记，<strong>当前 Bean 不处于创建中</strong>。</li></ul><p>其实开篇已经提到了，<code>#isSingletonCurrentlyInCreation(...)</code>方法，是用于检测当前 Bean 是否处于创建之中，代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.java/** * 正在创建中的单例 Bean 的名字的集合 */private final Set&lt;String&gt; singletonsCurrentlyInCreation =        Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16));</code></pre><ul><li>是根据<code>singletonsCurrentlyInCreation</code>集合中是否包含了<code>beanName</code>。</li></ul></font><h3 id="2-2-1-beforeSingletonCreation"><a href="#2-2-1-beforeSingletonCreation" class="headerlink" title="2.2.1 beforeSingletonCreation"></a>2.2.1 beforeSingletonCreation</h3><p>集合的元素，则一定是在<code>#beforeSingletonCreation(...)</code>方法中添加的，代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.javaprotected void beforeSingletonCreation(String beanName) {    if (!this.inCreationCheckExclusions.contains(beanName)            &amp;&amp; !this.singletonsCurrentlyInCreation.add(beanName)) { // 添加        throw new BeanCurrentlyInCreationException(beanName); // 如果添加失败，则抛出 BeanCurrentlyInCreationException 异常。    }}</code></pre><h3 id="2-2-2-afterSingletonCreation"><a href="#2-2-2-afterSingletonCreation" class="headerlink" title="2.2.2 afterSingletonCreation"></a>2.2.2 afterSingletonCreation</h3><p><code>#afterSingletonCreation(...)</code>方法，为移除，则一定就是对<code>singletonsCurrentlyInCreation</code>的 remove。代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.javaprotected void afterSingletonCreation(String beanName) {    if (!this.inCreationCheckExclusions.contains(beanName) &amp;&amp;            !this.singletonsCurrentlyInCreation.remove(beanName)) { // 移除        // 如果移除失败，则抛出 IllegalStateException 异常        throw new IllegalStateException(&quot;Singleton &#39;&quot; + beanName + &quot;&#39; isn&#39;t currently in creation&quot;);    }}</code></pre><h2 id="2-3-postProcessObjectFromFactoryBean"><a href="#2-3-postProcessObjectFromFactoryBean" class="headerlink" title="2.3 postProcessObjectFromFactoryBean"></a>2.3 postProcessObjectFromFactoryBean</h2><p><code>#postProcessObjectFromFactoryBean(...)</code>方法，对从 FactoryBean 处获取的 Bean 实例对象进行后置处理。其默认实现是直接返回 object 对象，不做任何处理，代码如下：</p><pre><code>// DefaultSingletonBeanRegistry.javaprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) throws BeansException {    return object;}</code></pre><h3 id="2-3-1-重写postProcessObjectFromFactoryBean"><a href="#2-3-1-重写postProcessObjectFromFactoryBean" class="headerlink" title="2.3.1 重写postProcessObjectFromFactoryBean"></a>2.3.1 重写postProcessObjectFromFactoryBean</h3><p>当前，子类可以重写，例如应用后置处理。<code>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory</code>抽象类，对其提供了实现，代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.javaprotected Object postProcessObjectFromFactoryBean(Object object, String beanName) {    return applyBeanPostProcessorsAfterInitialization(object, beanName);}</code></pre><p>该方法的定义为：对所有<code>{@code postProcessAfterInitialization}</code>进行回调注册 BeanProcessor，让他们能够后置处理从 FactoryBean 中获取的对象，代码如下：</p><pre><code>// AbstractAutowireCapableBeanFactory.java@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)        throws BeansException {    Object result = existingBean;    // 遍历 BeanPostProcessor    for (BeanPostProcessor processor : getBeanPostProcessors()) {        // 处理        Object current = processor.postProcessAfterInitialization(result, beanName);        // 返回空，则返回 result        if (current == null) {            return result;        }        // 修改 result        result = current;    }    return result;}</code></pre><p>对于后置处理器，这里我们不做过多阐述，后面会专门的博文进行详细介绍，这里我们只需要记住一点：尽可能保证所有 bean 初始化后都会调用注册的<code>BeanPostProcessor#postProcessAfterInitialization(...)</code>方法进行处理，在实际开发过程中大可以针对此特性设计自己的业务逻辑。</p><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>至此，从缓存中获取 Bean 对象过程已经分析完毕了。那么如果单例缓存中没有获得 Bean 怎么办？Spring 是如何处理的？</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开启Bean的加载</title>
      <link href="/2019/12/20/%E5%BC%80%E5%90%AFBean%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
      <url>/2019/12/20/%E5%BC%80%E5%90%AFBean%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>Spring IoC 容器的使用分为两个步骤：容器初始化和加载 Bean 阶段。</p><font size=2><ul><li>容器初始化阶段：<ul><li>首先，通过某种方法加载 Configuration Metadata（主要是依靠 Resource、ResourceLoader 两个体系）。</li><li>然后，容器会对加载的 Configuration Metadata 进行解析和分析，并将分析的信息组装成 BeanDefinition。</li></ul></li><li>加载 Bean 阶段：<ul><li>经过容器初始化阶段后，应用程序中定义的 bean 信息已经全部加载到系统中了，当我们显示或者隐式地调用 <code>BeanFactory#getBean(...)</code> 方法时，则会触发加载 Bean 阶段。</li><li>在这阶段，容器会首先检查所请求的对象是否已经初始化完成了，如果没有，则会根据注册的 Bean 信息实例化请求的对象，并为其注册依赖，然后将其返回给请求方。</li><li>至此第二个阶段也已经完成。<font></li></ul></li></ul><p>第一个阶段，前文已经了几篇文章来进行分析，从这篇开始第二阶段：加载 Bean 阶段。</p><h1 id="1-getBean"><a href="#1-getBean" class="headerlink" title="1 getBean"></a>1 getBean</h1><p>当我们显示或隐士地调用<code>BeanFactory#getBean(String name)</code>方法时，则会触发加载 Bean 阶段，代码如下：</p><pre><code>// AbstractBeanFactory.java@Overridepublic Object getBean(String name) throws BeansException {    return doGetBean(name, null, null, false);}</code></pre><font size=2><ul><li>内部调用<code>doGetBean(String name, final Class&lt;T&gt; requiredType, Object[] args, boolean typeCheckOnly)</code>方法，有四个参数：<ul><li>name：要获取 Bean 的名字。</li><li>requiredType：要获取 Bean 的类型。</li><li>args：创建 Bean 时传递的参数，这个参数仅限于创建 Bean 时使用。</li><li>typecheckOnly：是否为类型检查。<font></li></ul></li></ul><h1 id="2-doGetBean"><a href="#2-doGetBean" class="headerlink" title="2 doGetBean"></a>2 doGetBean</h1><p><code>#doGetBean(String name, final Class&lt;T&gt; requiredType, Object[] args, boolean typeCheckOnly)</code>此方法代码较长，代码如下：</p><pre><code>// AbstractBeanFactory.javaprotected &lt;T&gt; T doGetBean(final String name, @Nullable final Class&lt;T&gt; requiredType,        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {    // 【1】 返回 bean 名称，剥离工厂引用前缀。    // 如果 name 是 alias ，则获取对应映射的 beanName 。    final String beanName = transformedBeanName(name);    Object bean;    // 从缓存中或者实例工厂中获取 Bean 对象    // Eagerly check singleton cache for manually registered singletons.    Object sharedInstance = getSingleton(beanName);    if (sharedInstance != null &amp;&amp; args == null) {        if (logger.isTraceEnabled()) {            if (isSingletonCurrentlyInCreation(beanName)) {                logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +                        &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);            } else {                logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);            }        }        // 【2】 完成 FactoryBean 的相关处理，并用来获取 FactoryBean 的处理结果        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);    } else {        // Fail if we&#39;re already creating this bean instance:        // We&#39;re assumably within a circular reference.        // 【3】 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常。        if (isPrototypeCurrentlyInCreation(beanName)) {            throw new BeanCurrentlyInCreationException(beanName);        }        // 【4】 如果容器中没有找到，则从父类容器中加载        // Check if bean definition exists in this factory.        BeanFactory parentBeanFactory = getParentBeanFactory();        if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {            // Not found -&gt; check parent.            String nameToLookup = originalBeanName(name);            if (parentBeanFactory instanceof AbstractBeanFactory) {                return ((AbstractBeanFactory) parentBeanFactory).doGetBean(                        nameToLookup, requiredType, args, typeCheckOnly);            } else if (args != null) {                // Delegation to parent with explicit args.                return (T) parentBeanFactory.getBean(nameToLookup, args);            } else if (requiredType != null) {                // No args -&gt; delegate to standard getBean method.                return parentBeanFactory.getBean(nameToLookup, requiredType);            } else {                return (T) parentBeanFactory.getBean(nameToLookup);            }        }        // 【5】 如果不是仅仅做类型检查则是创建bean，这里需要记录        if (!typeCheckOnly) {            markBeanAsCreated(beanName);        }        try {            // 【6】 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象            final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);            // 检查给定的合并的 BeanDefinition            checkMergedBeanDefinition(mbd, beanName, args);            // Guarantee initialization of beans that the current bean depends on.            // 【7】 处理所依赖的 bean            String[] dependsOn = mbd.getDependsOn();            if (dependsOn != null) {                for (String dep : dependsOn) {                    // 若给定的依赖 bean 已经注册为依赖给定的 bean                    // 循环依赖的情况                    if (isDependent(beanName, dep)) {                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                                &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);                    }                    // 缓存依赖调用 TODO 芋艿                    registerDependentBean(dep, beanName);                    try {                        getBean(dep);                    } catch (NoSuchBeanDefinitionException ex) {                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,                                &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);                    }                }            }            // 【8】 bean 实例化            // Create bean instance.            if (mbd.isSingleton()) { // 单例模式                sharedInstance = getSingleton(beanName, () -&gt; {                    try {                        return createBean(beanName, mbd, args);                    }                    catch (BeansException ex) {                        // Explicitly remove instance from singleton cache: It might have been put there                        // eagerly by the creation process, to allow for circular reference resolution.                        // Also remove any beans that received a temporary reference to the bean.                        // 显式从单例缓存中删除 Bean 实例                        // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它。                         destroySingleton(beanName);                        throw ex;                    }                });                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);            } else if (mbd.isPrototype()) { // 原型模式                // It&#39;s a prototype -&gt; create a new instance.                Object prototypeInstance;                try {                    beforePrototypeCreation(beanName);                    prototypeInstance = createBean(beanName, mbd, args);                } finally {                    afterPrototypeCreation(beanName);                }                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);            } else {                // 从指定的 scope 下创建 bean                String scopeName = mbd.getScope();                final Scope scope = this.scopes.get(scopeName);                if (scope == null) {                    throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);                }try {                    Object scopedInstance = scope.get(beanName, () -&gt; {                        beforePrototypeCreation(beanName);                        try {                            return createBean(beanName, mbd, args);                        } finally {                            afterPrototypeCreation(beanName);                        }                    });                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);                } catch (IllegalStateException ex) {                    throw new BeanCreationException(beanName,                            &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +                            &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,                            ex);                }            }        } catch (BeansException ex) {            cleanupAfterBeanCreationFailure(beanName);            throw ex;        }    }    // 【9】 检查需要的类型是否符合 bean 的实际类型    // Check if required type matches the type of the actual bean instance.    if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {        try {            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);            if (convertedBean == null) {                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());            }            return convertedBean;        } catch (TypeMismatchException ex) {            if (logger.isTraceEnabled()) {                logger.trace(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +                        ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);            }            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());        }    }    return (T) bean;}</code></pre><p>这段代码是相当的长，逻辑也复杂，下面进行拆分分析。<br><font size=2></p><ul><li>【1】，详细解析，见[2.1]</li><li>【2】，详细解析，见[2.2]</li><li>【3】，详细解析，见[2.3]</li><li>【4】，详细解析，见[2.4]</li><li>【5】，详细解析，见[2.5]</li><li>【6】，详细解析，见[2.6]</li><li>【7】，详细解析，见[2.7]</li><li>【8】，详细解析，见[2.8]</li><li>【9】，详细解析，见[2.9]</li></ul></font><h2 id="2-1-获取-beanName"><a href="#2-1-获取-beanName" class="headerlink" title="2.1 获取 beanName"></a>2.1 获取 beanName</h2><p>对应代码如下：</p><pre><code>// AbstractBeanFactory.javafinal String beanName = transformedBeanName(name);</code></pre><p>这里传递的<code>name</code>参数，不一定就是 beanName，可能是 aliasName，也可能是 FactoryBean，所以这里需要<code>#transformedBeanName(String name)</code>方法，对<code>name</code>进行一番转换，代码如下：</p><pre><code>// AbstractBeanFactory.javaprotected String transformedBeanName(String name) {    return canonicalName(BeanFactoryUtils.transformedBeanName(name));}</code></pre><p>调用<code>BeanFactoryUtils#transformedBeanName(String name)</code>方法，去除 FactoryBean 的修饰符，代码如下：</p><pre><code>// BeanFactoryUtils.javaprivate static final Map&lt;String, String&gt; transformedBeanNameCache = new ConcurrentHashMap&lt;&gt;();/** * 去除 FactoryBean 的修饰符 &amp; * * 如果 name 以 “&amp;” 为前缀，那么会去掉该 &quot;&amp;&quot; 。 * 例如，name = &quot;&amp;studentService&quot; ，则会是 name = &quot;studentService&quot;。 * */public static String transformedBeanName(String name) {    Assert.notNull(name, &quot;&#39;name&#39; must not be null&quot;);    if (!name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX)) { // BeanFactory.FACTORY_BEAN_PREFIX = $        return name;    }    // computeIfAbsent 方法，分成两种情况：    //      1. 未存在，则进行计算执行，并将结果添加到缓存、    //      2. 已存在，则直接返回，无需计算。    return transformedBeanNameCache.computeIfAbsent(name, beanName -&gt; {        do {            beanName = beanName.substring(BeanFactory.FACTORY_BEAN_PREFIX.length());        } while (beanName.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));        return beanName;    });}</code></pre><p>实际上，这段代码比较简单，就是去除<code>name</code>参数的<code>&amp;</code>前缀。代码内的<code>transformedBeanNameCache</code>集合，是为了缓存转换后的做准备，下次再获取相同<code>name</code>时，直接返回缓存中的结果即可。</p><p>调用<code>#canonicalName(String name)</code>方法，取指定的<code>alias</code>所表示的最终 beanName，代码如下：</p><pre><code>// SimpleAliasRegistry.java/** Map from alias to canonical name. */// key: alias// value: beanNameprivate final Map&lt;String, String&gt; aliasMap = new ConcurrentHashMap&lt;&gt;(16);public String canonicalName(String name) {    String canonicalName = name;    // Handle aliasing...    String resolvedName;    // 循环，从 aliasMap 中，获取到最终的 beanName    do {        resolvedName = this.aliasMap.get(canonicalName);        if (resolvedName != null) {            canonicalName = resolvedName;        }    } while (resolvedName != null);    return canonicalName;}</code></pre><p>这里主要是一个循环获取 beanName 的过程，例如：别名 A 指向名称为 B 的 bean 返回 B，如果 别名 A 指向别名 B 指向名称为 C 的 bean，则返回 C。</p><h2 id="2-2-从单例-Bean-缓存中获取-Bean。"><a href="#2-2-从单例-Bean-缓存中获取-Bean。" class="headerlink" title="2.2 从单例 Bean 缓存中获取 Bean。"></a>2.2 从单例 Bean 缓存中获取 Bean。</h2><p>对应代码如下：</p><pre><code>// AbstractBeanFactory.java// 从缓存中或者实例工厂中获取 Bean 对象// Eagerly check singleton cache for manually registered singletons.Object sharedInstance = getSingleton(beanName);if (sharedInstance != null &amp;&amp; args == null) {    if (logger.isTraceEnabled()) {        if (isSingletonCurrentlyInCreation(beanName)) {            logger.trace(&quot;Returning eagerly cached instance of singleton bean &#39;&quot; + beanName +                    &quot;&#39; that is not fully initialized yet - a consequence of a circular reference&quot;);        } else {            logger.trace(&quot;Returning cached instance of singleton bean &#39;&quot; + beanName + &quot;&#39;&quot;);        }    }    // 【x】 完成 FactoryBean 的相关处理，并用来获取 FactoryBean 的处理结果    bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);}</code></pre><font size=2><ul><li>我们知道单例模式的 Bean 在整个生命周期只会被创建一次，第一次创建后会将该 Bean 加载到缓存中。后面再获取 Bean 直接从缓存获取。</li><li><code>【x】</code>处，如果从缓存中得到了 Bean 对象，则需要调用<code>#getObjectForBeanInstance(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</code>方法，对 Bean 进行实例化处理。因为，缓存中记录的是最原始的 Bean 状态，我们得到的不一定是我们最终想要的 Bean。另外，FactoryBean 的用途如下：</li></ul><blockquote><p>From 《Spring 源码深度解析》P83 页<br>一般情况下，Spring 通过反射机制利用 bean 的 class 属性指定实现类来实例化 bean 。某些情况下，实例化 bean 过程比较复杂，如果按照传统的方式，则需要在 中提供大量的配置信息，配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring 为此提供了一个 FactoryBean 的工厂类接口，用户可以通过实现该接口定制实例化 bean 的逻辑。<br>FactoryBean 接口对于 Spring 框架来说战友重要的地址，Spring 自身就提供了 70 多个 FactoryBean 的实现。它们隐藏了实例化一些复杂 bean 的细节，给上层应用带来了便利。 </p></blockquote></font><p>详细解析，见<strong>【源码】IoC加载Bean之从单例缓存中获取单例 Bean</strong></p><h2 id="2-3-原型模式依赖检查"><a href="#2-3-原型模式依赖检查" class="headerlink" title="2.3 原型模式依赖检查"></a>2.3 原型模式依赖检查</h2><p>对应代码如下：</p><pre><code>// AbstractBeanFactory.java// Fail if we&#39;re already creating this bean instance:// We&#39;re assumably within a circular reference.// 因为 Spring 只解决单例模式下得循环依赖，在原型模式下如果存在循环依赖则会抛出异常。if (isPrototypeCurrentlyInCreation(beanName)) {    throw new BeanCurrentlyInCreationException(beanName);}</code></pre><p>Spring 只处理单例模式下得循环依赖，对于原型模式的循环依赖直接抛出异常。主要原因还是在于，<strong>Spring 解决循环依赖的策略有关</strong>。</p><font size=2><ul><li>对于单例模式，Spring 在创建 Bean 的时候并不是等 Bean 完全创建完成后才会将 Bean 添加至缓存中，而是不等 Bean 创建完成就会将创建 Bean 的ObjectFactory 提早加入到缓存中，这样一旦下一个 Bean 创建的时候需要依赖时可以直接使用 ObjectFactory。</li><li>但是原型模式，我们知道是没办法使用缓存的，所以 Spring 对原型模式的循环依赖处理策略则是不处理。</li></ul></font><h2 id="2-4-从-parentBeanFactory-获取-Bean"><a href="#2-4-从-parentBeanFactory-获取-Bean" class="headerlink" title="2.4 从 parentBeanFactory 获取 Bean"></a>2.4 从 parentBeanFactory 获取 Bean</h2><p>对应代码如下：</p><pre><code>// AbstractBeanFactory.java// 如果当前容器中没有找到，则从父类容器中加载// Check if bean definition exists in this factory.BeanFactory parentBeanFactory = getParentBeanFactory();if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) {    // Not found -&gt; check parent.    String nameToLookup = originalBeanName(name);    // 如果，父类容器为 AbstractBeanFactory ，直接递归查找    if (parentBeanFactory instanceof AbstractBeanFactory) {        return ((AbstractBeanFactory) parentBeanFactory).doGetBean(                nameToLookup, requiredType, args, typeCheckOnly);    // 用明确的 args 从 parentBeanFactory 中，获取 Bean 对象    } else if (args != null) {        // Delegation to parent with explicit args.        return (T) parentBeanFactory.getBean(nameToLookup, args);    // 用明确的 requiredType 从 parentBeanFactory 中，获取 Bean 对象    } else if (requiredType != null) {        // No args -&gt; delegate to standard getBean method.        return parentBeanFactory.getBean(nameToLookup, requiredType);    // 直接使用 nameToLookup 从 parentBeanFactory 获取 Bean 对象    } else {        return (T) parentBeanFactory.getBean(nameToLookup);    }}</code></pre><p>如果当前容器缓存中没有对应的 BeanDefinition 对象，则会尝试从父类工厂（parentBeanFactory）中加载，然后在递归调用<code>#getBean(...)</code>方法。</p><p>详细解析，见<strong>【源码】IoC加载Bean之parentBeanFactory 与依赖处理</strong></p><h2 id="2-5-指定的-Bean-标记为已经创建或即将创建"><a href="#2-5-指定的-Bean-标记为已经创建或即将创建" class="headerlink" title="2.5 指定的 Bean 标记为已经创建或即将创建"></a>2.5 指定的 Bean 标记为已经创建或即将创建</h2><p>对应代码如下：</p><pre><code>// AbstractBeanFactory.java// 如果不是仅仅做类型检查则是创建bean，这里需要记录if (!typeCheckOnly) {    markBeanAsCreated(beanName);}</code></pre><p>详细解析，见<strong>【源码】IoC加载Bean之parentBeanFactory 与依赖处理</strong></p><h2 id="2-6-获取-BeanDefinition"><a href="#2-6-获取-BeanDefinition" class="headerlink" title="2.6 获取 BeanDefinition"></a>2.6 获取 BeanDefinition</h2><p>对应代码如下：</p><pre><code>// AbstractBeanFactory.java// 从容器中获取 beanName 相应的 GenericBeanDefinition 对象，并将其转换为 RootBeanDefinition 对象final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);// 检查给定的合并的 BeanDefinitioncheckMergedBeanDefinition(mbd, beanName, args);</code></pre><p>详细解析，见<strong>【源码】IoC加载Bean之parentBeanFactory 与依赖处理</strong></p><h2 id="2-7-依赖-Bean-处理"><a href="#2-7-依赖-Bean-处理" class="headerlink" title="2.7 依赖 Bean 处理"></a>2.7 依赖 Bean 处理</h2><p>对应代码如下：</p><pre><code>// AbstractBeanFactory.java// Guarantee initialization of beans that the current bean depends on.// 处理所依赖的 beanString[] dependsOn = mbd.getDependsOn();if (dependsOn != null) {    for (String dep : dependsOn) {        // 若给定的依赖 bean 已经注册为依赖给定的 bean        // 即循环依赖的情况，抛出 BeanCreationException 异常        if (isDependent(beanName, dep)) {            throw new BeanCreationException(mbd.getResourceDescription(), beanName,                    &quot;Circular depends-on relationship between &#39;&quot; + beanName + &quot;&#39; and &#39;&quot; + dep + &quot;&#39;&quot;);        }        // 缓存依赖调用 TODO 芋艿        registerDependentBean(dep, beanName);        try {            // 递归处理依赖 Bean            getBean(dep);        } catch (NoSuchBeanDefinitionException ex) {            throw new BeanCreationException(mbd.getResourceDescription(), beanName,                    &quot;&#39;&quot; + beanName + &quot;&#39; depends on missing bean &#39;&quot; + dep + &quot;&#39;&quot;, ex);        }    }}</code></pre><font size=2><ul><li>每个 Bean 都不是单独工作的，它会依赖其他 Bean，也会被其他 Bean 依赖。</li><li>对于依赖的 Bean，它会优先加载。所以，在 Spring 的加载顺序中，在初始化某一个 Bean 的时候，首先会初始化这个 Bean 的依赖。</li></ul></font><p>详细解析，见<strong>【源码】IoC加载Bean之parentBeanFactory 与依赖处理</strong></p><h2 id="2-8-不同作用域的-Bean-实例化"><a href="#2-8-不同作用域的-Bean-实例化" class="headerlink" title="2.8 不同作用域的 Bean 实例化"></a>2.8 不同作用域的 Bean 实例化</h2><p>对应代码如下：</p><pre><code>// AbstractBeanFactory.java// bean 实例化// Create bean instance.if (mbd.isSingleton()) { // 单例模式    sharedInstance = getSingleton(beanName, () -&gt; {        try {            return createBean(beanName, mbd, args);        }        catch (BeansException ex) {            // 显式从单例缓存中删除 Bean 实例            // 因为单例模式下为了解决循环依赖，可能他已经存在了，所以销毁它。 TODO 芋艿            destroySingleton(beanName);            throw ex;        }    });    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);} else if (mbd.isPrototype()) { // 原型模式    // It&#39;s a prototype -&gt; create a new instance.    Object prototypeInstance;    try {        beforePrototypeCreation(beanName);        prototypeInstance = createBean(beanName, mbd, args);    } finally {        afterPrototypeCreation(beanName);    }    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);} else {    // 从指定的 scope 下创建 bean    String scopeName = mbd.getScope();    final Scope scope = this.scopes.get(scopeName);    if (scope == null) {        throw new IllegalStateException(&quot;No Scope registered for scope name &#39;&quot; + scopeName + &quot;&#39;&quot;);    }try {        Object scopedInstance = scope.get(beanName, () -&gt; {            beforePrototypeCreation(beanName);            try {                return createBean(beanName, mbd, args);            } finally {                afterPrototypeCreation(beanName);            }        });        bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);    } catch (IllegalStateException ex) {        throw new BeanCreationException(beanName,                &quot;Scope &#39;&quot; + scopeName + &quot;&#39; is not active for the current thread; consider &quot; +                &quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;,                ex);    }}</code></pre><font size=2><ul><li>Spring Bean 的作用域默认为 singleton，当前还有其他的作用域，如 property、request、session 等。</li><li>不同的作用域会有不同的初始化策略。</li></ul></font><p>详细解析，见<strong>【源码】IoC加载Bean之分析各 scope 的 Bean 创建</strong></p><h2 id="2-9-类型转换"><a href="#2-9-类型转换" class="headerlink" title="2.9 类型转换"></a>2.9 类型转换</h2><p>对应代码如下：</p><pre><code>// AbstractBeanFactory.java// 检查需要的类型是否符合 bean 的实际类型// Check if required type matches the type of the actual bean instance.if (requiredType != null &amp;&amp; !requiredType.isInstance(bean)) {    try {        // 执行转换        T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);        // 转换失败，抛出 BeanNotOfRequiredTypeException 异常        if (convertedBean == null) {            throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());        }        return convertedBean;    } catch (TypeMismatchException ex) {        if (logger.isTraceEnabled()) {            logger.trace(&quot;Failed to convert bean &#39;&quot; + name + &quot;&#39; to required type &#39;&quot; +                    ClassUtils.getQualifiedName(requiredType) + &quot;&#39;&quot;, ex);        }        throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());    }}</code></pre><font size=2><ul><li>在调用<code>#doGetBean(...)</code>方法时，有一个 requireType 参数。该参数的功能就是将返回的 Bean 转换为<code>requireType</code>类型。</li><li>当然一般而言，我们是不需要进行类型转换的，也就是<code>requireType</code>为空。但是，可能会存在这种情况。比如我们返回的 Bean 类型是 String，我们在使用的时候需要将其转换为 Integer，那么这个时候<code>requireType</code> 就可以使用了。<strong>当前我们一般不这样使用</strong>。 </li></ul></font><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>至此<code>BeanFactory#getBean(...)</code>方法的过程简单的讲解完了，后续会进行拆分，详细的说明各个步骤。拆分主要分成三个部分：</p><font size=2><ul><li><ol><li>分析从缓存中获取单例 Bean，以及 Bean 的实例中获取对象。</li></ol></li><li><ol start="2"><li>如果从单例模式中获取 Bean，Spring 是怎样加载的？所以第二部分是分析 Bean 加载，以及 Bean 的依赖处理。</li></ol></li><li><ol start="3"><li>Bean 已经加载了，依赖也处理完毕了，第三部分则分析各个作用域的 Bean 初始化过程。</li></ol></li></ul></font></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册BeanDefinitions-下</title>
      <link href="/2019/12/11/%E6%B3%A8%E5%86%8CBeanDefinitions-%E4%B8%8B/"/>
      <url>/2019/12/11/%E6%B3%A8%E5%86%8CBeanDefinitions-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<font size=3><blockquote><p>在这里面，我把如何解析 bean 标签和自定义标签的方法忽略了，主要还是如何将解析后的 BeanDefinitions 注册到容器中。</p></blockquote><p><strong>DefaultBeanDefinitionDocumentReader</strong> 的<code>#processBeanDefinition()</code>方法，完成了解析 Bean 标签的核心代码。代码如下：</p><pre><code>// DefaultBeanDefinitionDocumentReader.javaprotected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {    // 【1】进行 bean 元素解析。    // 如果解析成功，则返回 BeanDefinitionHolder 对象。而 BeanDefinitionHolder 为 name 和 alias 的 BeanDefinition 对象    // 如果解析失败，则返回 null 。    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);    if (bdHolder != null) {        // 【2】进行自定义标签处理        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);        try {            // 【3】进行 BeanDefinition 的注册            // Register the final decorated instance.            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());        } catch (BeanDefinitionStoreException ex) {            getReaderContext().error(&quot;Failed to register bean definition with name &#39;&quot; +                    bdHolder.getBeanName() + &quot;&#39;&quot;, ele, ex);        }        // 发出响应事件，通知相关的监听器，已完成该 Bean 标签的解析。        // Send registration event.        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));    }}</code></pre><font size=2><ul><li>解析分为三步骤：<ul><li>【1】解析默认 Bean 标签。</li><li>【2】解析自定义标签。</li><li>【3】将解析后的 BeanDefinition 注册到容器中。</li></ul></li><li>经过前面两个步骤的解析，这时的 BeanDefinition 已经可以满足后续的使用要求了，<strong>那么接下来的工作就是将这些 BeanDefinition 进行注册，也就是完成第三步</strong>。</li></ul></font><h1 id="1-BeanDefinitionReaderUtils"><a href="#1-BeanDefinitionReaderUtils" class="headerlink" title="1 BeanDefinitionReaderUtils"></a>1 BeanDefinitionReaderUtils</h1><p>注册 BeanDefinition ，由<code>BeanDefinitionReaderUtils.registerBeanDefinition()</code>完成。代码如下：</p><pre><code>// BeanDefinitionReaderUtils.javapublic static void registerBeanDefinition(        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)        throws BeanDefinitionStoreException {    // 注册 beanName    // Register bean definition under primary name.    String beanName = definitionHolder.getBeanName();    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());    // 注册 alias    // Register aliases for bean name, if any.    String[] aliases = definitionHolder.getAliases();    if (aliases != null) {        for (String alias : aliases) {            registry.registerAlias(beanName, alias);        }    }}</code></pre><font size=2><ul><li>首先，通过 beanName 注册 BeanDefinition。【详见2.1】</li><li>然后，在注册 beanName 和 alias 的关联。【详见2.2】</li></ul></font><h1 id="2-BeanDefinitionRegistry"><a href="#2-BeanDefinitionRegistry" class="headerlink" title="2 BeanDefinitionRegistry"></a>2 BeanDefinitionRegistry</h1><p>BeanDefinition 的注册由 <code>org.springframework.beans.factory.support.BeanDefinitionRegistry</code>定义。</p><h2 id="2-1-通过-beanName-注册"><a href="#2-1-通过-beanName-注册" class="headerlink" title="2.1 通过 beanName 注册"></a>2.1 通过 beanName 注册</h2><p>调用 BeanDefinitionRegistry 的<code>#registerBeanDefinition(String beanName, BeanDefinition beanDefinition)</code>方法，实现通过<code>beanName</code>和 BeanDefinition注册。代码如下：</p><pre><code>// DefaultListableBeanFactory.java/** Whether to allow re-registration of a different definition with the same name. */private boolean allowBeanDefinitionOverriding = true;/** Map of bean definition objects, keyed by bean name. */private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256);/** List of bean definition names, in registration order. */private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256);/** List of names of manually registered singletons, in registration order. */private volatile Set&lt;String&gt; manualSingletonNames = new LinkedHashSet&lt;&gt;(16);/** Cached array of bean definition names in case of frozen configuration. */@Nullableprivate volatile String[] frozenBeanDefinitionNames;@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)        throws BeanDefinitionStoreException {    // 校验 beanName 与 beanDefinition 非空    Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);    Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);    // 【1】 校验 BeanDefinition 。    // 这是注册前的最后一次校验了，主要是对属性 methodOverrides 进行校验。    if (beanDefinition instanceof AbstractBeanDefinition) {        try {            ((AbstractBeanDefinition) beanDefinition).validate();        } catch (BeanDefinitionValidationException ex) {            throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,                    &quot;Validation of bean definition failed&quot;, ex);        }    }    // 【2】 从缓存中获取指定 beanName 的 BeanDefinition    BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);    // 【3】 如果已经存在    if (existingDefinition != null) {        // 如果存在但是不允许覆盖，抛出异常        if (!isAllowBeanDefinitionOverriding()) {            throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);        // 覆盖 beanDefinition 大于 被覆盖的 beanDefinition 的 ROLE ，打印 info 日志        } else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) {            // e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE            if (logger.isInfoEnabled()) {                logger.info(&quot;Overriding user-defined bean definition for bean &#39;&quot; + beanName +                        &quot;&#39; with a framework-generated bean definition: replacing [&quot; +                        existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);            }        // 覆盖 beanDefinition 与 被覆盖的 beanDefinition 不相同，打印 debug 日志        } else if (!beanDefinition.equals(existingDefinition)) {            if (logger.isDebugEnabled()) {                logger.debug(&quot;Overriding bean definition for bean &#39;&quot; + beanName +                        &quot;&#39; with a different definition: replacing [&quot; + existingDefinition +                        &quot;] with [&quot; + beanDefinition + &quot;]&quot;);            }        // 其它，打印 debug 日志        } else {            if (logger.isTraceEnabled()) {                logger.trace(&quot;Overriding bean definition for bean &#39;&quot; + beanName +                        &quot;&#39; with an equivalent definition: replacing [&quot; + existingDefinition +                        &quot;] with [&quot; + beanDefinition + &quot;]&quot;);            }        }        // 允许覆盖，直接覆盖原有的 BeanDefinition 到 beanDefinitionMap 中。        this.beanDefinitionMap.put(beanName, beanDefinition);    // 【4】 如果未存在    } else {        // 检测创建 Bean 阶段是否已经开启，如果开启了则需要对 beanDefinitionMap 进行并发控制        if (hasBeanCreationStarted()) {            // beanDefinitionMap 为全局变量，避免并发情况            // Cannot modify startup-time collection elements anymore (for stable iteration)            synchronized (this.beanDefinitionMap) {                // 添加到 BeanDefinition 到 beanDefinitionMap 中。                this.beanDefinitionMap.put(beanName, beanDefinition);                // 添加 beanName 到 beanDefinitionNames 中                List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);                updatedDefinitions.addAll(this.beanDefinitionNames);                updatedDefinitions.add(beanName);                this.beanDefinitionNames = updatedDefinitions;                // 从 manualSingletonNames 移除 beanName                if (this.manualSingletonNames.contains(beanName)) {                    Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;&gt;(this.manualSingletonNames);                    updatedSingletons.remove(beanName);                    this.manualSingletonNames = updatedSingletons;                }            }        } else {            // Still in startup registration phase            // 添加到 BeanDefinition 到 beanDefinitionMap 中。            this.beanDefinitionMap.put(beanName, beanDefinition);            // 添加 beanName 到 beanDefinitionNames 中            this.beanDefinitionNames.add(beanName);            // 从 manualSingletonNames 移除 beanName            this.manualSingletonNames.remove(beanName);        }        this.frozenBeanDefinitionNames = null;    }    // 【5】 重新设置 beanName 对应的缓存    if (existingDefinition != null || containsSingleton(beanName)) {        resetBeanDefinition(beanName);    }}</code></pre><font size=2><ul><li>【1】对 BeanDefinition 进行验证，该校验也是注册过程中的最后一次校验了，主要是对 AbstractBeanDefinition 的<code>methodOverrides</code>属性进行校验。</li><li>【2】根据<code>beanName</code>从缓存中获取 BeanDefinition对象。</li><li>【3】如何缓存中存在，则根据<code>allowBeanDefinitionOverriding</code>标签来判断是否允许覆盖，如果云讯直接覆盖，否则抛出<code>BeanDefinitionStoreException</code>异常。</li><li>【4】若缓存中没有<code>beanName</code>的 BeanDefinition 对象，则判断当前阶段是否已经开始了 Bean 的创建阶段？如果是，则需要对 beanDefinitionMap 进行加锁控制并发问题，否则直接设置即可。<ul><li>对于<code>#hasBeanCreationStarted()</code>后续做详细解释。</li></ul></li><li>【5】若缓存中存在该<code>beanName</code>或者单利 bean 集合中存在该<code>beanName</code>，则调用<code>#resetBeanDefinition(String beanName)</code>方法，重置 BeanDefinition 缓存。<ul><li>其实整段代码的核心在于<code>this.beanDefinitionMap.put(beanName, beanDefinition)</code>方法，而 BeanDefinition 缓存也不是一个神奇的东西，就是定义个 Map，Key 是 beanName，Value 是 BeanDefinition 对象。</li></ul></li></ul></font><h2 id="2-2-注册-alias-和-beanName-的映射"><a href="#2-2-注册-alias-和-beanName-的映射" class="headerlink" title="2.2 注册 alias 和 beanName 的映射"></a>2.2 注册 alias 和 beanName 的映射</h2><p>调用 BeanDefinitionRegistry 的<code>#registerAlias(String name, String alias)</code>方法，注册 <code>alias</code> 和 <code>beanName</code> 的映射关系。代码如下：</p><pre><code>// SimpleAliasRegistry.java/** Map from alias to canonical name. */// key: alias// value: beanNameprivate final Map&lt;String, String&gt; aliasMap = new ConcurrentHashMap&lt;&gt;(16);@Overridepublic void registerAlias(String name, String alias) {    // 校验 name 、 alias    Assert.hasText(name, &quot;&#39;name&#39; must not be empty&quot;);    Assert.hasText(alias, &quot;&#39;alias&#39; must not be empty&quot;);    synchronized (this.aliasMap) {        // name == alias 则去掉alias        if (alias.equals(name)) {            this.aliasMap.remove(alias);            if (logger.isDebugEnabled()) {                logger.debug(&quot;Alias definition &#39;&quot; + alias + &quot;&#39; ignored since it points to same name&quot;);            }        } else {            // 获取 alias 已注册的 beanName            String registeredName = this.aliasMap.get(alias);            // 已存在            if (registeredName != null) {                // 相同，则 return ，无需重复注册                if (registeredName.equals(name)) {                    // An existing alias - no need to re-register                    return;                }                // 不允许覆盖，则抛出 IllegalStateException 异常                if (!allowAliasOverriding()) {                    throw new IllegalStateException(&quot;Cannot define alias &#39;&quot; + alias + &quot;&#39; for name &#39;&quot; +                            name + &quot;&#39;: It is already registered for name &#39;&quot; + registeredName + &quot;&#39;.&quot;);                }                if (logger.isDebugEnabled()) {                    logger.debug(&quot;Overriding alias &#39;&quot; + alias + &quot;&#39; definition for registered name &#39;&quot; +                            registeredName + &quot;&#39; with new target name &#39;&quot; + name + &quot;&#39;&quot;);                }            }            // 校验，是否存在循环指向            checkForAliasCircle(name, alias);            // 注册 alias            this.aliasMap.put(alias, name);            if (logger.isTraceEnabled()) {                logger.trace(&quot;Alias definition &#39;&quot; + alias + &quot;&#39; registered for name &#39;&quot; + name + &quot;&#39;&quot;);            }        }    }}</code></pre><font size=2><ul><li>注册 alias 和 BeanDefinition 的过程差不多。</li><li>最后，调用<code>#checkForAliasCircle()</code>进行<strong>循环</strong>验证。</li></ul><pre><code>protected void checkForAliasCircle(String name, String alias) {    if (hasAlias(alias, name)) {        throw new IllegalStateException(&quot;Cannot register alias &#39;&quot; + alias +                &quot;&#39; for name &#39;&quot; + name + &quot;&#39;: Circular reference - &#39;&quot; +                name + &quot;&#39; is a direct or indirect alias for &#39;&quot; + alias + &quot;&#39; already&quot;);    }}public boolean hasAlias(String name, String alias) {    for (Map.Entry&lt;String, String&gt; entry : this.aliasMap.entrySet()) {        String registeredName = entry.getValue();        if (registeredName.equals(name)) {            String registeredAlias = entry.getKey();            if (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias)) {                return true;            }        }    }    return false;}</code></pre><ul><li>验证主要是避免循环指向的问题。</li></ul></font><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>到这里 BeanDefinition 基于 beanName 和 alias 的维度，都已经注入到缓存中，下一步则是等待初始化使用了。</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册BeanDefinitions-上</title>
      <link href="/2019/12/06/%E6%B3%A8%E5%86%8CBeanDefinitions-%E4%B8%8A/"/>
      <url>/2019/12/06/%E6%B3%A8%E5%86%8CBeanDefinitions-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<font size=3><br/><p>在获取 XML Document 对象后，会根据该对象和 Resource 资源对象调用<code>XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)</code>方法，开始注册 BeanDefinitions。代码如下：</p><pre><code>// AbstractBeanDefinitionReader.javaprivate final BeanDefinitionRegistry registry;// XmlBeanDefinitionReader.javapublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {    // 【1】 创建 BeanDefinitionDocumentReader 对象    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();    // 【2】 获取已注册的 BeanDefinition 数量    int countBefore = getRegistry().getBeanDefinitionCount();    // 【3】 创建 XmlReaderContext 对象    // 【4】 注册 BeanDefinition    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));    // 【5】 计算新注册的 BeanDefinition 数量    return getRegistry().getBeanDefinitionCount() - countBefore;}</code></pre><font size=2><ul><li>【1】，调用<code>#createBeanDefinitionDocumentReader()</code>方法，实例化 BeanDefinitionDocumentReader 对象。</li><li>【2】，调用<code>BeanDefinitionRegistry#getBeanDefinitionCount()</code>方法，获取<strong>已注册</strong>的 BeanDefinition 数量。</li><li>【3】，调用<code>#createReaderContext(Resource resource)</code>方法，创建 XmlReaderContext 对象。</li><li>【4】，调用<code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code>方法，读取 XML 元素，注册 BeanDefinitions。</li><li>【5】，计算新注册的 BeanDefinition 数量。</li></ul></font><h1 id="1-createBeanDefinitionDocumentReader"><a href="#1-createBeanDefinitionDocumentReader" class="headerlink" title="1 createBeanDefinitionDocumentReader"></a>1 createBeanDefinitionDocumentReader</h1><p><code>#createBeanDefinitionDocumentReader()</code>，实例化 BeanDefinitionDocumentReader 对象。代码如下：</p><pre><code>/** * documentReader 的类 * * @see #createBeanDefinitionDocumentReader()  */private Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass = DefaultBeanDefinitionDocumentReader.class;protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {    return BeanUtils.instantiateClass(this.documentReaderClass);}</code></pre><ul><li><code>documentReaderClass</code>的默认值为<code>DefaultBeanDefinitionDocumentReader.class</code>，关于它我们后续文章在详细说明。</li></ul><h1 id="2-registerBeanDefinitions"><a href="#2-registerBeanDefinitions" class="headerlink" title="2 registerBeanDefinitions"></a>2 registerBeanDefinitions</h1><p><code>BeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</code>方法，注册 BeanDefinition，在接口 BeanDefinitionDocumentReader 中定义。代码如下：</p><pre><code>public interface BeanDefinitionDocumentReader {    void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)            throws BeanDefinitionStoreException;}</code></pre><p><strong>从给定的 Document 对象中解析定义的 BeanDefinition 并将它们注册到注册表中</strong></p><ul><li><code>doc</code>方法参数：带解析的 Document 对象。</li><li><code>readerContext</code>方法，解析器的当前上下文，包括目标注册表和被解析的资源，它是根据 Resource 来创建的。（详见本篇 <strong>3 createReaderContext</strong>）</li></ul><h2 id="2-1-DefaultBeanDefinitionDocumentReader"><a href="#2-1-DefaultBeanDefinitionDocumentReader" class="headerlink" title="2.1 DefaultBeanDefinitionDocumentReader"></a>2.1 DefaultBeanDefinitionDocumentReader</h2><p><code>BeanDefinitionDocumentReader</code>有且只有一个默认实现类 <code>DefaultBeanDefinitionDocumentReader</code>，它对<code>#registerBeanDefinitions()</code>方法的实现代码如下：</p><pre><code>@Nullableprivate XmlReaderContext readerContext;@Nullableprivate BeanDefinitionParserDelegate delegate;@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {    this.readerContext = readerContext;    // 获得 XML Document Root Element    // 执行注册 BeanDefinition    doRegisterBeanDefinitions(doc.getDocumentElement());}/** * Register each bean definition within the given root {@code &lt;beans/&gt;} element. */@SuppressWarnings(&quot;deprecation&quot;)  // for Environment.acceptsProfiles(String...)protected void doRegisterBeanDefinitions(Element root) {    // 记录老的 BeanDefinitionParserDelegate 对象    BeanDefinitionParserDelegate parent = this.delegate;    // 【1】 创建 BeanDefinitionParserDelegate 对象，并进行设置到 delegate    this.delegate = createDelegate(getReaderContext(), root, parent);    // 【2】 检查 &lt;beans /&gt; 根标签的命名空间是否为空，或者是 http://www.springframework.org/schema/beans    if (this.delegate.isDefaultNamespace(root)) {        // 【2.1】 处理 profile 属性。可参见《Spring3自定义环境配置 &lt;beans profile=&quot;&quot;&gt;》http://nassir.iteye.com/blog/1535799        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);        if (StringUtils.hasText(profileSpec)) {            // 【2.2】 使用分隔符切分，可能有多个 profile 。            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);            // 【2.3】 如果所有 profile 都无效，则不进行注册            // We cannot use Profiles.of(...) since profile expressions are not supported            // in XML config. See SPR-12458 for details.            if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {                if (logger.isDebugEnabled()) {                    logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +                            &quot;] not matching: &quot; + getReaderContext().getResource());                }                return;            }        }    }    // 【3】 解析前处理    preProcessXml(root);    // 【4】 解析    parseBeanDefinitions(root, this.delegate);    // 【5】 解析后处理    postProcessXml(root);    // 设置 delegate 回老的 BeanDefinitionParserDelegate 对象    this.delegate = parent;}</code></pre><font size=2><ul><li><p>【1】，创建 BeanDefinitionParserDelegate 对象，并进行设置<code>delegate</code>，BeanDefinitionParserDelegate 是一个重要的类，它负责<strong>解析</strong> BeanDefinition。代码如下：</p><pre><code>protected BeanDefinitionParserDelegate createDelegate(      XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) {  // 创建 BeanDefinitionParserDelegate 对象  BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);  // 初始化默认  delegate.initDefaults(root, parentDelegate);  return delegate;}</code></pre></li><li><p>【2】，检查<code>&lt;beans /&gt;</code>跟标签的命名空间是否为空。</p><ul><li>【2.1】，判断是否<code>&lt;beans /&gt;</code>上配置了<code>profile</code>属性。</li><li>【2.2】，使用分隔符切分，可能有多个 profile。</li><li>【2.3】，判断如果所有 profile 都无效，则<code>return</code>不进行注册。</li></ul></li><li><p>【4】，调用<code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code>方法，进行逻辑解析（<strong>详见 2.1.1 parseBeanDefinition</strong>）</p></li><li><p>【3】、【5】，解析的前后处理，目前这两个方法都是空实现，交由子类实现。代码如下：</p></li></ul><pre><code>protected void preProcessXml(Element root) {}protected void postProcessXml(Element root) {}</code></pre></font><h3 id="2-1-1-parseBeanDefinitions"><a href="#2-1-1-parseBeanDefinitions" class="headerlink" title="2.1.1 parseBeanDefinitions"></a>2.1.1 parseBeanDefinitions</h3><p><code>#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</code>方法，进行解析逻辑。代码如下：</p><pre><code>protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {    // 【1】 如果根节点使用默认命名空间，执行默认解析    if (delegate.isDefaultNamespace(root)) {        // 遍历子节点        NodeList nl = root.getChildNodes();        for (int i = 0; i &lt; nl.getLength(); i++) {            Node node = nl.item(i);            if (node instanceof Element) {                Element ele = (Element) node;                // &lt;1&gt; 如果该节点使用默认命名空间，执行默认解析                if (delegate.isDefaultNamespace(ele)) {                    parseDefaultElement(ele, delegate);                // 如果该节点非默认命名空间，执行自定义解析                } else {                    delegate.parseCustomElement(ele);                }            }        }    // 【2】 如果根节点非默认命名空间，执行自定义解析    } else {        delegate.parseCustomElement(root);    }}</code></pre><ul><li>Spring 有<strong>两种</strong> Bean声明方法：<ul><li>配置文件式：<code>&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.StudentService&quot; /&gt;</code>对应【1】。</li><li>自定义注解方法：<code>&lt;tx:annotation-driven&gt;</code>对应【2】。</li></ul></li></ul><h1 id="3-createReaderContext"><a href="#3-createReaderContext" class="headerlink" title="3 createReaderContext"></a>3 createReaderContext</h1><p><code>#createReaderContext(Resource resource)</code>方法，创建 XmlReaderContext对象，代码如下：</p><pre><code>private ProblemReporter problemReporter = new FailFastProblemReporter();private ReaderEventListener eventListener = new EmptyReaderEventListener();private SourceExtractor sourceExtractor = new NullSourceExtractor();@Nullableprivate NamespaceHandlerResolver namespaceHandlerResolver;/** * Create the {@link XmlReaderContext} to pass over to the document reader. */public XmlReaderContext createReaderContext(Resource resource) {    return new XmlReaderContext(resource, this.problemReporter, this.eventListener,            this.sourceExtractor, this, getNamespaceHandlerResolver());}</code></pre><p>关于 XmlReaderContext详细，见后续。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>至此，<code>XmlBeanDefinitionReader#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code>方法中，做的三件事情已经全完分析完毕。<br>另外<code>XmlBeanDefinitionReader#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code>方法，整体时序图如下：</p><p><img src="/images/pasted-26.png" alt="时序图"></p><p><em>红色部分，就是 BeanDefinition 的解析过程</em></p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring统一资源加载策略</title>
      <link href="/2019/12/04/Spring%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5/"/>
      <url>/2019/12/04/Spring%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<font size=3><blockquote><p>因为 Java 提供的资源定位器不满足需求，所以 Spring 必须实现自己的资源加载策略。</p></blockquote><p>该资源策略的要求：<br><font size=2></p><ul><li>职能清晰，资源的定义和资源的加载应该有一个清晰的界限。</li><li>统一的抽象，统一的资源定义和资源加载策略。资源加载后要返回统一的抽象给客户端，客户端要对资源进行怎样的处理，应该由抽象资源接口来定义。</li></ul></font><h1 id="1-统一资源-Resource体系"><a href="#1-统一资源-Resource体系" class="headerlink" title="1 统一资源 Resource体系"></a>1 统一资源 Resource体系</h1><p><code>org.springframework.core.io.Resource</code>是 Spring 框架所有资源的抽象和访问接口，它继承<code>org.springframework.core.io.InputStreamSource</code>接口。作为所有资源的统一抽象， Resource 定义了一些通用的方法，由子类<code>AbstractResource</code>提供统一的默认实现。通用定义如下：</p><pre><code>public interface Resource extends InputStreamSource {    /**     * 资源是否存在     */    boolean exists();    /**     * 资源是否可读     */    default boolean isReadable() {        return true;    }    /**     * 资源所代表的句柄是否被一个 stream 打开了     */    default boolean isOpen() {        return false;    }    /**     * 是否为 File     */    default boolean isFile() {        return false;    }    /**     * 返回资源的 URL 的句柄     */    URL getURL() throws IOException;    /**     * 返回资源的 URI 的句柄     */    URI getURI() throws IOException;    /**     * 返回资源的 File 的句柄     */    File getFile() throws IOException;    /**     * 返回 ReadableByteChannel     */    default ReadableByteChannel readableChannel() throws IOException {        return java.nio.channels.Channels.newChannel(getInputStream());    }    /**     * 资源内容的长度     */    long contentLength() throws IOException;    /**     * 资源最后的修改时间     */    long lastModified() throws IOException;    /**     * 根据资源的相对路径创建新资源     */    Resource createRelative(String relativePath) throws IOException;    /**     * 资源的文件名     */    @Nullable    String getFilename();    /**     * 资源的描述     */    String getDescription();}</code></pre><h2 id="1-1-子类结构"><a href="#1-1-子类结构" class="headerlink" title="1.1 子类结构"></a>1.1 子类结构</h2><p><img src="/images/pasted-23.png" alt="Resource类图"></p><p>从上图可以看到， Resource 根据资源的不同类型提供了不同的具体实现：</p><font size=2><ul><li><strong>FileSystemResource</strong> ：对<code>java.io.File</code>类型资源的封装，只要是跟 File 打交道的，基本上与 FileSystemResource 也可以打交道。</li><li><strong>ByteArrayResource</strong> ：对字节数组提供的数据的封装。如果通过 InputStream 形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的 ByteArrayInputStream。</li><li><strong>UrlResource</strong> ：对<code>java.net.URL</code>类型资源的封装。内部委派 URL 进行具体的资源操作。</li><li><strong>ClassPathResource</strong> ：class path 类型资源的实现。使用给定的 ClassLoader 或者给定的 Class 来加载资源。</li><li><strong>InputStreamResource</strong> ：将给定的 InputStream 作为一种资源的 Resource 的实现类。</li></ul></font><h2 id="1-2-AbstractResource"><a href="#1-2-AbstractResource" class="headerlink" title="1.2 AbstractResource"></a>1.2 AbstractResource</h2><p><code>org.springframework.core.io.AbstractResource</code>，是Resource接口的默认<strong>抽象</strong>实现，它实现了 Resource 接口的<strong>大部分公共实现</strong>，作为 Resource 接口中的重要组成，定义如下：</p><pre><code>public abstract class AbstractResource implements Resource {    /**     * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流     */    @Override    public boolean exists() {        try {          // 基于 File 进行判断            return getFile().exists();        }        catch (IOException ex) {            // Fall back to stream existence: can we open the stream?            // 基于 InputStream 进行判断            try {                InputStream is = getInputStream();                is.close();                return true;            } catch (Throwable isEx) {                return false;            }        }    }    /**     * 直接返回true，表示可读     */    @Override    public boolean isReadable() {        return true;    }    /**     * 直接返回 false，表示未被打开     */    @Override    public boolean isOpen() {        return false;    }    /**     * 直接返回false，表示不为 File     */    @Override    public boolean isFile() {        return false;    }    /**     * 抛出 FileNotFoundException 异常，交给子类实现     */    @Override    public URL getURL() throws IOException {        throw new FileNotFoundException(getDescription() + &quot; cannot be resolved to URL&quot;);    }    /**     * 基于 getURL() 返回的 URL 构建 URI     */    @Override    public URI getURI() throws IOException {        URL url = getURL();        try {            return ResourceUtils.toURI(url);        } catch (URISyntaxException ex) {            throw new NestedIOException(&quot;Invalid URI [&quot; + url + &quot;]&quot;, ex);        }    }    /**     * 抛出 FileNotFoundException 异常，交给子类实现     */    @Override    public File getFile() throws IOException {        throw new FileNotFoundException(getDescription() + &quot; cannot be resolved to absolute file path&quot;);    }    /**     * 根据 getInputStream() 的返回结果构建 ReadableByteChannel     */    @Override    public ReadableByteChannel readableChannel() throws IOException {        return Channels.newChannel(getInputStream());    }    /**     * 获取资源的长度     *     * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断     */    @Override    public long contentLength() throws IOException {        InputStream is = getInputStream();        try {            long size = 0;            byte[] buf = new byte[255]; // 每次最多读取 255 字节            int read;            while ((read = is.read(buf)) != -1) {                size += read;            }            return size;        } finally {            try {                is.close();            } catch (IOException ex) {            }        }    }    /**     * 返回资源最后的修改时间     */    @Override    public long lastModified() throws IOException {        long lastModified = getFileForLastModifiedCheck().lastModified();        if (lastModified == 0L) {            throw new FileNotFoundException(getDescription() +                    &quot; cannot be resolved in the file system for resolving its last-modified timestamp&quot;);        }        return lastModified;    }    protected File getFileForLastModifiedCheck() throws IOException {        return getFile();    }    /**     * 抛出 FileNotFoundException 异常，交给子类实现     */    @Override    public Resource createRelative(String relativePath) throws IOException {        throw new FileNotFoundException(&quot;Cannot create a relative resource for &quot; + getDescription());    }    /**     * 获取资源名称，默认返回 null ，交给子类实现     */    @Override    @Nullable    public String getFilename() {        return null;    }    /**     * 返回资源的描述     */    @Override    public String toString() {        return getDescription();    }    @Override    public boolean equals(Object obj) {        return (obj == this ||            (obj instanceof Resource &amp;&amp; ((Resource) obj).getDescription().equals(getDescription())));    }    @Override    public int hashCode() {        return getDescription().hashCode();    }}</code></pre><p><em>如果我们想要实现自定义的 Resource ，记住不要实现 Resource 接口，而应该继承 AbstractResource 抽象类，然后根据当前的具体资源特性覆盖相应的方法即可。</em></p><h1 id="2-统一资源定位-ResourceLoader"><a href="#2-统一资源定位-ResourceLoader" class="headerlink" title="2 统一资源定位 ResourceLoader"></a>2 统一资源定位 ResourceLoader</h1><blockquote><p>开始就说了 Spring 将资源的定义和资源的加载区分开了，** Resource 定义了统一的资源，那资源的加载则由 ResourceLoader 来统一定义。**</p></blockquote><p><code>org.springframework.core.io.ResourceLoader</code>为 Spring 资源加载的统一抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将 ResourceLoader 称作为统一资源定位器。其定义如下：</p><pre><code>public interface ResourceLoader {    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; // CLASSPATH URL 前缀。默认为：&quot;classpath:&quot;    Resource getResource(String location);    ClassLoader getClassLoader();}</code></pre><font size=2><ul><li><code>#getResource(String location)</code>方法，根据所提供资源路径 location 返回 Resource 实例，<strong>但是它不确保该 Resource 一定存在</strong>，需要调用 Resource#exist() 方法来判断。<ul><li>该方法支持一下模式的资源：<ul><li>URL 位置资源，如<code>file:C:/test.dat</code>。</li><li>ClassPath 位置资源，如<code>classpath：test.dat</code>。</li><li>相对路径资源，如<code>WEB-INF/test.dat</code>。</li><li>返回的 Resource 实例根据实现不同而不同。<ul><li>该方法的主要实现是在其子类 <strong>DefaultResourceLoader</strong> 中实现，具体过程在分析 <strong>DefaultResourceLoader</strong> 时详细说明。</li></ul></li></ul></li></ul></li><li><code>#getClassLoader()</code>方法，返回 ClassLoader 实例，对于想要获取 ResourceLoader 使用的 ClassLoader 用于来说，可以直接调用该方法来获取。在分析 Resource 时，提到了一个类 <strong>ClassPathResource</strong>，这个类是可以根据指定的 ClassLoader 来加载资源的。</li></ul></font><p>作为 Spring 统一的资源加载器，它提供了统一的抽象，具体的实现则由相应的子类来负责实现，其类的类结构图如下：</p><p><img src="/images/pasted-24.png" alt="ResourceLoader加载资源文件类图"></p><h2 id="2-1-DefaultResourceLoader"><a href="#2-1-DefaultResourceLoader" class="headerlink" title="2.1 DefaultResourceLoader"></a>2.1 DefaultResourceLoader</h2><p>与 AbstractResource 相似， <strong>org.springframework.core.io.DefaultResourceLoader</strong> 是 ResourceLoader 的默认实现。</p><h3 id="2-1-1-构造函数"><a href="#2-1-1-构造函数" class="headerlink" title="2.1.1 构造函数"></a>2.1.1 构造函数</h3><p>它接收 ClassLoader 作为构造函数的参数，或者使用无参的构造函数。</p><font size=2><ul><li>使用<strong>无参</strong>的构造时，使用的 ClassLoader 为默认的 ClassLoader(<code>Thread.currentThread()#getContextClassLoader()</code>)。</li><li>使用<strong>带参</strong>的构造时，可以通过<code>ClassUtils#getDefaultClassLoader()</code>获取。</li><li>也可以调用<code>#setClassLoader()</code>方法进行后续设置。</li></ul></font><p>代码如下：</p><pre><code>@Nullableprivate ClassLoader classLoader;public DefaultResourceLoader() { // 无参构造函数    this.classLoader = ClassUtils.getDefaultClassLoader();}public DefaultResourceLoader(@Nullable ClassLoader classLoader) { // 带 ClassLoader 参数的构造函数    this.classLoader = classLoader;}public void setClassLoader(@Nullable ClassLoader classLoader) {    this.classLoader = classLoader;}@Override@Nullablepublic ClassLoader getClassLoader() {    return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());}</code></pre><h3 id="2-1-2-getResource方法"><a href="#2-1-2-getResource方法" class="headerlink" title="2.1.2 getResource方法"></a>2.1.2 getResource方法</h3><p>ResourceLoader 中最核心的方法是<code>#getResource(String localtion)</code>，它根据提供的 location 返回相应的 Resource。而 DefaultResourceLoader 对该方法提供了<strong>核心实现</strong>。</p><pre><code>// DefaultResourceLoader.java@Overridepublic Resource getResource(String location) {    Assert.notNull(location, &quot;Location must not be null&quot;);    // 首先，通过 ProtocolResolver 来加载资源    for (ProtocolResolver protocolResolver : this.protocolResolvers) {        Resource resource = protocolResolver.resolve(location, this);        if (resource != null) {            return resource;        }    }    // 其次，以 / 开头，返回 ClassPathContextResource 类型的资源    if (location.startsWith(&quot;/&quot;)) {        return getResourceByPath(location);    // 再次，以 classpath: 开头，返回 ClassPathResource 类型的资源    } else if (location.startsWith(CLASSPATH_URL_PREFIX)) {        return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());    // 然后，根据是否为文件 URL ，是则返回 FileUrlResource 类型的资源，否则返回 UrlResource 类型的资源    } else {        try {            // Try to parse the location as a URL...            URL url = new URL(location);            return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));        } catch (MalformedURLException ex) {            // 最后，返回 ClassPathContextResource 类型的资源            // No URL -&gt; resolve as resource path.            return getResourceByPath(location);        }    }}</code></pre><font size=2><ul><li>首先，通过 ProtocolResolver 来加载资源，成功加载返回 Resource。</li><li>其次，若<code>location</code>以<code>&quot;/&quot;</code>开头，则调用<code>#getResourceByPath()</code>方法，构造ClassPathContextResource类型资源并返回，代码如下<pre><code>protected Resource getResourceByPath(String path) {  return new ClassPathContextResource(path, getClassLoader());}</code></pre></li><li>再次，若<code>location</code>以<code>”classpath:“</code>开头，则构造ClassPathResource类型资源并返回，在构造该资源是，通过<code>#getClassLoader</code>获取当前的 ClassLoader。</li><li>然后，构造 URL ，尝试通过它进行资源定位，若没有抛出 MalformedURLException 异常，则判断是否为 FileURL , 如果是则构造 FileUrlResource 类型的资源，否则构造 UrlResource 类型的资源。</li><li>最后，若在加载过程中抛出 MalformedURLException 异常，则委派<code>#getResourceByPath()</code>方法，实现资源定位加载。</li></ul></font><h3 id="2-1-3-ProtocolResolver"><a href="#2-1-3-ProtocolResolver" class="headerlink" title="2.1.3 ProtocolResolver"></a>2.1.3 ProtocolResolver</h3><p><code>org.springframework.core.io.ProtocolResolver</code>,用户自定义资源解决策略，作为 DefaultResrouceLoader 的SPI：它允许用户自定义资源加载协议，而不需要继承ResourceLoader的子类。<br>在介绍 Resource 时，提到<strong>如果要实现自定义 Resource ，必须要继承 AbstractResource 实现</strong>，但有了 ProtocolResolver 后，我们不需要直接继承 DefaultResourceLoader ，改为实现 ProtocolResolver 接口也可以实现自定义的 ResourceLoader 。<br>ProtocolResolver 接口，只有一个方法，<code>Resource resolve(String location, ResourceLoader resourceLoader)</code>。代码如下：</p><pre><code>/** * 使用指定的 ResourceLoader ，解析指定的 location 。 * 若成功，则返回对应的 Resource 。 * * @param location  资源路径 * @param resourceLoader  指定的加载器 ResourceLoader * @return 返回为相应的 Resource */@NullableResource resolve(String location, ResourceLoader resourceLoader);</code></pre><p>在 Spring 中你会发现该接口并没有实现类，它需要用户自定义，自定义的 Resolver 如何加入 Spring 体系呢？调用<code>DefaultResourceLoader#addProtocolResolver(ProtocolResolver)</code>方法即可。代码如下：</p><pre><code>/** * ProtocolResolver 集合 */private final Set&lt;ProtocolResolver&gt; protocolResolvers = new LinkedHashSet&lt;&gt;(4);public void addProtocolResolver(ProtocolResolver resolver) {    Assert.notNull(resolver, &quot;ProtocolResolver must not be null&quot;);    this.protocolResolvers.add(resolver);}</code></pre><h3 id="2-1-4-示例"><a href="#2-1-4-示例" class="headerlink" title="2.1.4 示例"></a>2.1.4 示例</h3><p>下面示例是演示 DefaultResourceLoader 加载资源的具体策略，代码如下：</p><pre><code>ResourceLoader resourceLoader = new DefaultResourceLoader();Resource fileResource1 = resourceLoader.getResource(&quot;D:/Users/chenming673/Documents/spark.txt&quot;);System.out.println(&quot;fileResource1 is FileSystemResource:&quot; + (fileResource1 instanceof FileSystemResource));Resource fileResource2 = resourceLoader.getResource(&quot;/Users/chenming673/Documents/spark.txt&quot;);System.out.println(&quot;fileResource2 is ClassPathResource:&quot; + (fileResource2 instanceof ClassPathResource));Resource urlResource1 = resourceLoader.getResource(&quot;file:/Users/chenming673/Documents/spark.txt&quot;);System.out.println(&quot;urlResource1 is UrlResource:&quot; + (urlResource1 instanceof UrlResource));Resource urlResource2 = resourceLoader.getResource(&quot;http://www.baidu.com&quot;);System.out.println(&quot;urlResource1 is urlResource:&quot; + (urlResource2 instanceof  UrlResource));</code></pre><p>运行结果：</p><pre><code>fileResource1 is FileSystemResource:falsefileResource2 is ClassPathResource:trueurlResource1 is UrlResource:trueurlResource1 is urlResource:true</code></pre><font size=2><ul><li>其实对于<code>fileResource1</code>，我们更加希望是 FileSystemResource 资源类型，但事实它是 ClassPathResource 类型。为什么呢？ 在<code>DefaultResourceLoader#getResource()</code>方法的资源加载策略中，我们知道<code>D:/Users/chenming673/Documents/spark.txt</code>地址并不存在对应的资源。那么它就会抛出 MalformedURLException 异常，通过<code>DefaultResourceLoader#getResourceByPath()</code>方法构建一个 ClassPathResource 类型的资源返回。</li><li>而<code>urlResource1</code>和<code>urlResource2</code>，指定有协议前缀的资源路径，则通过URL就可以定义，所以返回的都是 UrLResource 类型。</li></ul></font><h2 id="2-2-FileSystemResourceLoader"><a href="#2-2-FileSystemResourceLoader" class="headerlink" title="2.2 FileSystemResourceLoader"></a>2.2 FileSystemResourceLoader</h2><p>从上面的示例，我们看到，其实 DefaultResourceLoader 对<code>#getResourceByPath(String)</code>方法处理其实不是很恰当，这个时候我们可以<code>org.springframework.core.io.FileSystemResourceLoader</code>。它继承 DefaultResourceLoader ，并且重写了<code>#getResourceByPath(String)</code>方法，使从文件系统加载资源并以 FileSystemResource 类型返回，这样我们就可以得到想要的资源类型。代码如下：</p><pre><code>@Overrideprotected Resource getResourceByPath(String path) {    // 截取首 /    if (path.startsWith(&quot;/&quot;)) {        path = path.substring(1);    }    // 创建 FileSystemContextResource 类型的资源    return new FileSystemContextResource(path);}</code></pre><h3 id="2-2-1-FileSystemResourceLoader"><a href="#2-2-1-FileSystemResourceLoader" class="headerlink" title="2.2.1 FileSystemResourceLoader"></a>2.2.1 FileSystemResourceLoader</h3><p>FileSystemResourceLoader，是 FileSystemResourceLoader 的内部类，它继承 FileSystemResource 类，实现了 ContextResource 接口。代码如下：</p><pre><code>private static class FileSystemContextResource extends FileSystemResource implements ContextResource {    public FileSystemContextResource(String path) {        super(path);    }    @Override    public String getPathWithinContext() {        return getPath();    }}</code></pre><font size=2><ul><li>在构造器中，也是调用 FileSystemResource 的构造函数来构造 FileSystemResource。</li><li>FileSystemContextResource 存在的意义是实现 ContextResource 接口，并实现对应的<code>#getPathWithinContext()</code>接口方法。</li></ul></font><h3 id="2-2-2-示例"><a href="#2-2-2-示例" class="headerlink" title="2.2.2 示例"></a>2.2.2 示例</h3><p>在回头看一下【2.1.4示例】，如果将 DefaultResourceLoader 改成 FileSystemResourceLoader，则<code>fileResource1</code>为 FileSystemResource 类型的资源。</p><h2 id="2-3-ClassRelativeResourceLoader"><a href="#2-3-ClassRelativeResourceLoader" class="headerlink" title="2.3 ClassRelativeResourceLoader"></a>2.3 ClassRelativeResourceLoader</h2><p><code>org.springframework.core.io.ClassRelativeResourceLoader</code>，是 DefaultResourceLoader 的另一个子类实现。和 FileSystemResource 在实现代码的结构上类似，也是重写<code>#getResourceByPath(String path)</code>方法，并返回对应的 ClassRelativeContextResource 的资源类型。</p><blockquote><p>ClassRelativeResourceLoader 扩展的功能是，可以根据给定的<code>class</code>所在包或者所在包的子包下加载资源。</p></blockquote><h2 id="2-4-ResourcePatternResolver"><a href="#2-4-ResourcePatternResolver" class="headerlink" title="2.4 ResourcePatternResolver"></a>2.4 ResourcePatternResolver</h2><p>ResourceLoader 的<code>Resource getResource(String location)</code>方法，每次只能根据 location  返回<strong>一个</strong> Resource。当需要加载多个资源时，我们除了多次调用<code>#getResource(String location)</code>方法以外，别无他法。<code>org.springframework.core.io.support.ResourcePatternResolver</code>是 ResourceLoader 的扩展，它支持根据指定的资源路径匹配模式每次返回<strong>多个</strong>Resource实例。代码如下：</p><pre><code>public interface ResourcePatternResolver extends ResourceLoader {    String CLASSPATH_ALL_URL_PREFIX = &quot;classpath*:&quot;;    Resource[] getResources(String locationPattern) throws IOException;}</code></pre><font size=2><ul><li>ResourcePatternResolver 在 ResourceLoader 的基础上增加了<code>#getResources(String locationPattern)</code>方法，以支持根据路径匹配模式返回<strong>多个 Resource 实例</strong>。</li><li>同时，也新增了一种新的协议前缀<code>&quot;classpath*:&quot;</code>，该协议前缀由其子类负责实现。</li></ul></font><h2 id="2-5-PathMatchingResourcePatternResolver"><a href="#2-5-PathMatchingResourcePatternResolver" class="headerlink" title="2.5 PathMatchingResourcePatternResolver"></a>2.5 PathMatchingResourcePatternResolver</h2><p><code>org.springframework.core.io.support.PathMatchingResourcePatternResolver</code>，为 ResourcePatternResolver 最常用的子类，它除了支持 ResourceLoader 和 ResourcePatternResolver 新增的<code>&quot;classpath*:&quot;</code>前缀外，<strong>还支持Ant风格的路径匹配</strong></p><h3 id="2-5-1-构造函数"><a href="#2-5-1-构造函数" class="headerlink" title="2.5.1 构造函数"></a>2.5.1 构造函数</h3><p>PathMatchingResourcePatternResolver 提供了三个构造函数，代码如下：</p><pre><code>/** * 内置的 ResourceLoader 资源定位器 */private final ResourceLoader resourceLoader;/** * Ant 路径匹配器 */private PathMatcher pathMatcher = new AntPathMatcher();public PathMatchingResourcePatternResolver() {    this.resourceLoader = new DefaultResourceLoader();}public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {    Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;);    this.resourceLoader = resourceLoader;}public PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) {    this.resourceLoader = new DefaultResourceLoader(classLoader);}</code></pre><font size=2><ul><li>PathMatchingResourcePatternResolver 在实例化的时候，可以指定一个 ResourceLoader，如果不指定的话，它会在内部构造一个 DefaultResourceLoader 。</li><li><code>pathMatcher</code> 属性，默认为 AntPathMatcher 对象，用于支持 Ant 类型的路径匹配。</li></ul></font><h3 id="2-5-2-getResource"><a href="#2-5-2-getResource" class="headerlink" title="2.5.2 getResource"></a>2.5.2 getResource</h3><pre><code>@Overridepublic Resource getResource(String location) {    return getResourceLoader().getResource(location);}public ResourceLoader getResourceLoader() {    return this.resourceLoader;}</code></pre><p>该方法，直接委托给相应的 ResourceLoader 来实现。所以，如果我们在实例化的 PathMatchingResourcePatternResolver 的时候，未指定 ResourceLoader 参数的情况下，那么在加载资源时，其实就是 DefaultResourceLoader 的过程。<br><br/><br>其实在下面介绍的<code>Resource[] getResources(String locationPattern)</code>方法也相同，只不过返回的资源是<strong>多个</strong>而已。</p><h3 id="2-5-3-getResources"><a href="#2-5-3-getResources" class="headerlink" title="2.5.3 getResources"></a>2.5.3 getResources</h3><pre><code>@Overridepublic Resource[] getResources(String locationPattern) throws IOException {    Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;);    // 以 &quot;classpath*:&quot; 开头    if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {        // 路径包含通配符        // a class path resource (multiple resources for same name possible)        if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {            // a class path resource pattern            return findPathMatchingResources(locationPattern);        // 路径不包含通配符        } else {            // all class path resources with the given name            return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));        }    // 不以 &quot;classpath*:&quot; 开头    } else {        // Generally only look for a pattern after a prefix here, // 通常只在这里的前缀后面查找模式        // and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol. 而在 Tomcat 上只有在 “*/ ”分隔符之后才为其 “war:” 协议        int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 :                locationPattern.indexOf(&#39;:&#39;) + 1);        // 路径包含通配符        if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {            // a file pattern            return findPathMatchingResources(locationPattern);        // 路径不包含通配符        } else {            // a single resource with the given name            return new Resource[] {getResourceLoader().getResource(locationPattern)};        }    }}</code></pre><font size=2>  <ul><li>非<code>&quot;classpath*:&quot;</code>开头，并且路径<strong>不包含</strong>通配符，直接委托给相应的 ResourceLoader 来实现。</li><li>其他情况，调用<code>#findAllClassPathResources()</code>或<code>#findPathMatchingResources()</code>方法，返回多个 Resource。</li></ul></font><h1 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h1><p>至此 Spring 整个资源加载过程已经分析完毕。我省略了如何具体定位资源地址的代码。  </p><font size=2><ul><li>Spring 提供了 Resource 和 ResourceLoader 来统一抽象整个资源及定位，使得资源与资源定位有了一个更加清晰的界限，并且提供了适合的 Default 类。</li><li><strong>AbstractResource 为 Resource 的默认抽象实现</strong>，它对 Resource 接口做了一个统一的实现。子类继承该类后需要重写相应的方法即可，统一对于自定义 Resource 我们也是继承该类。</li><li><strong>DefaultResourceLoader 同样也是 ResourceLoader 的默认实现</strong>，在自定义 ResourceLoader 时，我们除了继承该类以外，更推荐的用法是实现 <strong>ProtocolResolver</strong> 接口来实现自定义资源加载协议。</li><li><strong>DefaultResourceLoader 每次只能返回单一的资源</strong>，所以 Spring 针对这个提供了另外一个接口 ResourcePatternResolver，该接口提供了根据指定的 locationPattern 返回多个资源的策略。其子类 PathMatchingResourcePatternResolver 是一个集大成者的 ResourceLoader，因为它即实现了<code>Resource getResource(String location)</code>方法，也实现了<code>Resource[] getResources(String locationPattern)</code>方法。</li></ul></font></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加载BeanDefinition</title>
      <link href="/2019/12/04/%E5%8A%A0%E8%BD%BDBeanDefinition/"/>
      <url>/2019/12/04/%E5%8A%A0%E8%BD%BDBeanDefinition/</url>
      
        <content type="html"><![CDATA[<font size=3><br/>先看一段熟悉的代码：  <pre><code>ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;); // &lt;1&gt;DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); // &lt;2&gt;XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory); // &lt;3&gt;reader.loadBeanDefinitions(resource); // &lt;4&gt;</code></pre><p>这段代码是 Spring 中编程式使用 IoC 容器，通过这四段简单的代码，我们可以初步判断 IoC 容器的使用过程。</p><font size=2><ul><li>获取资源。</li><li>获取 BeanFactory。</li><li>根据新建的 BeanFactory 创建一个 BeanDefinitionReader 对象，该 Reader 对象为资源的解析器。</li><li>装在资源</li></ul></font><p>整个过程分为三个步骤：资源定位、转载、注册。</p><p><img src="/images/pasted-25.png" alt="装载流程"></p><font size=2><ul><li><strong>资源定位</strong>：我们一般用外部资源来描述 Bean 对象，所以在初始化 IoC 容器的第一步就是需要定位这个外部资源，具体可以参考（【源码】IoC之Spring统一资源加载策略）已经详细说明了资源加载的过程。</li><li><strong>装载</strong>：装载就是 BeanDefinition 的载入，BeanDefinitionReader 读取、解析 Resource 资源，也就是将用户定义的 Bean 表示成 IoC 容器的内部数据：<strong>BeanDefinition</strong>。<ul><li>在 IoC 容器的内部维护着一个 <strong>BeanDefinition Map</strong> 的数据结构。</li><li>在配置文件中每一个 <code>&lt;bean&gt;</code> 都对应着一个 BeanDefinition 对象。</li><li>本文，我们分享的就是<strong>装载</strong>这个步骤。</li></ul></li><li><strong>注册</strong>：向 IoC 容器注册在第二步解析好的 BeanDefinition，这个过程是通过 BeanDefinitionRegistry 接口实现，在 IoC 容器内部其实是将第二过程解析得到的 BeanDefinition 注入到一个 HashMap 容器中，IoC 容器就是通过这个 HashMap 来维护这些 BeanDefinition。<ul><li>在这里需要注意的是，这个过程<strong>并没有完成依赖注入</strong>，Bean 的创建发生在第一次调用<code>#getBean()</code>方法时。</li><li>当然我们可以通过设置参数，对某个 Bean 设置<code>lazyinit = false</code>属性，那么 Bean 的依赖注入就会在容器初始化的时候完成。</li></ul></li></ul></font><h1 id="1-loadBeanDefinitions"><a href="#1-loadBeanDefinitions" class="headerlink" title="1 loadBeanDefinitions"></a>1 loadBeanDefinitions</h1><p>上面我们看到的<code>reader.loadBeanDefinitions(resource)</code>代码，才是加载资源的真正实现，所以我们直接从该方法入手。代码如下：</p><pre><code>// XmlBeanDefinitionReader.java@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {    return loadBeanDefinitions(new EncodedResource(resource));}</code></pre><font size=2><ul><li>从指定的资源文件加载 BeanDefinition，这里会先对 Resource 资源封装成<code>org.springframework.core.io.support.EncodedResource</code>对象，这里之所以封装一层，主要是为了对 Resource 进行编码，保证内容读取的正确性。</li><li>然后在调用<code>#loadBeanDefinitions(EncodedResource encodedResource)</code>方法，开始执行真正的逻辑实现。</li></ul></font><pre><code>/** * 当前线程，正在加载的 EncodedResource 集合。 */private final ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded = new NamedThreadLocal&lt;&gt;(&quot;XML bean definition resources currently being loaded&quot;);public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {    Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);    if (logger.isTraceEnabled()) {        logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource);    }    // 【1】 获取已经加载过的资源    Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();    if (currentResources == null) {        currentResources = new HashSet&lt;&gt;(4);        this.resourcesCurrentlyBeingLoaded.set(currentResources);    }    if (!currentResources.add(encodedResource)) { // 将当前资源加入记录中。如果已存在，抛出异常        throw new BeanDefinitionStoreException(&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);    }    try {        // 【2】 从 EncodedResource 获取封装的 Resource ，并从 Resource 中获取其中的 InputStream        InputStream inputStream = encodedResource.getResource().getInputStream();        try {            InputSource inputSource = new InputSource(inputStream);            if (encodedResource.getEncoding() != null) { // 设置编码                inputSource.setEncoding(encodedResource.getEncoding());            }            // 核心逻辑部分，执行加载 BeanDefinition            return doLoadBeanDefinitions(inputSource, encodedResource.getResource());        } finally {            inputStream.close();        }    } catch (IOException ex) {        throw new BeanDefinitionStoreException(&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);    } finally {        // 【3】 从缓存中剔除该资源         currentResources.remove(encodedResource);        if (currentResources.isEmpty()) {            this.resourcesCurrentlyBeingLoaded.remove();        }    }}</code></pre><font size=2><ul><li><code>【1】</code>,通过<code>resourcesCurrentlyBeingLoaded.get()</code>来获取已经加载过的资源，然后将<code>encodedResource</code>加入其中，如果<code>resourcesCurrentlyBeingLoaded</code>中已经存在该资源，则抛出 BeanDefinitionStoreException 异常。<ul><li>之所以要抛出异常，是为了避免一个 EncodedResource 在加载时，还没加载完成，又加载自身，导致<strong>死循环</strong></li><li>也是因为这个，在<code>【3】</code>当一个 EncodedResource 加载完成后，需要从缓存中剔除掉。</li></ul></li><li><code>【2】</code>，从<code>encodedResource</code>获取封装的 Resource 资源，并从 Resource 中获取相应的 InputStream， 然后将 InputStream 封装成 InputSource，最后调用<code>#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code>方法，执行加载 BeanDefinition 的真正逻辑。</li></ul></font><h1 id="2-doLoadBeanDefinitions"><a href="#2-doLoadBeanDefinitions" class="headerlink" title="2 doLoadBeanDefinitions"></a>2 doLoadBeanDefinitions</h1><pre><code>protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)        throws BeanDefinitionStoreException {    try {        // 【1】 获取 XML Document 实例        Document doc = doLoadDocument(inputSource, resource);        // 【2】 根据 Document 实例，注册 Bean 信息        int count = registerBeanDefinitions(doc, resource);        if (logger.isDebugEnabled()) {            logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource);        }        return count;    } catch (BeanDefinitionStoreException ex) {        throw ex;    } catch (SAXParseException ex) {        throw new XmlBeanDefinitionStoreException(resource.getDescription(),                &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);    } catch (SAXException ex) {        throw new XmlBeanDefinitionStoreException(resource.getDescription(),                &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);    } catch (ParserConfigurationException ex) {        throw new BeanDefinitionStoreException(resource.getDescription(),                &quot;Parser configuration exception parsing XML from &quot; + resource, ex);    } catch (IOException ex) {        throw new BeanDefinitionStoreException(resource.getDescription(),                &quot;IOException parsing XML document from &quot; + resource, ex);    } catch (Throwable ex) {        throw new BeanDefinitionStoreException(resource.getDescription(),                &quot;Unexpected exception parsing XML document from &quot; + resource, ex);    }}</code></pre><font size=2><ul><li><code>【1】</code>：调用<code>#doLoadDocument(InputSource inputSource, Resource resource)</code>，根据 xml 文件，获取 Document 实例。</li><li><code>【2】</code>：调用<code>#registerBeanDefinitions(Document doc, Resource resource)</code>，根据获取到的 Document 实例，注册相关信息。</li></ul></font><h2 id="2-1-doLoadDocument"><a href="#2-1-doLoadDocument" class="headerlink" title="2.1 doLoadDocument"></a>2.1 doLoadDocument</h2><pre><code>/** * 解析验证 XML 获取 Document 实例 */protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {    return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,            getValidationModeForResource(resource), isNamespaceAware());}</code></pre><h2 id="2-2-registerBeanDefinitions"><a href="#2-2-registerBeanDefinitions" class="headerlink" title="2.2 registerBeanDefinitions"></a>2.2 registerBeanDefinitions</h2><blockquote><p>该方法详细，见（【源码】IoC 之注册 BeanDefinitions）</p></blockquote></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Spring IoC</title>
      <link href="/2019/12/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%20IoC/"/>
      <url>/2019/12/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%20IoC/</url>
      
        <content type="html"><![CDATA[<font size=3><blockquote><p>Spring的源码好难，看的稀里糊涂。在最最开始学习Spring的时候就接触了IoC，作为Spring的核心概念，还是有必要对Ico的全套实现有一个深入的认识的。本篇主要介绍IoC的基本概念和各个组件。</p></blockquote><h1 id="1-IoC理论"><a href="#1-IoC理论" class="headerlink" title="1 IoC理论"></a>1 IoC理论</h1><p>IoC全称<code>Inversion of Control</code>翻译过来就是<code>控制反转</code>，它还有一个别名叫DI（<code>Dependency Injection</code>），即依赖注入。    </p><p>这里就涉及一个问题，如何理解“控制反转”？引申出来四个问题：</p><font size=2><ul><li>谁控制了谁？</li><li>控制了谁？</li><li>为何是反转？</li><li>哪些方面进行了反转？  </li></ul></font><blockquote><p>所谓的IoC，就是由Spring IoC容器来负责对象的生命周期和对象之间的关键。</p></blockquote><p>上面这句话就是IoC的核心含义。为此我们使用一个例子来阐述。</p><pre><code>/** * 年轻小伙子 */public class YoungMan {    private BeautifulGirl beautifulGirl;    YoungMan(){        // 可能你比较牛逼，指腹为婚        // beautifulGirl = new BeautifulGirl();    }    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {        this.beautifulGirl = beautifulGirl;    }    public static void main(String[] args){        YoungMan you = new YoungMan();        // 建立我们的依赖        BeautifulGirl beautifulGirl = new BeautifulGirl(&quot;你的各种条件&quot;);        beautifulGirl.setxxx(&quot;各种投其所好&quot;);        // 然后你有女票了        you.setBeautifulGirl(beautifulGirl);    }}</code></pre><p>这就是我们通常的使用方式，如果我们需要某一个对象一般都是采取直接创建的方式（<code>new BeautifulGirl</code>），这个过程既繁琐又复杂，而且我们必须面对每一个环节，使用完成后我们还要负责销毁它。这种情况下我们使用的对象与之依赖的对象耦合在了一起。<br>其实我们思考一下就会发现一个问题，我们每次依赖到的对象真的需要我们去创建它吗？我们明白，<strong>我们依赖某一个对象并不是依赖它本身，和是依赖于它所能提供的服务</strong>。只要它能在我们需要的时候将服务提供给我们，至于它是我们创建的还是别人送过来的无关紧要。<br>这个送过来的“人”就是IoC，以上面的代码为例，它就相当于一个“婚介公司”，当我们需要一个女朋友到时候，只需要和“婚介公司”说，它会根据我们需求提供一个妹子给我们。我们需要负责谈谈恋爱、使用就可以。<br><br/><br>IoC这个“婚介公司”帮助我们从主动寻找变成了被动接受，更加的简洁、方便所有的一些都又IoC去操作，我们坐享其成。<br>所以简单的说：IoC的理念就是<strong>让别人为你服务</strong></p><p><img src="/images/pasted-16.png" alt="由IoC管理"><br>在没有IoC的时候，被注入的对象直接和被依赖的对象耦合。引入IoC以后，通过IoC Service Provider将被依赖的对象送过来。所以IoC就是这么简单：<strong>原来是需要什么东西自己去拿，现在是需要什么东西让别人（IoC Service Provider）送过来。</strong></p><br/>现在让我们在回顾上面提出的四个问题：<font size=2><ul><li>谁控制了谁？<ul><li>在传统模式下，我们使用new来创建对象，也就是对象由你自己控制。现在使用IoC，由IoC来负责创建对象。谁控制了谁？当然是IoC控制了对象。</li></ul></li><li>控制了什么？<ul><li>控制对象的创建。</li></ul></li><li>为何是反转？<ul><li>没有 IoC 的时候我们都是在自己对象中主动去创建被依赖的对象，这是正转。但是有了 IoC 后，所依赖的对象直接由 IoC 容器创建后注入到被注入的对象中，依赖的对象由原来的主动获取变成被动接受，所以是反转。</li></ul></li><li>哪些方面进行了反转？<ul><li>所依赖对象的获取被反转了。</li></ul></li></ul></font><h2 id="1-1-注入形式"><a href="#1-1-注入形式" class="headerlink" title="1.1 注入形式"></a>1.1 注入形式</h2><blockquote><p>现在妹子有了，但是如何拥有妹子？这也是一门学问。</p></blockquote><p>IoC Service Provider 为被注入对象提供被依赖对象也有如下几种方式：构造方法注入、setter方法注入、接口注入。</p><ul><li><p><strong>构造方法注入</strong><br>构造器注入，顾名思义就是被注入的对象通过在其构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。</p><pre><code>YoungMan(BeautifulGirl beautifulGirl) {  this.beautifulGirl = beautifulGirl;}</code></pre><p>构造器注入方式比较直观，对象构造完毕后就可以直接使用，这就好比你出生你家里就给你指定了你媳妇。</p></li><li><p><strong>setter方法注入</strong><br>对于 JavaBean 对象而言，我们一般都是通过 getter 和 setter 方法来访问和设置对象的属性。所以，当前对象只需要为其所依赖的对象提供相对应的 setter 方法，就可以通过该方法将相应的依赖对象设置到被注入对象中。如下：</p></li></ul><pre><code>public class YoungMan {    private BeautifulGirl beautifulGirl;    public void setBeautifulGirl(BeautifulGirl beautifulGirl) {        this.beautifulGirl = beautifulGirl;    }}</code></pre><p>相比于构造器注入，setter 方式注入会显得比较宽松灵活些，它可以在任何时候进行注入（当然是在使用依赖对象之前），这就好比你可以先把自己想要的妹子想好了，然后再跟婚介公司打招呼，你可以要林志玲款式的，赵丽颖款式的，甚至凤姐哪款的，随意性较强。</p><ul><li><strong>接口注入</strong></li></ul><p><em>接口方式注入显得比较霸道，因为它需要被依赖的对象实现不必要的接口，带有侵入性。一般都不推荐这种方式。</em></p><h1 id="2-五大组件"><a href="#2-五大组件" class="headerlink" title="2 五大组件"></a>2 五大组件</h1><blockquote><p>IoC有五大组件，它们五个负责了IoC的全部工作。</p></blockquote><h2 id="2-1-Resource体系"><a href="#2-1-Resource体系" class="headerlink" title="2.1 Resource体系"></a>2.1 Resource体系</h2><p><code>org.springframework.core.io.Resource</code>，对资源的抽象。它的每一个实现都代表一种资源的<strong>访问策略</strong>，如 ClassPathResource、RLResource、FileSystemResource 等。</p><p><img src="/images/pasted-17.png" alt="资源定位"></p><h3 id="2-1-1-ResourceLoader-体系"><a href="#2-1-1-ResourceLoader-体系" class="headerlink" title="2.1.1 ResourceLoader 体系"></a>2.1.1 ResourceLoader 体系</h3><p>有了资源的定位，就要有资源加载。Spring利用<code>org.springframework.core.io.ResourceLoader</code>进行统一资源加载。</p><p><img src="/images/pasted-18.png" alt="资源加载"></p><h2 id="2-2-BeanFactory-体系"><a href="#2-2-BeanFactory-体系" class="headerlink" title="2.2 BeanFactory 体系"></a>2.2 BeanFactory 体系</h2><p><code>org.springframework.beans.factory.BeanFactory</code>，是一个非常纯粹的 bean 容器，它是 IoC 必备的数据结构，其中 BeanDefinition 是它的基本结构。BeanFactory 内部维护着一个BeanDefinition map ，并可根据 BeanDefinition 的描述进行 bean 的创建和管理。</p><p><img src="/images/pasted-19.png" alt="Bean的管理"></p><ul><li>BeanFactory 有三个直接子类 ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory 。</li><li>DefaultListableBeanFactory 为最终默认实现，它实现了所有接口。</li></ul><h2 id="2-3-BeanDefinition-体系"><a href="#2-3-BeanDefinition-体系" class="headerlink" title="2.3 BeanDefinition 体系"></a>2.3 BeanDefinition 体系</h2><p><code>org.springframework.beans.factory.config.BeanDefinition</code>，用来描述 Spring 中的 Bean 对象。</p><p><img src="/images/pasted-20.png" alt="Bean的描述"></p><h2 id="2-4-BeanDefinitionReader-体系"><a href="#2-4-BeanDefinitionReader-体系" class="headerlink" title="2.4 BeanDefinitionReader 体系"></a>2.4 BeanDefinitionReader 体系</h2><p><code>org.springframework.beans.factory.support.BeanDefinitionReader</code>，是读取 Spring 的配置文件的内容，也就是从 XML 中读取配置信息。并将其转换成 IoC 容器内部的数据结构 ：BeanDefinition 。</p><p><img src="/images/pasted-21.png" alt="Bean的转换"></p><h2 id="2-5-ApplicationContext-体系"><a href="#2-5-ApplicationContext-体系" class="headerlink" title="2.5 ApplicationContext 体系"></a>2.5 ApplicationContext 体系</h2><p><code>org.springframework.context.ApplicationContext</code>，这就是大名鼎鼎的Spring容器。它叫做应用上下文，与我们应用息息相关。它继承 BeanFactory ，所以它是 BeanFactory 的扩展升级版，如果BeanFactory 是屌丝的话，那么 ApplicationContext 则是名副其实的高富帅。由于 ApplicationContext 的结构就决定了它与 BeanFactory 的不同，其主要区别有：</p><ul><li>继承<code>org.springframework.context.MessageSource</code>接口，提供国际化的标准访问策略。</li><li>继承<code>org.springframework.context.ApplicationEventPublisher</code>接口，<strong>提供强大的事件机制。</strong></li><li>扩展 ResourceLoader，可以用来加载多种 Resource，可以灵活访问不同的资源。</li><li>对 Web 应用的支持。</li></ul><p>我们对 ApplicationContext 还是相对更熟悉一些的，例如我们 WEB 中用到的 XmlWebApplicationContext 就属于这个体系，还有 ClassPathXmlApplicationContext 等。<br><img src="/images/pasted-22.png" alt="复杂的Spring容器"></p><h2 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h2><p>上面的5个体系，是 Spring IoC 中的核心部分。其实 IoC 一看还是挺简单的，无外乎是将配置文件（暂时理解成XML）中的配置进行解析，然后将生成的对象放到一个 Map 里面，然后使用的时候直接从 Map 里面取就可以。但是真实的场景里面还是要面临很多的问题。</p></font>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试题</title>
      <link href="/2019/12/02/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/12/02/Spring%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<font size=3><blockquote><p>这套面试题，不包括Spring MVC部分。主要以IoC、AOP、Transction为主。</p></blockquote></font>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring IOC </tag>
            
            <tag> Spring AOP </tag>
            
            <tag> Spring 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java【基础】面试题</title>
      <link href="/2019/12/02/Java%E3%80%90%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2019/12/02/Java%E3%80%90%E5%9F%BA%E7%A1%80%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<font size=3><h1 id="Java的引用级别有什么区别？"><a href="#Java的引用级别有什么区别？" class="headerlink" title="Java的引用级别有什么区别？"></a><strong>Java的引用级别有什么区别？</strong></h1><blockquote><p> 不同的引用类型，主要体现的是对象的不同的可达性和对垃圾收集的影响。  </p></blockquote><ul><li>强引用<ul><li>最常见的普通对象引用，只要还有强引用指向一个对象，就表示这个对象活着，垃圾收集器不会碰这种对象。但是只要超过了引用的作用域或者显示的将强引用对象赋值为null，就是可以被垃圾回收。</li></ul></li><li>软引用<ul><li>相对比强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM认为内存不足时，才会去试图回收软引用对象。JVM会确保在抛出OOM以前将软引用指向的对象清理掉。通常来实现内存敏感的缓存。</li></ul></li><li>弱引用<ul><li>它和软引用类似，但是它不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的路径。比如维护一种非强制性的映射关系。</li></ul></li><li>虚引用<ul><li>无法通过虚引用访问对象，虚引用仅仅是提供了一种finalize后做某些事情的机制。  </li></ul></li></ul><p><strong>所有的引用类型都是在java.lang.Reference抽象类的子类，通过get()方法可以获得。</strong></p><h1 id="Exception和Error的区别？"><a href="#Exception和Error的区别？" class="headerlink" title="Exception和Error的区别？"></a><strong>Exception和Error的区别？</strong></h1><blockquote><p>Exception和Error都是继承Throw类，在Java中只有Throwable类的实例才可以throw和catch，它是异常处理机制的基本组成。</p></blockquote><p>Exception和Error是两种不同的设计理念，Exception是程序正常运行中可以被预料到的意外形况，可以进行相应的处理。 Error是在正常情况以外，突然出现的问题。大部分的Error都会导致程序的崩溃，不可恢复。很多时候，我们是很难显性的看到Error的，例如OOM。<br>Exceptoin分为<strong>可检查异常</strong>和<strong>不可检查异常</strong>两种：  </p><ul><li>可检查异常必须显示的进行捕获处理，这时编译期检查的一部分，例如当我们使用File对象的时候，经常出现的文件不存在异常，这种异常是编译器在编译时帮我们想到的异常情况。  </li><li>不可检查异常就是runtime exception，是程序在运行期间发生的异常，比如从List中取值的代码，可能平时都是正常运行的，突然就出现了脚标越界的异常，但是下一次执行又正常了，这种异常就是不可检查的，因为它的动态的。 </li></ul><h2 id="ClassNotFoundException和NoClassDefFoundError有什么区别？"><a href="#ClassNotFoundException和NoClassDefFoundError有什么区别？" class="headerlink" title="ClassNotFoundException和NoClassDefFoundError有什么区别？"></a>ClassNotFoundException和NoClassDefFoundError有什么区别？</h2><ul><li>首先，它们一个的Exception的实例，一个是Error的实例，这就是最大的区别。</li><li>ClassNotFoundException体现在，当程序运行期间尝试使用类加载去加载某一个Class文件，但是在classpath中没有找到，例如通过反射Class.forName()去实例化某一个类，如果它不存在，就抛出这个Exception。</li><li>NoClassDefFoundError体现在，一个类在编译期间存在，但是运行时找不到这个类的定义，JVM就抛出这个Error。</li></ul><p><img src="/images/pasted-2.png" alt="异常错误关系图"></p><p><strong>要理解Throwable、Exception、Error的设计和分类，要知道它们三者之间的关系，并且有一个原则就是尽量小的范围去catch异常，不要catch Exception这种根本不知道为什么出错的异常。异常的处理腰围后续排查做准备，不要为后续工作增加负担。</strong><br>如果从性能的方面出发，我们要知道Java的异常在实例每一个Exception时都会对当时的栈进行快照，这是一个相对比较重的操作，如果发生的频繁了那么性能开销不低。当我们的服务出现反应慢、吞吐量下降时，优化的一个思路可能从检查频繁的Exception出发。</p><h1 id="final、finally、finalize有什么区别？"><a href="#final、finally、finalize有什么区别？" class="headerlink" title="final、finally、finalize有什么区别？"></a><strong>final、finally、finalize有什么区别？</strong></h1><blockquote><p>这就是一个垃圾的题，感觉没什么用。</p></blockquote><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final可以修饰类、方法、变量。修饰后的类代表不可以继承，修饰后的变量是不可以修改的，而final的方法也不可以重写。<br><strong>但是final并不等于immutable。</strong>一个List变量，我们只能约束这个List不可以改变，但是不能约束它调用add方法。假如我们就是想要一个immutable类怎么办？ </p><ol><li>将class声明成final，这样别人就不能通过继承来扩展。</li><li>将所有成员变量定位为private和final，并且不要使用setter方法。</li><li>在构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，因为你无法确定输入对象不被其他人修改。深度拷贝可以使用JSON来实现。对象–JSON–对象。</li><li>如果需要提供getter方法，那么使用copy-on-write原则。及写入操作时通过复制一个全新的对象，然后将old对象指向new对象，释放锁。读取操作没有枷锁，多线程下不保证数据一致性。</li></ol><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>finally是java异常处理的一种机制，try-catch-finally。保证在try语句后一定会执行finally中的代码。大部分的时候我们都是将资源流在这里关闭，但是更推荐使用JDK7以后的try-catch-resource语句。<br><em>主要是实现AutoCloseable接口</em></p><pre><code>//通过实现AutoCloseable接口，JVM会自动调用内部的close方法public class Resource implements AutoCloseable {    public void sayHello() {        System.out.println(&quot;hello&quot;);    }    @Override    public void close() throws Exception {        System.out.println(&quot;Resource is closed&quot;);    }}public class CloseResourceIn7 {    public static void main(String[] args) {        //将资源流在try语句的括号中声明，如果有多个资源使用分号分割。        try(Resource resource = new Resource()) {            resource.sayHello();        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><h2 id="finalizefinalize是Object对象的一个方法，JDK9以后标记为不推荐使用。"><a href="#finalizefinalize是Object对象的一个方法，JDK9以后标记为不推荐使用。" class="headerlink" title="finalizefinalize是Object对象的一个方法，JDK9以后标记为不推荐使用。"></a>finalizefinalize是Object对象的一个方法，JDK9以后标记为不推荐使用。</h2><h1 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a><strong>重载和重写的区别？</strong></h1><pre><code>class main{ public static void main(String[] arrgs){     Animal o = new Dog();        o.test1(&quot;main&quot;);        o.test1(o);        //问：打印什么？为什么？    }}class Amimal{ public void test1(String str){     //打印：1    }    public void test1(Animal item){     //打印：2    }    public void test1(Dog item){     //打印：3    }}class Dgo extends Animal{    public void test1(String str){     //打印：str    }}</code></pre><blockquote><p>输入：str、2。结果就是重载与重写<strong>最重要</strong>区别，动态编译与静态编译。</p></blockquote><ul><li>重写：<ul><li>方法名、返回值、参数值相同。</li><li>子类不能缩小父类方法的访问权限。</li><li>子类不可以抛出比父类更多的异常，但是也不抛。</li><li>方法被定义为final的，不可以重写。</li><li>动态编译：在运行时根据实际类型来确定，每个类的方法区都有它自己的虚拟方法表。  </li></ul></li><li>重载：<ul><li>参数类型、个数、顺序至少有一项不同。</li><li>不可以只变化返回值。</li><li>静态编辑：在编译时根据静态类型来确定，Animal o = new Dog(); Animal就是静态类型，编译期可知。</li></ul></li></ul><h1 id="Java-中的几种基本数据类型是什么？占多少字节？占多少位？"><a href="#Java-中的几种基本数据类型是什么？占多少字节？占多少位？" class="headerlink" title="Java 中的几种基本数据类型是什么？占多少字节？占多少位？"></a><strong>Java 中的几种基本数据类型是什么？占多少字节？占多少位？</strong></h1><blockquote><p>Java 支持的数据类型包括基本数据类型和引用类型。</p></blockquote><p>基本数据类型：</p><table><thead><tr><th>类型</th><th align="center">字节</th><th align="center">位</th><th align="center">取值范围</th></tr></thead><tbody><tr><td>boolean</td><td align="center">1</td><td align="center">1</td><td align="center"></td></tr><tr><td>byte</td><td align="center">1</td><td align="center">8</td><td align="center">-2的7次方到2的7次方-1</td></tr><tr><td>short</td><td align="center">2</td><td align="center">16</td><td align="center">-2的15次方到2的15次方-1</td></tr><tr><td>char</td><td align="center">2</td><td align="center">16</td><td align="center"></td></tr><tr><td>int</td><td align="center">4</td><td align="center">32</td><td align="center">-2的31次方到2的31次方-1</td></tr><tr><td>float</td><td align="center">4</td><td align="center">32</td><td align="center"></td></tr><tr><td>long</td><td align="center">8</td><td align="center">64</td><td align="center">-2的63次方到2的63次方-1</td></tr><tr><td>double</td><td align="center">8</td><td align="center">64</td><td align="center"></td></tr></tbody></table><p>引用数据类型：</p><ul><li>包括类、接口、数组等。</li></ul><h1 id="非static方法中能调用static变量吗？"><a href="#非static方法中能调用static变量吗？" class="headerlink" title="非static方法中能调用static变量吗？"></a><strong>非static方法中能调用static变量吗？</strong></h1><p>不可以，<code>static</code>变量是属于类等，它在所有实例中的值都是不变的。在了解<strong>类加载机制</strong>后我们就知道，<code>static</code>变量在<strong>连接</strong>阶段就拥有了默认值，这时类还没有经历<strong>初始化</strong>阶段。</p><h1 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a><strong>String、StringBuffer、StringBuilder 的区别？</strong></h1><blockquote><p>Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。</p></blockquote><p>String：只读字符串，String类是final的内容不可改变。  </p><blockquote><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</p></blockquote><p>StringBuffer/StringBuilder：可以直接进行修改自身，它俩的操作完全相同，区别在于StringBuilder是单线程有线程安全问题。</p><blockquote><p>有时我们为了避免每个线程重复创建 StringBuilder 对象，会通过 ThreadLocal + StringBuilder 的方式，进行对 StringBuilder 的重用。</p></blockquote><h1 id="equals-与-的区别？"><a href="#equals-与-的区别？" class="headerlink" title="equals 与 == 的区别？"></a><strong>equals 与 == 的区别？</strong></h1><p><code>==</code>对比的是对象堆空间的地址，如果两个不同的对象说同一个内存地址，就是true。<code>equals</code>是Object对象的方法，判断的是具体的值。</p><h1 id="java-lang-Object-对象中-hashCode-和-equals-方法的关系？"><a href="#java-lang-Object-对象中-hashCode-和-equals-方法的关系？" class="headerlink" title="java.lang.Object 对象中 hashCode 和 equals 方法的关系？"></a><strong>java.lang.Object 对象中 hashCode 和 equals 方法的关系？</strong></h1><p>当我们准备重写equals方法时，大部分的时候都要连带着重写hashCode方法。这主要是为了在集合中使用这个对象的时候避免<strong>哈希碰撞</strong>当发生。两个不同的对象，它们的哈希值是可能一样的。</p><ul><li>equals不相等，hashCode可能相等。</li><li>equals相等，就要重写hashCode方法，保证hashCode相等。//大部分时候使用31这个质数来操作。</li></ul><h1 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a><strong>什么是序列化？</strong></h1><blockquote><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。</p></blockquote><ul><li>可以对流话后的对象进行读写操作，可以传输于网络。</li><li>序列化是为了解决在对象流进行读写操作时引发的问题。</li></ul><p>反序列化的过程则是与序列化相反。</p><blockquote><p>但是我们要知道，序列化并不是局限的把对象转换成二进制数组，将一个对象换成成XML、JSON也是序列化。</p></blockquote><h2 id="如何序列化？"><a href="#如何序列化？" class="headerlink" title="如何序列化？"></a>如何序列化？</h2><blockquote><p>下面的例子是使用Java内置的方案，实际场景中我们可以使用Google Protobuf序列化方案。</p></blockquote><p>将需要被序列化的类，实现<strong>Serializable</strong>接口，该接口没有具体的序列化方法，仅仅是标记当前的类可以被序列化。</p><ul><li>序列化<ul><li>使用一个输出流（如：FileOutputStream）来构造一个ObjectOutputStream（对象流）。</li><li>使用，ObjectOutputStream的<code>writeObject(Object obj)</code>方法，就可以将参数<code>obj</code>的对象序列化。</li></ul></li><li>反序列化<ul><li>想要恢复序列化，需要使用输入流。</li></ul></li></ul><p><em>如果有一些变量不想序列化可以使用<code>transient</code>关键字修饰，这个关键字只能修饰变量。</em></p><h1 id="如何实现对象克隆？"><a href="#如何实现对象克隆？" class="headerlink" title="如何实现对象克隆？"></a>如何实现对象克隆？</h1><ul><li>实现Cloneable接口，重写Object类中的clone方法，就可以实现浅克隆和深克隆。</li><li>通过序列化与反序列化来实现深克隆。</li></ul><p><em>使用序列化时要注意避免修改序列化对象，如果修改了很可能造成，以前序列化出来的对象反序列化失败。</em></p><blockquote><p>之所以区分深克隆和浅克隆主要的关键在于对象引用，浅克隆出来的对象它们的对象引用说指向同一个对象，深克隆的对象所有的一切都是自己独有的。</p></blockquote></font>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾收集机制</title>
      <link href="/2019/11/30/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/11/30/Java%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域详解</title>
      <link href="/2019/11/30/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/11/30/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Java虚拟机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM堆、栈 </tag>
            
            <tag> 内存溢出异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解ClassLoader</title>
      <link href="/2019/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ClassLoader/"/>
      <url>/2019/11/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ClassLoader/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这在面试中算是比较深的问题了，当我们将.class文件从硬盘读取到内存中供我们使用，JVM经历了一系列的操作。</p></blockquote><p>&emsp; 我们看一下代码，对类的加载顺序有一个认识。下面的两版代码打印什么？</p><pre><code>public class Main {    public static void main(String[] args) {        Test test = Test.getInstance();        System.out.println(test.counter1);        System.out.println(test.counter2);    }}//写一个简单的单例class Test{    private static Test t = new Test();    public static int counter1;    public static int counter2 = 0;    private Test() {        counter1 ++;        counter2 ++;    }    public static Test getInstance(){        return t;    }}--------------第二版//修改类部分代码class Test{    public static int counter1;    public static int counter2 = 0;    private static Test t = new Test(); //修改类书写顺序    private Test() {        counter1 ++;        counter2 ++;    }    public static Test getInstance(){        return t;    }}</code></pre><h1 id="从硬盘到内存"><a href="#从硬盘到内存" class="headerlink" title="从硬盘到内存"></a>从硬盘到内存</h1><p>&emsp; 类的加载顺序主要分为：</p><p><img src="/images/pasted-15.png" alt="图解"></p><ul><li>加载：从硬盘将二进制文件加载到内存，将读到到数据放到JVM方法区中，然后在堆上创建一个Class对象用来封装这个类在方法区到数据结构。也就是一个镜像对象，每一个类都有一个自己到专属Class对象，所以在反射中我们可以使用Class对象来获取类到全部数据。</li><li>连接：<ul><li>验证：保证被加载类到正确性。验证结构、语义、字节码、兼容性等。</li><li>准备：为类到静态变量分配内存，并设置默认值。</li><li>解析：把类中的符号引用换成成直接引用。</li></ul></li><li>初始化：为类的静态变量赋正确的值。</li></ul><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>&emsp; <strong>所有的JVM类必须在被程序首次主动使用时才初始化，但是加载和连接阶段已经发生。</strong><br>&emsp; 这里我们要说明一下主动使用场景：</p><ul><li>new对象，当我们手动创建一个对象时。</li><li>访问某个类到静态变量。</li><li>调用某个类到静态方法。</li><li>通过Class类进行反射操作。</li><li>初始化一个类的子类。</li><li>JVM启动时通过参数标明为默认启动到类。</li></ul><p>&emsp; 有主动就有被动，被动使用并不会触发初始化：</p><ul><li>当我们通过子类到静态方法获取父类到静态变量。</li><li>创建数组对象。<strong>E.g.&emsp; Student[] s = new Student[1]</strong>。</li><li>Classloader的loadClass方法会加载一个类，但不是主动使用，不初始化。</li></ul><h1 id="类加载器对象"><a href="#类加载器对象" class="headerlink" title="类加载器对象"></a>类加载器对象</h1><blockquote><p>JVM通过类加载对象来读取.class文件，这里有一个重要到概念：双亲委派机制</p></blockquote><h2 id="类加载器类型"><a href="#类加载器类型" class="headerlink" title="类加载器类型"></a>类加载器类型</h2><ul><li>Bootstrap Classloader：JVM最顶级加载器，只负责加载最核心到类，不提供给开发者使用。</li><li>Extension Classloader：负责加载扩展类库，加载/lib/ext目录下到jar。</li><li>System Classloader：复杂加载classpath下面到所有jar和class文件，也就是说我们到业务代码都是通过它来加载到JVM中到。<blockquote><p>我们可以通过继承ClassLoader抽象类来实现<strong>自定义加载器</strong>，它的默认父加载器是System Classloader，加载器之前是关系并不是继承实现。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
            <tag> 类加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch-es的持久化方案</title>
      <link href="/2019/11/30/Elasticsearch-es%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88/"/>
      <url>/2019/11/30/Elasticsearch-es%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>es保证数据的安全和redis比较类似。都是才用log的形式。</p></blockquote><h1 id="持久化方案"><a href="#持久化方案" class="headerlink" title="持久化方案"></a>持久化方案</h1><ul><li>es同时将数据写入buffer和translog日志文件。</li><li>每间隔1秒，buffer中的数据写入一个segment file，并进入os cache中。这个时候就可以对外提供搜索服务。</li><li>写入os cache后将buffer中的数据清空。</li><li>一直重复上面的步骤，也就是一直像os cache和translog中写入数据。</li><li><strong>当translog文件比较大的时候，就触发了commit动作</strong><ul><li>首先重复1-3步骤，也就是先将buffer中数据清空。</li><li>写一个commit point到磁盘上，这个point表明了有哪些segment要写到磁盘上。</li><li>使用fsync将os cache中的数据，强行刷到磁盘上。</li><li>清空translog文件，创建一个新到translog文件。</li><li>触发commit默认是30分钟或者translog文件过大。</li></ul></li></ul><p>&emsp; <strong>这种存储原理最多丢失5s数据。</strong></p><h1 id="segment的merge"><a href="#segment的merge" class="headerlink" title="segment的merge"></a>segment的merge</h1><p>&emsp; es会自动维护内存中的各个segment file。</p><ul><li>选择一些相似大小到segment file merge成一个大的segment。</li><li>将新的segment file flush到磁盘上。</li><li>写一个新到commit point到磁盘上，这次到point排除掉旧到segment，使用刚刚merge到segment。</li><li>将新到segment file打开对外提供搜索服务，删除掉旧到segment。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch-TF&amp;IDF算法、Scroll搜索</title>
      <link href="/2019/11/30/Elasticsearch-TF-IDF%E7%AE%97%E6%B3%95%E3%80%81Scroll%E6%90%9C%E7%B4%A2/"/>
      <url>/2019/11/30/Elasticsearch-TF-IDF%E7%AE%97%E6%B3%95%E3%80%81Scroll%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="TF-amp-IDF"><a href="#TF-amp-IDF" class="headerlink" title="TF&amp;IDF"></a>TF&amp;IDF</h1><blockquote><p>es计算分数的算法，es的分数，是es给出的最直观的搜索文本与索引中的文本匹配度的一个分数。默认es会将返回的数据按照分数进行倒叙。</p></blockquote><p>&emsp; es的分数算法，是使用TF&amp;IDF算法来实现，这个算法的主要分成三个部分。</p><ul><li>搜索文本中各个词条，在field文本中出现的次数。次数越多，分数越高。权重较高。</li><li>搜索文本中各个词条，在整个索引中所有文档中的出现次数。次数越多，分数越低。</li><li>field的长度越长，分数越低。field的长度越短，分数越高。权重较低。</li></ul><p><strong>举一个例子：</strong><br>&emsp; 假如我们有三篇文章</p><ul><li>Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全问搜索引擎，基于RESTful web接口。</li><li>Solr是一个高性能，采用java开发，给予Lucene的全文搜索服务器。</li><li>Lucene是一个开源的全文检索引擎工具包，但它不是一个完整的全文检索引擎。</li></ul><p>&emsp; 这时，我们想通过一个inpute框检索系统中所有包含“Lucene”关键字的文章，es为这三篇文章，分别赋予了“Lucene”关键字的分数。然后通过?explain=true参数可以查询到一个query中的详细信息和分数的计算。</p><pre><code>GET /test2/article/_search?explain=true{  &quot;query&quot;: {    &quot;match&quot;: {      &quot;content&quot;: &quot;lucene&quot;    }  }}</code></pre><h1 id="Scroll大数据搜索"><a href="#Scroll大数据搜索" class="headerlink" title="Scroll大数据搜索"></a>Scroll大数据搜索</h1><p>&emsp; 如果一次将大量数据查询出来，那么性能就会很差。这时我们一般采用Scroll滚动查询，也就是每次查询一部分的数据，直到所有数据查询完成。Scroll搜索会在第一次搜索时保存一个当时数据的快照来缓存，后续给予这个快照进行搜索，这个期间如果数据发生了变化，用户是看不到的。Scroll不使用相关度分数排序，而且使用_doc排序，性能较高。<br>&emsp; 每次发送Scroll查询，我们需要指定一个Scroll的时间参数，每次搜索请求只要在这个时间内完成就可以。返回的结果会包含一个scroll_id，后续的请求必须带上一个scroll_id。<br>&emsp; Scoll主要进行海量数据的搜索，与分页的使用场景不同。分页主要用来一页一页搜索给用户看，Scroll主要用一批一批检索数据，让系统处理。</p><pre><code>GET /test2/article/_search?scroll=1m{  &quot;query&quot;: {    &quot;match_all&quot;: {}  },  &quot;sort&quot;: [&quot;_doc&quot;],  &quot;size&quot;: 1}//第二次查询使用返回的idGET /_search/scroll{  &quot;scroll&quot;:&quot;1m&quot;,  &quot;scroll_id&quot;:&quot;返回的scrollId&quot;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch-deep paging、mapping介绍</title>
      <link href="/2019/11/30/Elasticsearch-deep-paging%E3%80%81mapping%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/11/30/Elasticsearch-deep-paging%E3%80%81mapping%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="deep-paging"><a href="#deep-paging" class="headerlink" title="deep paging"></a>deep paging</h1><blockquote><p>深度分页是es分页的一个特点，它耗费了大量的性能。</p></blockquote><p>&emsp; es的分页语法使用from和size关键字和mysql limit使用一样，下标从0开始。</p><pre><code>    GET /index/type/_search?from=0&amp;size=10    GET /index/type/_search?from=10&amp;size=10</code></pre><p>&emsp; 深度分页搜索，当在大量数据中使用分页，就会发生这种问题。<br>&emsp; 假如我们分页查询第100页，每页10条，一共有6000条数据，也就是取出1001-1010条数据。这些数据保存在三个shard中，每个shard保存2000条。请求到达协调节点，协调节点向三个shard转发。这时每个shard都会从自己的2000条数据中，取出0-1010条数据返回给协调节点。<br>&emsp; 协调节点收到3030条数据后，进行排序，从排序后的数据中在取出1001-1010条数据返回给客户端。<br>&emsp; 之所以不是在shard内部排序好，然后返回30条数据，再由协调节点对30条数据进行整理。就是因为document中的_score导致，每个shard中数据的_score是不一样的，如果在内部排序那么最后的数据一定是不准确的。</p><h2 id="deep-paging引发的问题"><a href="#deep-paging引发的问题" class="headerlink" title="deep paging引发的问题"></a>deep paging引发的问题</h2><ul><li>耗费带宽：每次深度分页查询，都要返回大量的无用数据占用带宽。</li><li>耗费内存：这些无用数据也占用了大量的内存，</li><li>耗费CPU：协调节点每次都需要对这些数据进行排序，然后在返回。</li></ul><h1 id="mapping介绍"><a href="#mapping介绍" class="headerlink" title="mapping介绍"></a>mapping介绍</h1><p>&emsp; mapping就是index的type的元数据，每个type都有一个自己的mapping，决定了数据类型、建立倒排索引的行为、还有可以进行搜索的行为。<br>&emsp; 当我们向es插入数据时，es会自动建立索引，同时建立type以及对应的mapping，mapping中定义了每一个field的数据类型。<br>&emsp; 不同的类型，比如text和date，可能有的是exact value，有的是full text类型。</p><ul><li>exact value在建立倒排索引的分词时，会将整个一个关键词建立在倒排索引中，处理搜索时，也要求关键词完全匹配才可以。</li><li>full text在建立倒排索引时会经过一系列的处理流程，例如大小写转换，同义词转换等等。处理搜索时</li></ul>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch-写一致性、返回解析</title>
      <link href="/2019/11/30/Elasticsearch-%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E8%BF%94%E5%9B%9E%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/11/30/Elasticsearch-%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E8%BF%94%E5%9B%9E%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="写一致性"><a href="#写一致性" class="headerlink" title="写一致性"></a>写一致性</h1><p>&emsp; 我们在发送任何一个增删改请求时，都可以要求es对节点的健康状况做判断。通过一个<strong>consistency</strong>参数来指明，我们当前这个请求的写一致性是什么。</p><ul><li>one：要求所有的primary shard都是活跃的。</li><li>all：要求所有的primary shard和replica shard都是活跃的。</li><li>quorum默认：要求所有的shard中，大部分都是活跃的。通过算法来设置一个quorum值，并且es限定了只有当replica shard的数量&gt;1的时候才可以使用，这就解释了为什么1台节点的时候，我们也可以正常操作。当quorum不足时，进行wait默认1分钟，然后timeout。</li></ul><h1 id="search返回内容解析"><a href="#search返回内容解析" class="headerlink" title="_search返回内容解析"></a>_search返回内容解析</h1><pre><code>GET /_search?timeout=10ms    {      &quot;took&quot;: 5,      &quot;timed_out&quot;: false,      &quot;_shards&quot;: {        &quot;total&quot;: 5,        &quot;successful&quot;: 5,        &quot;skipped&quot;: 0,        &quot;failed&quot;: 0      },      &quot;hits&quot;: {        &quot;total&quot;: 3,        &quot;max_score&quot;: 1,        &quot;hits&quot;: [          {            &quot;_index&quot;: &quot;mamber&quot;,            &quot;_type&quot;: &quot;account&quot;,            &quot;_id&quot;: &quot;2&quot;,            &quot;_score&quot;: 1,            &quot;_source&quot;: {              &quot;name&quot;: &quot;lisi&quot;,              &quot;age&quot;: 22            }          }        ]      }    }</code></pre><ul><li>took：搜索使用的毫秒。</li><li>timed_out：默认我们只有将一次请求的数据完整请求后才返回，但是通过设置timeout，我们可以要求es尽量在期间内将搜索到的部分数据直接返回给client端，而不是等待全部数据。</li><li>hits.total：总条数</li><li>hits.max_score：所有结果中，最高的匹配度分数。</li><li>hits.hits：默认前10条数据，按照分数倒叙。</li></ul><p><img src="/images/pasted-14.png" alt="time_out"></p>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch-路由算法、请求原理</title>
      <link href="/2019/11/30/Elasticsearch-%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E3%80%81%E8%AF%B7%E6%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2019/11/30/Elasticsearch-%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E3%80%81%E8%AF%B7%E6%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h1><blockquote><p>一个index的数据会分为多片，每片在一个shard上。所以说一个document只能存在一个shard中，当创建document的时候，es就需要决定这个document要保存到哪个shard上，这个过程就是document routing，数据路由。</p></blockquote><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><blockquote><p>shard = hash（routing number） % number_of_primary_shards。</p></blockquote><p>&emsp; 这就是es计算一个document保存在哪个shard使用的算法。需要注意的是，这里面的routing_number默认是id，可以手动设置。同样的routing_number经过hash函数后的值是相同的。无论hash后的数值是多少，与primaryShards取余后，一定小于等于它。<br>&emsp; 这也就解释了为什么我们可以通过参数修改replica shard但是不能修改primary shard，因为它参与了routing算法。</p><h1 id="请求原理"><a href="#请求原理" class="headerlink" title="请求原理"></a>请求原理</h1><h2 id="写原理"><a href="#写原理" class="headerlink" title="写原理"></a>写原理</h2><p><img src="/images/pasted-12.png" alt="图解"></p><p>&emsp; 当一个请求决定创建document时，可以任意选一个primary shard进行请求。接受到请求的primary shard就升级成为<strong>协调节点</strong>，通过上面将的routing算法得出一个需要保存的shard地址，然后将这个请求路由到算法的节点上，primary shard创建完成后，同步到自己的replica shard。都处理完成后，通知协调节点自己已经工作完成了，然后由协调节点响应client端。</p><h2 id="读原理"><a href="#读原理" class="headerlink" title="读原理"></a>读原理</h2><p><img src="/images/pasted-13.png" alt="图解"></p><p>&emsp; es在处理一个请求时，会将请求打到所有的shard上面，因为每个shard都包含了部分数据，但是如果primary shard存在replica shard，那么请求也可以打到replica shard上。</p>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos-配置中心</title>
      <link href="/2019/11/30/nacos-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
      <url>/2019/11/30/nacos-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Nacos是阿里巴巴为SpringCloud-Alibaba提供的注册中心与配置中心组件，提供了服务发现与管理、动态配置管理、动态DNS服务三大功能。Nacos在1.0.0版本后支持AP与CP两种一致性协议并存。<br>这里我们主要介绍Nacos在SpringCloud中的应用场景。   </p></blockquote><h1 id="为什么我们使用Nacos？"><a href="#为什么我们使用Nacos？" class="headerlink" title="为什么我们使用Nacos？"></a>为什么我们使用Nacos？</h1><p>&emsp; 当前的SpringCloud生态拥有多种注册中心，官方推荐的Eureka、强大的Zookeeper、超级火的Consul。那么为什么我们还要使用Nacos呢？<br>&emsp; 在国内，阿里巴巴一直是推广和使用Java的行业老大，它推动了国内Java行业的发展。这一次微服务浪潮，阿里巴巴也选择跟进，在最开始将Dubbo复活，并且推出了Spring-Cloud-Dubbo组件，后续推出了一整套的解决方案在Spring基金会进行孵化。Nacos就是这一批组件中的一份子。我们要相信阿里巴巴对行业的冲击，所以我们选择学习SpringCloud-Alibaba生态。</p><h1 id="Nacos的优势有哪些"><a href="#Nacos的优势有哪些" class="headerlink" title="Nacos的优势有哪些?"></a>Nacos的优势有哪些?</h1><ul><li>它整合了注册中心与配置中心，使用Eureka的时候，Eureka只能作为服务注册中心，如果我们想使用配置中心，需要在使用SpringCloud-Config组件进行配置。</li><li>提供了图形化页面方便操作。</li><li>在<strong>注册中心</strong>方面，它同时支持AP和CP协议。</li><li>Eureka与Zookeeper都不能支持大规模的服务实例，Eureka会将所有的实例在Eureka Server中保存，大量的实例造成大量的心跳检测，导致Eureka无法支持高并发操作。Zookeeper会将服务的上下线通知到每一个实例，如果频繁的上下线，会去通知大量实例，造成性能下降。</li><li>Nacos的开源版本中，官方提供的数据是支持100万个服务实例注册，服务的数量可以达到10万以上，哪怕在实际部署中有水分，这个数量也是很恐怖的。</li></ul><h1 id="使用NacosConfig。"><a href="#使用NacosConfig。" class="headerlink" title="使用NacosConfig。"></a>使用NacosConfig。</h1><h2 id="启动Nacos。"><a href="#启动Nacos。" class="headerlink" title="启动Nacos。"></a>启动Nacos。</h2><p>&emsp; 在<a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">Nacos发布地址</a>下载最新版的Nacos应用，启动\bin\startup.cmd命令，通过<a href="http://127.0.0.1:8848/nacos/#/login" target="_blank" rel="noopener">Nacos启动地址</a>查看Nacos是否启动成功，账号密码nacos。<br><img src="/images/pasted-8.png" alt="nacos首页"></p><h2 id="SpringCloud集成NacosConfig。"><a href="#SpringCloud集成NacosConfig。" class="headerlink" title="SpringCloud集成NacosConfig。"></a>SpringCloud集成NacosConfig。</h2><p>&emsp; 首先我们要清楚的知道SpringBoot和SpringCloud有什么区别？SpringCloud是基于SpringBoot开发的微服务架构，提供了大量微服务组件。其实它也就是一个SpringBoot项目而已。我们现在使用Nacos的Config功能，并不需要引用Spring-Cloud的版本，但是我们需要使用到Cloud的注解，所以这里我们使用<strong>spring-cloud-starter-alibaba-nacos-config</strong>这个Maven地址，而不是<strong>nacos-config-spring-boot-starter</strong>。<br>&emsp; Nacos提供与多种技术集成的方式，Spring、SpringBoot、SpringCloud、Docker、k8s等。Nacos这个组件并不是简简单单的局限在SpringCloud-Alibaba这个生态内，它是<strong>单独发布</strong>的。  </p><p>&emsp; <em>首先我们要创建一个普通的SpringBoot应用，要求2.X的版本，需要引入的组件有：LomBok、Spring Web</em>  </p><h3 id="在pom-xml中引入Nacos-config。"><a href="#在pom-xml中引入Nacos-config。" class="headerlink" title="在pom.xml中引入Nacos-config。"></a>在pom.xml中引入Nacos-config。</h3><pre><code>    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-config --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="配置boostrap-yml。"><a href="#配置boostrap-yml。" class="headerlink" title="配置boostrap.yml。"></a>配置boostrap.yml。</h3><pre><code>spring:  application:    name: nacos-config  cloud:    nacos:      config:        server-addr: 127.0.0.1:8848        file-extension: yaml  profiles:    active: dev</code></pre><p><em>在Nacos Spring Cloud中，dataId的格式：${prefix}-${spring.profile.active}.${file-extension}</em>  </p><ul><li>prefix默认为applicationName，也可以spring.cloud.nacos.config.prefix配置。</li><li>spring.profiles.active是当前环境对应的profile，如果不配置，dataId的格式变为：${prefix}.${file-extension}</li><li>file-extension是文件的后缀地址，目前只支持<strong>properties、yaml</strong>。</li></ul><h3 id="设置配置。"><a href="#设置配置。" class="headerlink" title="设置配置。"></a>设置配置。</h3><p><em>这里我们配置一个动态的userName</em><br>&emsp; 在<a href="http://127.0.0.1:8848/nacos/#/login" target="_blank" rel="noopener">Nacos首页</a>增加一个新的配置。<br><img src="/images/pasted-9.png" alt="添加配置"><br><img src="/images/pasted-10.png" alt="添加配置"></p><pre><code>//注意：这里不是yml，是yaml。dataId : nacos-config-dev.yamlgroup : DEFAULT_GROUP配置项userName: 张三</code></pre><p><strong>需要注意一点是dataId要符合boostrap.yml中配置的信息一致。</strong></p><h3 id="读取配置。"><a href="#读取配置。" class="headerlink" title="读取配置。"></a>读取配置。</h3><p><em>我们使用一个Controller来动态的读取这个userName</em></p><pre><code>@RestController@RefreshScope //使用SpringCloud原生注解来实现自动刷新public class MainController {    @Value(&quot;${userName}&quot;)    private String userName;    @RequestMapping(&quot;/say&quot;)    public String say(){        return &quot;hello &quot; + userName;    }}</code></pre><p><a href="http://127.0.0.1:8080/say" target="_blank" rel="noopener">启动项目</a>，查看userName的变化。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-cloud-alibaba </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nacos-注册中心</title>
      <link href="/2019/11/30/nacos-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
      <url>/2019/11/30/nacos-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/pasted-11.png" alt="注册中心示例"></p><blockquote><p>通过上图，我们可以看到一个简单的服务发现并调用的机制。</p></blockquote><h1 id="配置member服务"><a href="#配置member服务" class="headerlink" title="配置member服务"></a>配置member服务</h1><h2 id="在pom-xml中引入Nacos-Discovery"><a href="#在pom-xml中引入Nacos-Discovery" class="headerlink" title="在pom.xml中引入Nacos-Discovery"></a>在pom.xml中引入Nacos-Discovery</h2><pre><code>        &lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;        &lt;/dependency&gt;</code></pre><h2 id="在bootstrap-yml中配置Nacos地址"><a href="#在bootstrap-yml中配置Nacos地址" class="headerlink" title="在bootstrap.yml中配置Nacos地址"></a>在bootstrap.yml中配置Nacos地址</h2><pre><code>//注意这里只使用的NacosDiscovery没有使用NacosConfig。server:  port: 9991spring:  application:    name: user  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8848</code></pre><h2 id="通过Cloud原生注解-EnableDiscoveryClient开启服务发现"><a href="#通过Cloud原生注解-EnableDiscoveryClient开启服务发现" class="headerlink" title="通过Cloud原生注解@EnableDiscoveryClient开启服务发现"></a>通过Cloud原生注解@EnableDiscoveryClient开启服务发现</h2><pre><code>@SpringBootApplication@EnableDiscoveryClientpublic class WhyApplication {    public static void main(String[] args) {        SpringApplication.run(WhyApplication.class, args);    }}</code></pre><h1 id="配置order服务"><a href="#配置order服务" class="headerlink" title="配置order服务"></a>配置order服务</h1><h2 id="按照上面的配置，在配置一个端口不一样的applicationName-order的服务"><a href="#按照上面的配置，在配置一个端口不一样的applicationName-order的服务" class="headerlink" title="按照上面的配置，在配置一个端口不一样的applicationName=order的服务"></a>按照上面的配置，在配置一个端口不一样的applicationName=order的服务</h2><h2 id="在order服务中对外提供服务"><a href="#在order服务中对外提供服务" class="headerlink" title="在order服务中对外提供服务"></a>在order服务中对外提供服务</h2><pre><code>@RestControllerpublic class OrderController {    @GetMapping(&quot;/list&quot;)    public String list(){        return &quot;返回订单列表&quot;;    }}</code></pre><h1 id="在mamber服务中调用order服务"><a href="#在mamber服务中调用order服务" class="headerlink" title="在mamber服务中调用order服务"></a>在mamber服务中调用order服务</h1><h2 id="配置RestTemplate"><a href="#配置RestTemplate" class="headerlink" title="配置RestTemplate"></a>配置RestTemplate</h2><blockquote><p>RestTemplate是Spring提供的全家桶的一员，它的底层是对HttpClient进行了封装。</p></blockquote><pre><code>@Componentpublic class RestTemplateConfig {    @Bean    @LoadBalanced    public RestTemplate restTemplate(){        return new RestTemplate();    }}</code></pre><h2 id="调用order服务"><a href="#调用order服务" class="headerlink" title="调用order服务"></a>调用order服务</h2><pre><code>@RestControllerpublic class UserController {    @Autowired    private RestTemplate restTemplate;    @GetMapping(&quot;/get/order&quot;)    public String getOrder(){        return restTemplate.getForObject(&quot;http://order/list/&quot;,String.class);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring-cloud-alibaba </tag>
            
            <tag> 注册中心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch-shard、扩容介绍</title>
      <link href="/2019/11/30/Elasticsearch-shard%E3%80%81%E6%89%A9%E5%AE%B9%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/11/30/Elasticsearch-shard%E3%80%81%E6%89%A9%E5%AE%B9%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是shard？"><a href="#什么是shard？" class="headerlink" title="什么是shard？"></a>什么是shard？</h1><p>&emsp; 首先我们明确一个概念，每个index都是默认拥有5个P shard和与之对应的R shard组成。也就是说一个index拥有10个shard。我们的document通过es的处理保存在不同的P shard和R shard上。<strong>每一个shard都是磁盘上的某一块具体物理地址</strong>。<br>&emsp; Es为了保证高可用，在node宕机时不会造成服务无法访问、数据丢失等因素，它选择<strong>冗余的存储数据</strong>来避免。</p><ul><li>每一个index包含多个shard，最少是由1个P sahrd组成。在创建index时，P shard的数量就已经确定，后期无法进行更改。但是R shard是可以随时进行数量调整的。</li><li>每一个shard都是一个最小的工作单元，它承担了部分数据。是一个完整的Lucene实例，拥有完整的创建索引、处理请求的能力。这也就说明，一个R shard在P shard宕机时，是完全可以自主处理该shard组下的所有请求的。</li><li>在node发生变化时，shard会自动在node中进行负载均衡的分配，这一切都是es来帮助我们处理的。</li><li>每个document一定只保存在一个P shard以及对应的R shard中。不可能同时存在两个P shard中。</li><li>P shard不能和自己的R shard在同一个node上，但可以和其他的R shard在同一个node。</li></ul><pre><code>PUT /创建的索引{    &quot;settings&quot;:{        &quot;number_of_shards&quot;:5,        &quot;number_of_replicas&quot;1    }}</code></pre><h1 id="es的扩容"><a href="#es的扩容" class="headerlink" title="es的扩容"></a>es的扩容</h1><p>&emsp; es的扩容就像任何其他分布式应用扩容一样，分为垂直扩容与水平扩种两种。es会自动对扩容后的note进行负载均衡。</p><ul><li>垂直扩容：更新服务器的大小，服务器总数量不变。比如：两台16G内存的服务器（共32G），将其中一台替换为32G，服务器总数量=2，但是内存扩容到48G。</li><li>水平扩容：增加服务器数量，服务器总数量变化。比如：两台16G内存的服务区（共32G），新增一台16G服务器，服务器总数量=3，内存扩容到48G。 </li></ul><h2 id="扩容的极限"><a href="#扩容的极限" class="headerlink" title="扩容的极限"></a>扩容的极限</h2><p>&emsp; 通过扩容机制以及shard的特性，我们引出一个扩容极限的问题。那么什么是扩容极限？<br>&emsp; 我们知道每一个shard其实都是硬盘内的一个区域，它耗费着系统的IO/CPU/Memery资源。那么也就是说，如果一台node，上面只有1个shard岂不是就能占用全部的资源，这时也是es性能最好的时候。<br>&emsp; 但是这又引出了另一个问题，我们知道一个index，默认是有10个shard（5P 5R），也就是说当我们扩容到了10台node，就发生了扩容极限。我们每一个shard已经占用了当前note的全部资源。如果这时发生了性能问题，也就是说我们的10台note的集群都无法不足时，还要继续进行扩容。<br>处理方法就是：增加node，然后新增R shard，来继续进行负载均衡。不过这里要注意的是，我们在进行settings时，是以P shard的倍数进行设置。<br>&emsp; 举例：默认5P，每一个搭配1R，总shard数=10   |    修改R shard为2。默认5P，每一个搭配2R，总shard数=15。这时你的扩容极限就变为了15台。  </p><h2 id="尽可能的提高容错性"><a href="#尽可能的提高容错性" class="headerlink" title="尽可能的提高容错性"></a>尽可能的提高容错性</h2><p>&emsp; 当我们某一个node发生各种异常情况宕机，但是不影响服务的使用，保证数据查询的正确性。允许最多的note宕机，那么就越高可用、高容错。假如100台note，我们最多允许99台node宕机还能保证服务和数据正常。那么这就是超级高可用和超级高容错。。要是100台node，100个note都宕机了，还是能用，那这就太神了。。。<br>&emsp; 在3台note下，9个shard（3P 6R）的配置，容错性就很不错，我们最多同时允许2台note宕机</p><h1 id="分布式透明隐藏特性"><a href="#分布式透明隐藏特性" class="headerlink" title="分布式透明隐藏特性"></a>分布式透明隐藏特性</h1><p>&emsp; es是一套分布式系统，之所以分布式就是为了处理大数据。如果数量很小或者纯单机应用，那还不如用Solor或者直接用Lucene来实现。但是es的优势又不光光体现在分布式，它相比较前两者更简单好用，解压即用。为此它在内部实现了很多机制没有暴露给我们开发者。</p><ul><li>自动分片机制，当我们保存document时不需要考虑这个document要保存在什么shard上。取的时候也不需要特意指定shard。</li><li>集群发现机制，es使node自动加入相关或者默认的集群中接受集群的管理。</li><li>shard的负载均衡，es对各个node中的shard进行负载均衡，尽量不使某一个note压力过大。</li><li>请求路由，当我们准备从es获取数据使，我们并不需要关心真实的命中node和shard。只需访问一个es地址，es会自动将数据进行汇集处理响应回来。</li><li>集群扩容，当note的数量发生改变，shard需要重新进行分配。如何分配，怎么分配这些es都帮我们处理了。</li><li>master宕机node升级，假如我们的master节点发生了宕机，es会自动将某一个node升级为master节点，不会发生服务中断的情况。当master回归使，回来时master就变成了一个普通的node。</li><li>master节点主要是管理es集群的元数据，比如索引的创建和删除。node的创建和删除。master不承担所有的请求，也就不会造成性能瓶颈。</li><li>节点对等分布式架构：在es架构中，每一个node都能接受处理所有的请求，任何一个node接受请求后，都可以路由到相关node。最先接受请求的node，统一处理后将数据响应。也就是说集群中的所有node都是平等的，不存在master能做的事node不能做。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticssearch-安装、运行</title>
      <link href="/2019/11/30/Elasticssearch-%E5%AE%89%E8%A3%85%E3%80%81%E8%BF%90%E8%A1%8C/"/>
      <url>/2019/11/30/Elasticssearch-%E5%AE%89%E8%A3%85%E3%80%81%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><blockquote><p>Elasticsearch是一个分布式、高性能、高可用、可伸缩的搜索和分析系统。一个实时的分布式搜索分析引擎，它能让你以一个之前从未有过的速度和规模，去探索你的数据。它是全文检索、结构化搜索、分析这三个功能的组合。 </p></blockquote><p>&emsp; Elasticsearch是基于全文检索引擎Lucene之上，但是它不仅仅是一个全文搜索引擎，它可以被下面这样准确的形容：</p><ul><li>一个分布式的实施文档存储，每个字段都可以被索引与搜索。</li><li>一个分布式实时分析搜索引擎。</li><li>能胜任上百个服务节点的扩展，并支持PB级别的结构化或者非结构化数据。</li><li>自动维护数据冗余，避免服务宕机造成数据丢失。</li><li>基于Lucene封装更多支持，例如聚合搜索、基于地理位置的检索。</li></ul><p>&emsp; es支持九种基本数据类型：text、byte、short、integer、long、float、double、boolean、date。</p><h2 id="什么是倒排索引？"><a href="#什么是倒排索引？" class="headerlink" title="什么是倒排索引？"></a>什么是倒排索引？</h2><p>&emsp; 在我们搜索Elasticsearch时，总是看到说es是基于倒排索引进行查询，那么什么是倒排索引？当我们将一句话通过分词进行拆分，然后将每一个拆分后的词设置一个专门的id，最后将这些id进行整合就得到了倒排索引。<br>&emsp; 例如：这时，我们搜索《狮子》es会就去[1,2,3,4]的文档，然后展示出来。这个效率相比较数据库的like，快了不知道多少倍。当然中文分词的效果比英文分词要差很多，向百度之类的大厂，还是自己实现中文分词。</p><table><thead><tr><th>ID</th><th>文档</th></tr></thead><tbody><tr><td>1</td><td>狮子王电影预告</td></tr><tr><td>2</td><td>狮子王电影海报</td></tr><tr><td>3</td><td>狮子王剧透</td></tr><tr><td>4</td><td>狮子王电影海报剧透</td></tr></tbody></table><table><thead><tr><th>索引</th><th>文档地址</th></tr></thead><tbody><tr><td>狮子</td><td>1、2、3、4</td></tr><tr><td>狮子王</td><td>1、2、3、4</td></tr><tr><td>电影</td><td>1、2、4</td></tr><tr><td>海报</td><td>2、4</td></tr><tr><td>剧透</td><td>3、4</td></tr></tbody></table><h2 id="什么是全文检索？"><a href="#什么是全文检索？" class="headerlink" title="什么是全文检索？"></a>什么是全文检索？</h2><p>&emsp; 通过上面的倒排索引，我们已经可以很快的精确将某一个值快速的查找出来，但是这远远不够。如果我们忽略速度，这和数据库查询有什么区别？没有任何区别甚至还不如数据库。<br>&emsp; 倒排索引除了可以让我们更快的更精准的查到数据，还为全文索引做准备。上面了例子，我搜索“狮子”，当然可以把1，2，3，4四个文档的数据返回给我。甚至我搜索“狮”这一个字，数据库也有like，也搜索到这四个文档。<br>&emsp; 但是我如果搜索“老虎”呢？搜索“动物”呢？以数据库的思维这是绝对不会检索到的。但这不是我们希望的结果。我们希望可以将类似的、相近的数据返回。全文检索就是解决这个问题。当创建倒排索引时，也可以会分词创建一个相似，目的就是解决上面的问题。<br>&emsp; es的全文检索提供了很多强大的功能，例如：缩写（中国 -&gt; cn）、格式化、大小写、同义词等。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>Index<ul><li>类似于Mysql里面的database。</li></ul></li><li>Type  <ul><li>类似于mysql中的table，es可以在index中创建type，然后通过mapping进行映射。</li><li>在Lucene底层是不区分type的，同一个index下面的所有type都存储在一起，底层数据结构中通过_type这个field来进行type的区分。</li><li>当前index下所有document都是共享field的，也就是说，假如一个index下面保存人、动物两个type。虽然动物中没有field，但是人里面有。那么动物也就自然而然有了这个field，只不过是空值而已。所以我们要把具有相似field的数据放在一个index下，避免大量空值造成性能问题。</li></ul></li><li>Document&amp;field<ul><li>一个type是由多个Document组成的，类似一行数据，每一行数据是由多个field也就是列组成。</li></ul></li><li>Mapping<ul><li>用来表述数据、字段、表之间的关系和相关信息。例如创建索引，索引类型，是否保存原始索引，是否压缩，是否分词等等信息。</li></ul></li><li>Shard<ul><li>每一个index存储在多个分片中，里面冗余的保存的具体的document，es默认一个index由5个primary shard和5个replica shard组成。</li></ul></li><li>Replica<ul><li>为了避免shard宕机造成服务无法访问，es提供了replica进行高可用扩展。每一个shard分配一个replica，在shard宕机时可以提供服务，并且可以单独使用读服务。</li></ul></li></ul><h4 id="index和type到底有什么区别？"><a href="#index和type到底有什么区别？" class="headerlink" title="index和type到底有什么区别？"></a>index和type到底有什么区别？</h4><p>&emsp; 前面说了，把index理解成database，type理解成table。这只是为了更好了理解。由于两种数据存储的方式完全不一样，任何比喻都是为了更好的理解。但是往往把他们真实的用途掩盖。</p><ul><li>index<ul><li>Index存储在多个分片中，也就是Lucene index。它们有自己的资源开销。在我们搜索数据时，每个分片都需要搜索一次。然后ES通过自己的机制在整合从所有分片得到的数据。因此一个大的index，效率要比小index高。例如：搜索10个index，每个index拥有5个分片。那么本次检索的需要整合的数据就是10*5 = 50个分片结果。如果有大量的index和分片，发起一个搜索请求时，光是合并任务就要耗费大量的服务器资源。 </li></ul></li><li>type<ul><li>使用type允许我们在index中存储多种数据类型。这样就减少了index了数量。在使用时，向每个文档加入_type，然后检索的时候通过type搜索，就会过滤掉不相关的数据。搜索一个index下面的多个type和只所有一个type没有额外的开销。因为在数据整合时的数量都是一样分片。</li></ul></li><li>当然如果我们只是想es用于一个企业级的信息检索，它的很多功能我们都用不到。但是如果我们想让关系数据库中的关系也一同保存在es中，那么这里的type和index就要特别的注意一下。</li></ul><h2 id="单机安装"><a href="#单机安装" class="headerlink" title="单机安装"></a>单机安装</h2><blockquote><p>准备工作：jdk8以上版本、nodejs8以上版本。</p></blockquote><h3 id="server端安装"><a href="#server端安装" class="headerlink" title="server端安装"></a>server端安装</h3><p>&emsp; 1、访问<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">官网地址</a>地址，可以下载最新版，也可以在<a href="https://www.elastic.co/cn/downloads/past-releases" target="_blank" rel="noopener">past releases</a>中下载历史版本。<br><img src="/images/pasted-3.png" alt="下载页面">  </p><p>&emsp; 2、运行解压后的文件：*\Elasticsearch\bin\elasticsearch.bat，我们可以看到127.0.0.1:9200端口上跑起了我们es服务。<br>&emsp; 3、访问127.0.0.1:9200端口，安装成功。<br><img src="/images/pasted-4.png" alt="单机安装成功"></p><h3 id="head插件安装"><a href="#head插件安装" class="headerlink" title="head插件安装"></a>head插件安装</h3><p>&emsp; 因为Elasticsearch的返回数据都是json，不具备可读性。这里使用一个开源的插件，来展示数据。<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">下载地址</a><br>&emsp; <strong>该项目是基于nodejs的，需要nodejs8以上版本启动。进入解压目录，npm install下载node相关依赖，然后npm run start启动该项目。默认端口占用：9100。</strong></p><pre><code>#修改es中的配置文件，配置head插件http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;</code></pre><p>&emsp; 重启server端，head连接成功。</p><h3 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h3><blockquote><p>Kibana是es官方开源的一个数据分析和可视化平台，是一个增强版的head插件。<strong>下载Kibana时一定要注意版本，要与es的版本一致。</strong></p></blockquote><p>&emsp; 修改Kibana.yml配置文件，增加Elasticsearch访问路径。</p><pre><code>#配置es地址elasticsearch.url: &quot;http://localhost:9200&quot;</code></pre><p>&emsp; 启动Kibana，访问默认的5601端口。<br><img src="/images/pasted-5.png" alt="Kibana安装成功页面"></p><h2 id="集群安装"><a href="#集群安装" class="headerlink" title="集群安装"></a>集群安装</h2><blockquote><p>本次集群部署三台服务器，一台master节点，两台slave节点。</p></blockquote><h3 id="Master节点配置"><a href="#Master节点配置" class="headerlink" title="Master节点配置"></a>Master节点配置</h3><p>&emsp; 修改master节点的配置文件，增加配置信息。</p><pre><code>#master集群配置cluster.name: esnode.name: masternode.master: truenetwork.host: 127.0.0.1</code></pre><p>&emsp; 增加好配置信息后，重启es服务。查看head插件页面是否正确显示。</p><h3 id="Slave节点配置"><a href="#Slave节点配置" class="headerlink" title="Slave节点配置"></a>Slave节点配置</h3><p>&emsp; 修改slave节点的配置文件，增加配置信息</p><pre><code>#slave集群配置cluster.name: esnode.name: slave1network.host: 127.0.0.1http.port: 8200 #当前子节点占用的端口号discovery.zen.ping.unicast.hosts: [&quot;127.0.0.1&quot;] </code></pre><p>&emsp; 增加好配置信息后，重启es服务。查看head插件页面是否正确显示。<br><img src="/images/pasted-6.png" alt="集群安装成功"><br>&emsp; <strong>注意，这里复制文件夹时，尽量使用刚刚解压的，因为直接复制master文件夹，容易将data文件夹中是数据也一起复制过来，造成启动失败。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es </tag>
            
            <tag> 全文检索 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
